"""
This type stub file was generated by pyright.
"""

import tkinter as tk
import datetime
from tkinter import ttk

version = ...
_change_log = ...
__version__ = ...
port = ...
tclversion_detailed = ...
framework_version = ...
pil_import_attempted = ...
g_time_start = ...
g_time_end = ...
g_time_delta = ...
def timer_start(): # -> None:
    """
    Time your code easily.... starts the timer.
    Uses the time.time value, a technique known to not be terribly accurage, but tis' gclose enough for our purposes
    """
    ...

def timer_stop(): # -> int:
    """
    Time your code easily.... stop the timer and print the number of milliseconds since the timer start

    :return: delta in milliseconds from timer_start was called
    :rtype:  int
    """
    ...

_timeit_counter = ...
MAX_TIMEIT_COUNT = ...
_timeit_total = ...
def running_linux(): # -> bool:
    """
    Determines the OS is Linux by using sys.platform

    Returns True if Linux

    :return: True if sys.platform indicates running Linux
    :rtype:  (bool)
    """
    ...

def running_mac(): # -> bool:
    """
    Determines the OS is Mac by using sys.platform

    Returns True if Mac

    :return: True if sys.platform indicates running Mac
    :rtype:  (bool)
    """
    ...

def running_windows(): # -> bool:
    """
    Determines the OS is Windows by using sys.platform

    Returns True if Windows

    :return: True if sys.platform indicates running Windows
    :rtype:  (bool)
    """
    ...

def running_trinket(): # -> bool:
    """
    A special case for Trinket.  Checks both the OS and the number of environment variables
    Currently, Trinket only has ONE environment variable.  This fact is used to figure out if Trinket is being used.

    Returns True if "Trinket" (in theory)

    :return: True if sys.platform indicates Linux and the number of environment variables is 1
    :rtype:  (bool)
    """
    ...

def running_replit(): # -> bool:
    """
    A special case for REPLIT.  Checks both the OS and for the existance of the number of environment variable REPL_OWNER
    Currently, Trinket only has ONE environment variable.  This fact is used to figure out if Trinket is being used.

    Returns True if running on "replit"

    :return: True if sys.platform indicates Linux and setting REPL_OWNER is found in the environment variables
    :rtype:  (bool)
    """
    ...

DEFAULT_BASE64_ICON = ...
DEFAULT_BASE64_ICON_16_BY_16 = ...
DEFAULT_BASE64_LOADING_GIF = ...
PSG_DEBUGGER_LOGO = ...
UDEMY_ICON = ...
BLANK_BASE64 = ...
BLANK_BASE64 = ...
DEFAULT_WINDOW_ICON = ...
DEFAULT_ELEMENT_SIZE = ...
DEFAULT_BUTTON_ELEMENT_SIZE = ...
DEFAULT_MARGINS = ...
DEFAULT_ELEMENT_PADDING = ...
DEFAULT_AUTOSIZE_TEXT = ...
DEFAULT_AUTOSIZE_BUTTONS = ...
DEFAULT_FONT = ...
DEFAULT_TEXT_JUSTIFICATION = ...
DEFAULT_BORDER_WIDTH = ...
DEFAULT_AUTOCLOSE_TIME = ...
DEFAULT_DEBUG_WINDOW_SIZE = ...
DEFAULT_WINDOW_LOCATION = ...
MAX_SCROLLED_TEXT_BOX_HEIGHT = ...
DEFAULT_TOOLTIP_TIME = ...
DEFAULT_TOOLTIP_OFFSET = ...
DEFAULT_KEEP_ON_TOP = ...
DEFAULT_SCALING = ...
DEFAULT_ALPHA_CHANNEL = ...
TOOLTIP_BACKGROUND_COLOR = ...
TOOLTIP_FONT = ...
BLUES = ...
PURPLES = ...
GREENS = ...
YELLOWS = ...
TANS = ...
NICE_BUTTON_COLORS = ...
COLOR_SYSTEM_DEFAULT = ...
DEFAULT_BUTTON_COLOR = ...
OFFICIAL_PYSIMPLEGUI_BUTTON_COLOR = ...
OFFICIAL_PYSIMPLEGUI_THEME = ...
DEFAULT_ERROR_BUTTON_COLOR = ...
DEFAULT_BACKGROUND_COLOR = ...
DEFAULT_ELEMENT_BACKGROUND_COLOR = ...
DEFAULT_ELEMENT_TEXT_COLOR = ...
DEFAULT_TEXT_ELEMENT_BACKGROUND_COLOR = ...
DEFAULT_TEXT_COLOR = ...
DEFAULT_INPUT_ELEMENTS_COLOR = ...
DEFAULT_INPUT_TEXT_COLOR = ...
DEFAULT_SCROLLBAR_COLOR = ...
RELIEF_RAISED = ...
RELIEF_SUNKEN = ...
RELIEF_FLAT = ...
RELIEF_RIDGE = ...
RELIEF_GROOVE = ...
RELIEF_SOLID = ...
RELIEF_LIST = ...
THEME_DEFAULT = ...
THEME_WINNATIVE = ...
THEME_CLAM = ...
THEME_ALT = ...
THEME_CLASSIC = ...
THEME_VISTA = ...
THEME_XPNATIVE = ...
DEFAULT_TTK_THEME = ...
ttk_theme_in_use = ...
USE_TTK_BUTTONS = ...
DEFAULT_PROGRESS_BAR_COLOR = ...
DEFAULT_PROGRESS_BAR_COMPUTE = ...
DEFAULT_PROGRESS_BAR_COLOR_OFFICIAL = ...
DEFAULT_PROGRESS_BAR_SIZE = ...
DEFAULT_PROGRESS_BAR_BORDER_WIDTH = ...
DEFAULT_PROGRESS_BAR_RELIEF = ...
DEFAULT_PROGRESS_BAR_STYLE = ...
DEFAULT_METER_ORIENTATION = ...
DEFAULT_SLIDER_ORIENTATION = ...
DEFAULT_SLIDER_BORDER_WIDTH = ...
DEFAULT_SLIDER_RELIEF = ...
DEFAULT_FRAME_RELIEF = ...
DEFAULT_LISTBOX_SELECT_MODE = ...
SELECT_MODE_MULTIPLE = ...
LISTBOX_SELECT_MODE_MULTIPLE = ...
SELECT_MODE_BROWSE = ...
LISTBOX_SELECT_MODE_BROWSE = ...
SELECT_MODE_EXTENDED = ...
LISTBOX_SELECT_MODE_EXTENDED = ...
SELECT_MODE_SINGLE = ...
LISTBOX_SELECT_MODE_SINGLE = ...
TABLE_SELECT_MODE_NONE = ...
TABLE_SELECT_MODE_BROWSE = ...
TABLE_SELECT_MODE_EXTENDED = ...
DEFAULT_TABLE_SELECT_MODE = ...
TABLE_CLICKED_INDICATOR = ...
DEFAULT_MODAL_WINDOWS_ENABLED = ...
DEFAULT_MODAL_WINDOWS_FORCED = ...
TAB_LOCATION_TOP = ...
TAB_LOCATION_TOP_LEFT = ...
TAB_LOCATION_TOP_RIGHT = ...
TAB_LOCATION_LEFT = ...
TAB_LOCATION_LEFT_TOP = ...
TAB_LOCATION_LEFT_BOTTOM = ...
TAB_LOCATION_RIGHT = ...
TAB_LOCATION_RIGHT_TOP = ...
TAB_LOCATION_RIGHT_BOTTOM = ...
TAB_LOCATION_BOTTOM = ...
TAB_LOCATION_BOTTOM_LEFT = ...
TAB_LOCATION_BOTTOM_RIGHT = ...
TITLE_LOCATION_TOP = ...
TITLE_LOCATION_BOTTOM = ...
TITLE_LOCATION_LEFT = ...
TITLE_LOCATION_RIGHT = ...
TITLE_LOCATION_TOP_LEFT = ...
TITLE_LOCATION_TOP_RIGHT = ...
TITLE_LOCATION_BOTTOM_LEFT = ...
TITLE_LOCATION_BOTTOM_RIGHT = ...
TEXT_LOCATION_TOP = ...
TEXT_LOCATION_BOTTOM = ...
TEXT_LOCATION_LEFT = ...
TEXT_LOCATION_RIGHT = ...
TEXT_LOCATION_TOP_LEFT = ...
TEXT_LOCATION_TOP_RIGHT = ...
TEXT_LOCATION_BOTTOM_LEFT = ...
TEXT_LOCATION_BOTTOM_RIGHT = ...
TEXT_LOCATION_CENTER = ...
GRAB_ANYWHERE_IGNORE_THESE_WIDGETS = ...
ThisRow = ...
MESSAGE_BOX_LINE_WIDTH = ...
EVENT_TIMEOUT = ...
WIN_CLOSED = ...
WINDOW_CLOSE_ATTEMPTED_EVENT = ...
TITLEBAR_MINIMIZE_KEY = ...
TITLEBAR_MAXIMIZE_KEY = ...
TITLEBAR_CLOSE_KEY = ...
TITLEBAR_IMAGE_KEY = ...
TITLEBAR_DO_NOT_USE_AN_ICON = ...
WRITE_ONLY_KEY = ...
MENU_DISABLED_CHARACTER = ...
MENU_SHORTCUT_CHARACTER = ...
MENU_KEY_SEPARATOR = ...
MENU_SEPARATOR_LINE = ...
MENU_RIGHT_CLICK_EDITME_EXIT = ...
MENU_RIGHT_CLICK_EDITME_VER_EXIT = ...
MENU_RIGHT_CLICK_EDITME_VER_LOC_EXIT = ...
MENU_RIGHT_CLICK_EDITME_VER_SETTINGS_EXIT = ...
MENU_RIGHT_CLICK_EXIT = ...
MENU_RIGHT_CLICK_DISABLED = ...
_MENU_RIGHT_CLICK_TABGROUP_DEFAULT = ...
ENABLE_TK_WINDOWS = ...
USE_CUSTOM_TITLEBAR = ...
CUSTOM_TITLEBAR_BACKGROUND_COLOR = ...
CUSTOM_TITLEBAR_TEXT_COLOR = ...
CUSTOM_TITLEBAR_ICON = ...
CUSTOM_TITLEBAR_FONT = ...
TITLEBAR_METADATA_MARKER = ...
CUSTOM_MENUBAR_METADATA_MARKER = ...
SUPPRESS_ERROR_POPUPS = ...
SUPPRESS_RAISE_KEY_ERRORS = ...
SUPPRESS_KEY_GUESSING = ...
SUPPRESS_WIDGET_NOT_FINALIZED_WARNINGS = ...
ENABLE_TREEVIEW_869_PATCH = ...
ENABLE_MAC_NOTITLEBAR_PATCH = ...
ENABLE_MAC_MODAL_DISABLE_PATCH = ...
ENABLE_MAC_DISABLE_GRAB_ANYWHERE_WITH_TITLEBAR = ...
ENABLE_MAC_ALPHA_99_PATCH = ...
OLD_TABLE_TREE_SELECTED_ROW_COLORS = ...
ALTERNATE_TABLE_AND_TREE_SELECTED_ROW_COLORS = ...
SYMBOL_SQUARE = ...
SYMBOL_CIRCLE = ...
SYMBOL_CIRCLE_OUTLINE = ...
SYMBOL_UP = ...
SYMBOL_RIGHT = ...
SYMBOL_LEFT = ...
SYMBOL_DOWN = ...
SYMBOL_X = ...
SYMBOL_CHECK = ...
SYMBOL_CHECK_SMALL = ...
SYMBOL_X_SMALL = ...
SYMBOL_BALLOT_X = ...
SYMBOL_BALLOT_CHECK = ...
SYMBOL_LEFT_DOUBLE = ...
SYMBOL_RIGHT_DOUBLE = ...
SYMBOL_LEFT_ARROWHEAD = ...
SYMBOL_RIGHT_ARROWHEAD = ...
SYMBOL_UP_ARROWHEAD = ...
SYMBOL_DOWN_ARROWHEAD = ...
if sum([int(i) for i in tclversion_detailed.split('.')]) > 19:
    SYMBOL_TITLEBAR_MINIMIZE = ...
    SYMBOL_TITLEBAR_MAXIMIZE = ...
    SYMBOL_TITLEBAR_CLOSE = ...
else:
    SYMBOL_TITLEBAR_MINIMIZE = ...
    SYMBOL_TITLEBAR_MAXIMIZE = ...
    SYMBOL_TITLEBAR_CLOSE = ...
DEFAULT_USER_SETTINGS_WIN_PATH = ...
DEFAULT_USER_SETTINGS_LINUX_PATH = ...
DEFAULT_USER_SETTINGS_MAC_PATH = ...
DEFAULT_USER_SETTINGS_TRINKET_PATH = ...
DEFAULT_USER_SETTINGS_REPLIT_PATH = ...
DEFAULT_USER_SETTINGS_UNKNOWN_OS_PATH = ...
DEFAULT_USER_SETTINGS_PATH = ...
DEFAULT_USER_SETTINGS_PYSIMPLEGUI_PATH = ...
DEFAULT_USER_SETTINGS_PYSIMPLEGUI_FILENAME = ...
def rgb(red, green, blue): # -> str:
    """
    Given integer values of Red, Green, Blue, return a color string "#RRGGBB"
    :param red:   Red portion from 0 to 255
    :type red:    (int)
    :param green: Green portion from 0 to 255
    :type green:  (int)
    :param blue:  Blue portion from 0 to 255
    :type  blue:  (int)
    :return:      A single RGB String in the format "#RRGGBB" where each pair is a hex number.
    :rtype:       (str)
    """
    ...

BUTTON_TYPE_BROWSE_FOLDER = ...
BUTTON_TYPE_BROWSE_FILE = ...
BUTTON_TYPE_BROWSE_FILES = ...
BUTTON_TYPE_SAVEAS_FILE = ...
BUTTON_TYPE_CLOSES_WIN = ...
BUTTON_TYPE_CLOSES_WIN_ONLY = ...
BUTTON_TYPE_READ_FORM = ...
BUTTON_TYPE_REALTIME = ...
BUTTON_TYPE_CALENDAR_CHOOSER = ...
BUTTON_TYPE_COLOR_CHOOSER = ...
BUTTON_TYPE_SHOW_DEBUGGER = ...
BROWSE_FILES_DELIMITER = ...
FILE_TYPES_ALL_FILES = ...
BUTTON_DISABLED_MEANS_IGNORE = ...
ELEM_TYPE_TEXT = ...
ELEM_TYPE_INPUT_TEXT = ...
ELEM_TYPE_INPUT_COMBO = ...
ELEM_TYPE_INPUT_OPTION_MENU = ...
ELEM_TYPE_INPUT_RADIO = ...
ELEM_TYPE_INPUT_MULTILINE = ...
ELEM_TYPE_INPUT_CHECKBOX = ...
ELEM_TYPE_INPUT_SPIN = ...
ELEM_TYPE_BUTTON = ...
ELEM_TYPE_IMAGE = ...
ELEM_TYPE_CANVAS = ...
ELEM_TYPE_FRAME = ...
ELEM_TYPE_GRAPH = ...
ELEM_TYPE_TAB = ...
ELEM_TYPE_TAB_GROUP = ...
ELEM_TYPE_INPUT_SLIDER = ...
ELEM_TYPE_INPUT_LISTBOX = ...
ELEM_TYPE_OUTPUT = ...
ELEM_TYPE_COLUMN = ...
ELEM_TYPE_MENUBAR = ...
ELEM_TYPE_PROGRESS_BAR = ...
ELEM_TYPE_BLANK = ...
ELEM_TYPE_TABLE = ...
ELEM_TYPE_TREE = ...
ELEM_TYPE_ERROR = ...
ELEM_TYPE_SEPARATOR = ...
ELEM_TYPE_STATUSBAR = ...
ELEM_TYPE_PANE = ...
ELEM_TYPE_BUTTONMENU = ...
ELEM_TYPE_TITLEBAR = ...
ELEM_TYPE_SIZEGRIP = ...
POPUP_BUTTONS_YES_NO = ...
POPUP_BUTTONS_CANCELLED = ...
POPUP_BUTTONS_ERROR = ...
POPUP_BUTTONS_OK_CANCEL = ...
POPUP_BUTTONS_OK = ...
POPUP_BUTTONS_NO_BUTTONS = ...
PSG_THEME_PART_BUTTON_TEXT = ...
PSG_THEME_PART_BUTTON_BACKGROUND = ...
PSG_THEME_PART_BACKGROUND = ...
PSG_THEME_PART_INPUT_BACKGROUND = ...
PSG_THEME_PART_INPUT_TEXT = ...
PSG_THEME_PART_TEXT = ...
PSG_THEME_PART_SLIDER = ...
PSG_THEME_PART_LIST = ...
TTK_SCROLLBAR_PART_TROUGH_COLOR = ...
TTK_SCROLLBAR_PART_BACKGROUND_COLOR = ...
TTK_SCROLLBAR_PART_ARROW_BUTTON_ARROW_COLOR = ...
TTK_SCROLLBAR_PART_FRAME_COLOR = ...
TTK_SCROLLBAR_PART_SCROLL_WIDTH = ...
TTK_SCROLLBAR_PART_ARROW_WIDTH = ...
TTK_SCROLLBAR_PART_RELIEF = ...
TTK_SCROLLBAR_PART_LIST = ...
TTK_SCROLLBAR_PART_THEME_BASED_LIST = ...
DEFAULT_TTK_PART_MAPPING_DICT = ...
ttk_part_mapping_dict = ...
class TTKPartOverrides:
    """
    This class contains "overrides" to the defaults for ttk scrollbars that are defined in the global settings file.
    This class is used in every element, in the Window class and there's a global one that is used by set_options.
    """
    def __init__(self, sbar_trough_color=..., sbar_background_color=..., sbar_arrow_color=..., sbar_width=..., sbar_arrow_width=..., sbar_frame_color=..., sbar_relief=...) -> None:
        ...
    


ttk_part_overrides_from_options = ...
DEFAULT_WINDOW_SNAPSHOT_KEY_CODE = ...
DEFAULT_WINDOW_SNAPSHOT_KEY = ...
tkinter_keysyms = ...
class ToolTip:
    """
    Create a tooltip for a given widget
    (inspired by https://stackoverflow.com/a/36221216)
    This is an INTERNALLY USED only class.  Users should not refer to this class at all.
    """
    def __init__(self, widget, text, timeout=...) -> None:
        """
        :param widget:  The tkinter widget
        :type widget:   widget type varies
        :param text:    text for the tooltip. It can inslude \n
        :type text:     (str)
        :param timeout: Time in milliseconds that mouse must remain still before tip is shown
        :type timeout:  (int)
        """
        ...
    
    def enter(self, event=...): # -> None:
        """
        Called by tkinter when mouse enters a widget
        :param event: from tkinter.  Has x,y coordinates of mouse
        :type event:

        """
        ...
    
    def leave(self, event=...): # -> None:
        """
        Called by tktiner when mouse exits a widget
        :param event: from tkinter.  Event info that's not used by function.
        :type event:

        """
        ...
    
    def schedule(self): # -> None:
        """
        Schedule a timer to time how long mouse is hovering
        """
        ...
    
    def unschedule(self): # -> None:
        """
        Cancel timer used to time mouse hover
        """
        ...
    
    def showtip(self): # -> None:
        """
        Creates a topoltip window with the tooltip text inside of it
        """
        ...
    
    def hidetip(self): # -> None:
        """
        Destroy the tooltip window
        """
        ...
    


class Element:
    """ The base class for all Elements. Holds the basic description of an Element like size and colors """
    def __init__(self, type, size=..., auto_size_text=..., font=..., background_color=..., text_color=..., key=..., pad=..., tooltip=..., visible=..., metadata=..., sbar_trough_color=..., sbar_background_color=..., sbar_arrow_color=..., sbar_width=..., sbar_arrow_width=..., sbar_frame_color=..., sbar_relief=...) -> None:
        """
        Element base class. Only used internally.  User will not create an Element object by itself

        :param type:                        The type of element. These constants all start with "ELEM_TYPE_"
        :type type:                         (int) (could be enum)
        :param size:                        w=characters-wide, h=rows-high. If an int instead of a tuple is supplied, then height is auto-set to 1
        :type size:                         (int, int) | (None, None) | int
        :param auto_size_text:              True if the Widget should be shrunk to exactly fit the number of chars to show
        :type auto_size_text:               bool
        :param font:                        specifies the font family, size. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
        :type font:                         (str or (str, int[, str]) or None)
        :param background_color:            color of background. Can be in #RRGGBB format or a color name "black"
        :type background_color:             (str)
        :param text_color:                  element's text color. Can be in #RRGGBB format or a color name "black"
        :type text_color:                   (str)
        :param key:                         Identifies an Element. Should be UNIQUE to this window.
        :type key:                          str | int | tuple | object
        :param pad:                         Amount of padding to put around element in pixels (left/right, top/bottom). If an int is given, then auto-converted to tuple (int, int)
        :type pad:                          (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param tooltip:                     text, that will appear when mouse hovers over the element
        :type tooltip:                      (str)
        :param visible:                     set visibility state of the element (Default = True)
        :type visible:                      (bool)
        :param metadata:                    User metadata that can be set to ANYTHING
        :type metadata:                     (Any)
        :param sbar_trough_color:           Scrollbar color of the trough
        :type sbar_trough_color:            (str)
        :param sbar_background_color:       Scrollbar color of the background of the arrow buttons at the ends AND the color of the "thumb" (the thing you grab and slide). Switches to arrow color when mouse is over
        :type sbar_background_color:        (str)
        :param sbar_arrow_color:            Scrollbar color of the arrow at the ends of the scrollbar (it looks like a button). Switches to background color when mouse is over
        :type sbar_arrow_color:             (str)
        :param sbar_width:                  Scrollbar width in pixels
        :type sbar_width:                   (int)
        :param sbar_arrow_width:            Scrollbar width of the arrow on the scrollbar. It will potentially impact the overall width of the scrollbar
        :type sbar_arrow_width:             (int)
        :param sbar_frame_color:            Scrollbar Color of frame around scrollbar (available only on some ttk themes)
        :type sbar_frame_color:             (str)
        :param sbar_relief:                 Scrollbar relief that will be used for the "thumb" of the scrollbar (the thing you grab that slides). Should be a constant that is defined at starting with "RELIEF_" - RELIEF_RAISED, RELIEF_SUNKEN, RELIEF_FLAT, RELIEF_RIDGE, RELIEF_GROOVE, RELIEF_SOLID
        :type sbar_relief:                  (str)
        """
        ...
    
    @property
    def visible(self): # -> bool:
        """
        Returns visibility state for the element.  This is a READONLY property
        :return: Visibility state for element
        :rtype:  (bool)
        """
        ...
    
    @property
    def metadata(self): # -> Any:
        """
        Metadata is an Element property that you can use at any time to hold any value
        :return: the current metadata value
        :rtype:  (Any)
        """
        ...
    
    @metadata.setter
    def metadata(self, value): # -> None:
        """
         Metadata is an Element property that you can use at any time to hold any value
        :param value: Anything you want it to be
        :type value:  (Any)
        """
        ...
    
    @property
    def key(self): # -> None:
        """
        Returns key for the element.  This is a READONLY property.
        Keys can be any hashable object (basically anything except a list... tuples are ok, but not lists)
        :return: The window's Key
        :rtype:  (Any)
        """
        ...
    
    @property
    def widget(self): # -> None:
        """
        Returns tkinter widget for the element.  This is a READONLY property.
        The implementation is that the Widget member variable is returned. This is a backward compatible addition
        :return:    The element's underlying tkinter widget
        :rtype:     (tkinter.Widget)
        """
        ...
    
    def bind(self, bind_string, key_modifier, propagate=...): # -> None:
        """
        Used to add tkinter events to an Element.
        The tkinter specific data is in the Element's member variable user_bind_event
        :param bind_string:  The string tkinter expected in its bind function
        :type bind_string:   (str)
        :param key_modifier: Additional data to be added to the element's key when event is returned
        :type key_modifier:  (str)
        :param propagate:    If True then tkinter will be told to propagate the event to the element
        :type propagate:     (bool)
        """
        ...
    
    def unbind(self, bind_string): # -> None:
        """
        Removes a previously bound tkinter event from an Element.
        :param bind_string: The string tkinter expected in its bind function
        :type bind_string:  (str)
        """
        ...
    
    def set_tooltip(self, tooltip_text): # -> None:
        """
        Called by application to change the tooltip text for an Element.  Normally invoked using the Element Object such as: window.Element('key').SetToolTip('New tip').

        :param tooltip_text: the text to show in tooltip.
        :type tooltip_text:  (str)
        """
        ...
    
    def set_focus(self, force=...): # -> None:
        """
        Sets the current focus to be on this element

        :param force: if True will call focus_force otherwise calls focus_set
        :type force:  bool
        """
        ...
    
    def block_focus(self, block=...): # -> None:
        """
        Enable or disable the element from getting focus by using the keyboard.
        If the block parameter is True, then this element will not be given focus by using
        the keyboard to go from one element to another.
        You CAN click on the element and utilize it.

        :param block: if True the element will not get focus via the keyboard
        :type block:  bool
        """
        ...
    
    def get_next_focus(self): # -> None:
        """
        Gets the next element that should get focus after this element.

        :return:    Element that will get focus after this one
        :rtype:     (Element)
        """
        ...
    
    def get_previous_focus(self): # -> None:
        """
        Gets the element that should get focus previous to this element.

        :return:    Element that should get the focus before this one
        :rtype:     (Element)
        """
        ...
    
    def set_size(self, size=...): # -> None:
        """
        Changes the size of an element to a specific size.
        It's possible to specify None for one of sizes so that only 1 of the element's dimensions are changed.

        :param size: The size in characters, rows typically. In some cases they are pixels
        :type size:  (int, int)
        """
        ...
    
    def get_size(self): # -> tuple[Unknown | None, Unknown | None]:
        """
        Return the size of an element in Pixels.  Care must be taken as some elements use characters to specify their size but will return pixels when calling this get_size method.
        :return: width and height of the element
        :rtype:  (int, int)
        """
        ...
    
    def hide_row(self): # -> None:
        """
        Hide the entire row an Element is located on.
        Use this if you must have all space removed when you are hiding an element, including the row container
        """
        ...
    
    def unhide_row(self): # -> None:
        """
        Unhides (makes visible again) the row container that the Element is located on.
        Note that it will re-appear at the bottom of the window / container, most likely.
        """
        ...
    
    def expand(self, expand_x=..., expand_y=..., expand_row=...): # -> None:
        """
        Causes the Element to expand to fill available space in the X and Y directions.  Can specify which or both directions

        :param expand_x:   If True Element will expand in the Horizontal directions
        :type expand_x:    (bool)
        :param expand_y:   If True Element will expand in the Vertical directions
        :type expand_y:    (bool)
        :param expand_row: If True the row containing the element will also expand. Without this your element is "trapped" within the row
        :type expand_row:  (bool)
        """
        ...
    
    def set_cursor(self, cursor=..., cursor_color=...): # -> None:
        """
        Sets the cursor for the current Element.
        "Cursor" is used in 2 different ways in this call.
        For the parameter "cursor" it's actually the mouse pointer.
        If you do not want any mouse pointer, then use the string "none"
        For the parameter "cursor_color" it's the color of the beam used when typing into an input element

        :param cursor:       The tkinter cursor name
        :type cursor:        (str)
        :param cursor_color: color to set the "cursor" to
        :type cursor_color:  (str)
        """
        ...
    
    def set_vscroll_position(self, percent_from_top): # -> None:
        """
        Attempts to set the vertical scroll postition for an element's Widget
        :param percent_from_top: From 0 to 1.0, the percentage from the top to move scrollbar to
        :type percent_from_top:  (float)
        """
        ...
    
    def grab_anywhere_exclude(self): # -> None:
        """
        Excludes this element from being used by the grab_anywhere feature
        Handy for elements like a Graph element when dragging is enabled. You want the Graph element to get the drag events instead of the window dragging.
        """
        ...
    
    def grab_anywhere_include(self): # -> None:
        """
        Includes this element in the grab_anywhere feature
        This will allow you to make a Multline element drag a window for example
        """
        ...
    
    def set_right_click_menu(self, menu=...): # -> None:
        ...
    
    def update(self, *args, **kwargs): # -> None:
        """
        A dummy update call.  This will only be called if an element hasn't implemented an update method
        It is provided here for docstring purposes.  If you got here by browing code via PyCharm, know
        that this is not the function that will be called.  Your actual element's update method will be called.

        If you call update, you must call window.refresh if you want the change to happen prior to your next
        window.read() call. Normally uou don't do this as the window.read call is likely going to happen next.
        """
        ...
    
    def __call__(self, *args, **kwargs): # -> None:
        """
        Makes it possible to "call" an already existing element.  When you do make the "call", it actually calls
        the Update method for the element.
        Example:    If this text element was in yoiur layout:
                    sg.Text('foo', key='T')
                    Then you can call the Update method for that element by writing:
                    window.find_element('T')('new text value')
        """
        ...
    
    SetTooltip = ...
    SetFocus = ...


class Input(Element):
    """
    Display a single text input field.  Based on the tkinter Widget `Entry`
    """
    def __init__(self, default_text=..., size=..., s=..., disabled=..., password_char=..., justification=..., background_color=..., text_color=..., font=..., tooltip=..., border_width=..., change_submits=..., enable_events=..., do_not_clear=..., key=..., k=..., focus=..., pad=..., p=..., use_readonly_for_disable=..., readonly=..., disabled_readonly_background_color=..., disabled_readonly_text_color=..., expand_x=..., expand_y=..., right_click_menu=..., visible=..., metadata=...) -> None:
        """
        :param default_text:                       Text initially shown in the input box as a default value(Default value = ''). Will automatically be converted to string
        :type default_text:                        (Any)
        :param size:                               w=characters-wide, h=rows-high. If an int is supplied rather than a tuple, then a tuple is created width=int supplied and heigh=1
        :type size:                                (int, int) |  (int, None) | int
        :param s:                                  Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
        :type s:                                   (int, int)  | (None, None) | int
        :param disabled:                           set disable state for element (Default = False)
        :type disabled:                            (bool)
        :param password_char:                      Password character if this is a password field (Default value = '')
        :type password_char:                       (char)
        :param justification:                      justification for data display. Valid choices - left, right, center
        :type justification:                       (str)
        :param background_color:                   color of background in one of the color formats
        :type background_color:                    (str)
        :param text_color:                         color of the text
        :type text_color:                          (str)
        :param font:                               specifies the font family, size. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
        :type font:                                (str or (str, int[, str]) or None)
        :param tooltip:                            text, that will appear when mouse hovers over the element
        :type tooltip:                             (str)
        :param border_width:                       width of border around element in pixels
        :type border_width:                        (int)
        :param change_submits:                     * DEPRICATED DO NOT USE. Use `enable_events` instead
        :type change_submits:                      (bool)
        :param enable_events:                      If True then changes to this element are immediately reported as an event. Use this instead of change_submits (Default = False)
        :type enable_events:                       (bool)
        :param do_not_clear:                       If False then the field will be set to blank after ANY event (button, any event) (Default = True)
        :type do_not_clear:                        (bool)
        :param key:                                Value that uniquely identifies this element from all other elements. Used when Finding an element or in return values. Must be unique to the window
        :type key:                                 str | int | tuple | object
        :param k:                                  Same as the Key. You can use either k or key. Which ever is set will be used.
        :type k:                                   str | int | tuple | object
        :param focus:                              Determines if initial focus should go to this element.
        :type focus:                               (bool)
        :param pad:                                Amount of padding to put around element. Normally (horizontal pixels, vertical pixels) but can be split apart further into ((horizontal left, horizontal right), (vertical above, vertical below)). If int is given, then converted to tuple (int, int) with the value provided duplicated
        :type pad:                                 (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param p:                                  Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
        :type p:                                   (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param use_readonly_for_disable:           If True (the default) tkinter state set to 'readonly'. Otherwise state set to 'disabled'
        :type use_readonly_for_disable:            (bool)
        :param readonly:                           If True tkinter state set to 'readonly'.  Use this in place of use_readonly_for_disable as another way of achieving readonly.  Note cannot set BOTH readonly and disabled as tkinter only supplies a single flag
        :type readonly:                            (bool)
        :param disabled_readonly_background_color: If state is set to readonly or disabled, the color to use for the background
        :type disabled_readonly_background_color:  (str)
        :param disabled_readonly_text_color:       If state is set to readonly or disabled, the color to use for the text
        :type disabled_readonly_text_color:        (str)
        :param expand_x:                           If True the element will automatically expand in the X direction to fill available space
        :type expand_x:                            (bool)
        :param expand_y:                           If True the element will automatically expand in the Y direction to fill available space
        :type expand_y:                            (bool)
        :param right_click_menu:                   A list of lists of Menu items to show when this element is right clicked. See user docs for exact format.
        :type right_click_menu:                    List[List[ List[str] | str ]]
        :param visible:                            set visibility state of the element (Default = True)
        :type visible:                             (bool)
        :param metadata:                           User metadata that can be set to ANYTHING
        :type metadata:                            (Any)
        """
        ...
    
    def update(self, value=..., disabled=..., select=..., visible=..., text_color=..., background_color=..., move_cursor_to=..., password_char=..., paste=...): # -> None:
        """
        Changes some of the settings for the Input Element. Must call `Window.Read` or `Window.Finalize` prior.
        Changes will not be visible in your window until you call window.read or window.refresh.

        If you change visibility, your element may MOVE. If you want it to remain stationary, use the "layout helper"
        function "pin" to ensure your element is "pinned" to that location in your layout so that it returns there
        when made visible.

        :param value:            new text to display as default text in Input field
        :type value:             (str)
        :param disabled:         disable or enable state of the element (sets Entry Widget to readonly or normal)
        :type disabled:          (bool)
        :param select:           if True, then the text will be selected
        :type select:            (bool)
        :param visible:          change visibility of element
        :type visible:           (bool)
        :param text_color:       change color of text being typed
        :type text_color:        (str)
        :param background_color: change color of the background
        :type background_color:  (str)
        :param move_cursor_to:   Moves the cursor to a particular offset. Defaults to 'end'
        :type move_cursor_to:    int | str
        :param password_char:    Password character if this is a password field
        :type password_char:     str
        :param paste:            If True "Pastes" the value into the element rather than replacing the entire element. If anything is selected it is replaced. The text is inserted at the current cursor location.
        :type paste:             bool
        """
        ...
    
    def get(self): # -> Literal['']:
        """
        Read and return the current value of the input element. Must call `Window.Read` or `Window.Finalize` prior

        :return: current value of Input field or '' if error encountered
        :rtype:  (str)
        """
        ...
    
    Get = ...
    Update = ...


In = Input
InputText = Input
I = Input
class Combo(Element):
    """
    ComboBox Element - A combination of a single-line input and a drop-down menu. User can type in their own value or choose from list.
    """
    def __init__(self, values, default_value=..., size=..., s=..., auto_size_text=..., background_color=..., text_color=..., button_background_color=..., button_arrow_color=..., bind_return_key=..., change_submits=..., enable_events=..., disabled=..., key=..., k=..., pad=..., p=..., expand_x=..., expand_y=..., tooltip=..., readonly=..., font=..., visible=..., metadata=...) -> None:
        """
        :param values:                  values to choose. While displayed as text, the items returned are what the caller supplied, not text
        :type values:                   List[Any] or Tuple[Any]
        :param default_value:           Choice to be displayed as initial value. Must match one of values variable contents
        :type default_value:            (Any)
        :param size:                    width, height. Width = characters-wide, height = NOTE it's the number of entries to show in the list. If an Int is passed rather than a tuple, then height is auto-set to 1 and width is value of the int
        :type size:                     (int, int)  | (None, None) | int
        :param s:                       Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
        :type s:                        (int, int)  | (None, None) | int
        :param auto_size_text:          True if element should be the same size as the contents
        :type auto_size_text:           (bool)
        :param background_color:        color of background
        :type background_color:         (str)
        :param text_color:              color of the text
        :type text_color:               (str)
        :param button_background_color: The color of the background of the button on the combo box
        :type button_background_color:  (str)
        :param button_arrow_color:      The color of the arrow on the button on the combo box
        :type button_arrow_color:       (str)
        :param bind_return_key:         If True, then the return key will cause a the Combo to generate an event
        :type bind_return_key:          (bool)
        :param change_submits:          DEPRICATED DO NOT USE. Use `enable_events` instead
        :type change_submits:           (bool)
        :param enable_events:           Turns on the element specific events. Combo event is when a choice is made
        :type enable_events:            (bool)
        :param disabled:                set disable state for element
        :type disabled:                 (bool)
        :param key:                     Used with window.find_element and with return values to uniquely identify this element
        :type key:                      str | int | tuple | object
        :param k:                       Same as the Key. You can use either k or key. Which ever is set will be used.
        :type k:                        str | int | tuple | object
        :param pad:                     Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
        :type pad:                      (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param p:                       Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
        :type p:                        (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param expand_x:                If True the element will automatically expand in the X direction to fill available space
        :type expand_x:                 (bool)
        :param expand_y:                If True the element will automatically expand in the Y direction to fill available space
        :type expand_y:                 (bool)
        :param tooltip:                 text that will appear when mouse hovers over this element
        :type tooltip:                  (str)
        :param readonly:                make element readonly (user can't change). True means user cannot change
        :type readonly:                 (bool)
        :param font:                    specifies the font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
        :type font:                     (str or (str, int[, str]) or None)
        :param visible:                 set visibility state of the element
        :type visible:                  (bool)
        :param metadata:                User metadata that can be set to ANYTHING
        :type metadata:                 (Any)
        """
        ...
    
    def update(self, value=..., values=..., set_to_index=..., disabled=..., readonly=..., font=..., visible=..., size=...):
        """
        Changes some of the settings for the Combo Element. Must call `Window.Read` or `Window.Finalize` prior.
        Note that the state can be in 3 states only.... enabled, disabled, readonly even
        though more combinations are available. The easy way to remember is that if you
        change the readonly parameter then you are enabling the element.

        Changes will not be visible in your window until you call window.read or window.refresh.

        If you change visibility, your element may MOVE. If you want it to remain stationary, use the "layout helper"
        function "pin" to ensure your element is "pinned" to that location in your layout so that it returns there
        when made visible.

        :param value:        change which value is current selected based on new list of previous list of choices
        :type value:         (Any)
        :param values:       change list of choices
        :type values:        List[Any]
        :param set_to_index: change selection to a particular choice starting with index = 0
        :type set_to_index:  (int)
        :param disabled:     disable or enable state of the element
        :type disabled:      (bool)
        :param readonly:     if True make element readonly (user cannot change any choices). Enables the element if either choice are made.
        :type readonly:      (bool)
        :param font:         specifies the font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
        :type font:          (str or (str, int[, str]) or None)
        :param visible:      control visibility of element
        :type visible:       (bool)
        :param size:         width, height. Width = characters-wide, height = NOTE it's the number of entries to show in the list
        :type size:          (int, int)
        """
        ...
    
    def get(self): # -> str | None:
        """
        Returns the current (right now) value of the Combo.  DO NOT USE THIS AS THE NORMAL WAY OF READING A COMBO!
        You should be using values from your call to window.read instead.  Know what you're doing if you use it.

        :return: Returns the value of what is currently chosen
        :rtype:  Any | None
        """
        ...
    
    Get = ...
    Update = ...


InputCombo = Combo
DropDown = InputCombo
Drop = InputCombo
DD = Combo
class OptionMenu(Element):
    """
    Option Menu is an Element available ONLY on the tkinter port of PySimpleGUI.  It's is a widget that is unique
    to tkinter.  However, it looks much like a ComboBox.  Instead of an arrow to click to pull down the list of
    choices, another little graphic is shown on the widget to indicate where you click.  After clicking to activate,
    it looks like a Combo Box that you scroll to select a choice.
    """
    def __init__(self, values, default_value=..., size=..., s=..., disabled=..., auto_size_text=..., expand_x=..., expand_y=..., background_color=..., text_color=..., key=..., k=..., pad=..., p=..., tooltip=..., visible=..., metadata=...) -> None:
        """
        :param values:           Values to be displayed
        :type values:            List[Any] or Tuple[Any]
        :param default_value:    the value to choose by default
        :type default_value:     (Any)
        :param size:             (width, height) size in characters (wide), height is ignored and present to be consistent with other elements
        :type size:              (int, int) (width, UNUSED)
        :param s:                Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
        :type s:                 (int, int)  | (None, None) | int
        :param disabled:         control enabled / disabled
        :type disabled:          (bool)
        :param auto_size_text:   True if size of Element should match the contents of the items
        :type auto_size_text:    (bool)
        :param expand_x:         If True the element will automatically expand in the X direction to fill available space
        :type expand_x:          (bool)
        :param expand_y:         If True the element will automatically expand in the Y direction to fill available space
        :type expand_y:          (bool)
        :param background_color: color of background
        :type background_color:  (str)
        :param text_color:       color of the text
        :type text_color:        (str)
        :param key:              Used with window.find_element and with return values to uniquely identify this element
        :type key:               str | int | tuple | object
        :param k:                Same as the Key. You can use either k or key. Which ever is set will be used.
        :type k:                 str | int | tuple | object
        :param pad:              Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
        :type pad:               (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param p:                Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
        :type p:                 (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param tooltip:          text that will appear when mouse hovers over this element
        :type tooltip:           (str)
        :param visible:          set visibility state of the element
        :type visible:           (bool)
        :param metadata:         User metadata that can be set to ANYTHING
        :type metadata:          (Any)
        """
        ...
    
    def update(self, value=..., values=..., disabled=..., visible=..., size=...): # -> None:
        """
        Changes some of the settings for the OptionMenu Element. Must call `Window.Read` or `Window.Finalize` prior

        Changes will not be visible in your window until you call window.read or window.refresh.

        If you change visibility, your element may MOVE. If you want it to remain stationary, use the "layout helper"
        function "pin" to ensure your element is "pinned" to that location in your layout so that it returns there
        when made visible.

        :param value:    the value to choose by default
        :type value:     (Any)
        :param values:   Values to be displayed
        :type values:    List[Any]
        :param disabled: disable or enable state of the element
        :type disabled:  (bool)
        :param visible:  control visibility of element
        :type visible:   (bool)
        :param size:     (width, height) size in characters (wide), height is ignored and present to be consistent with other elements
        :type size:      (int, int) (width, UNUSED)
        """
        ...
    
    Update = ...


InputOptionMenu = OptionMenu
class Listbox(Element):
    """
    A List Box.  Provide a list of values for the user to choose one or more of.   Returns a list of selected rows
    when a window.read() is executed.
    """
    def __init__(self, values, default_values=..., select_mode=..., change_submits=..., enable_events=..., bind_return_key=..., size=..., s=..., disabled=..., auto_size_text=..., font=..., no_scrollbar=..., horizontal_scroll=..., background_color=..., text_color=..., highlight_background_color=..., highlight_text_color=..., sbar_trough_color=..., sbar_background_color=..., sbar_arrow_color=..., sbar_width=..., sbar_arrow_width=..., sbar_frame_color=..., sbar_relief=..., key=..., k=..., pad=..., p=..., tooltip=..., expand_x=..., expand_y=..., right_click_menu=..., visible=..., metadata=...) -> None:
        """
        :param values:                     list of values to display. Can be any type including mixed types as long as they have __str__ method
        :type values:                      List[Any] or Tuple[Any]
        :param default_values:             which values should be initially selected
        :type default_values:              List[Any]
        :param select_mode:                Select modes are used to determine if only 1 item can be selected or multiple and how they can be selected.   Valid choices begin with "LISTBOX_SELECT_MODE_" and include: LISTBOX_SELECT_MODE_SINGLE LISTBOX_SELECT_MODE_MULTIPLE LISTBOX_SELECT_MODE_BROWSE LISTBOX_SELECT_MODE_EXTENDED
        :type select_mode:                 [enum]
        :param change_submits:             DO NOT USE. Only listed for backwards compat - Use enable_events instead
        :type change_submits:              (bool)
        :param enable_events:              Turns on the element specific events. Listbox generates events when an item is clicked
        :type enable_events:               (bool)
        :param bind_return_key:            If True, then the return key will cause a the Listbox to generate an event
        :type bind_return_key:             (bool)
        :param size:                       w=characters-wide, h=rows-high. If an int instead of a tuple is supplied, then height is auto-set to 1
        :type size:                        (int, int) |  (int, None) | int
        :param s:                          Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
        :type s:                           (int, int)  | (None, None) | int
        :param disabled:                   set disable state for element
        :type disabled:                    (bool)
        :param auto_size_text:             True if element should be the same size as the contents
        :type auto_size_text:              (bool)
        :param font:                       specifies the font family, size, etc.  Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
        :type font:                        (str or (str, int[, str]) or None)
        :param no_scrollbar:               Controls if a scrollbar should be shown.  If True, no scrollbar will be shown
        :type no_scrollbar:                (bool)
        :param horizontal_scroll:          Controls if a horizontal scrollbar should be shown.  If True a horizontal scrollbar will be shown in addition to vertical
        :type horizontal_scroll:           (bool)
        :param background_color:           color of background
        :type background_color:            (str)
        :param text_color:                 color of the text
        :type text_color:                  (str)
        :param highlight_background_color: color of the background when an item is selected. Defaults to normal text color (a reverse look)
        :type highlight_background_color:  (str)
        :param highlight_text_color:       color of the text when an item is selected. Defaults to the normal background color (a rerverse look)
        :type highlight_text_color:        (str)
        :param sbar_trough_color:           Scrollbar color of the trough
        :type sbar_trough_color:            (str)
        :param sbar_background_color:       Scrollbar color of the background of the arrow buttons at the ends AND the color of the "thumb" (the thing you grab and slide). Switches to arrow color when mouse is over
        :type sbar_background_color:        (str)
        :param sbar_arrow_color:            Scrollbar color of the arrow at the ends of the scrollbar (it looks like a button). Switches to background color when mouse is over
        :type sbar_arrow_color:             (str)
        :param sbar_width:                  Scrollbar width in pixels
        :type sbar_width:                   (int)
        :param sbar_arrow_width:            Scrollbar width of the arrow on the scrollbar. It will potentially impact the overall width of the scrollbar
        :type sbar_arrow_width:             (int)
        :param sbar_frame_color:            Scrollbar Color of frame around scrollbar (available only on some ttk themes)
        :type sbar_frame_color:             (str)
        :param sbar_relief:                 Scrollbar relief that will be used for the "thumb" of the scrollbar (the thing you grab that slides). Should be a constant that is defined at starting with "RELIEF_" - RELIEF_RAISED, RELIEF_SUNKEN, RELIEF_FLAT, RELIEF_RIDGE, RELIEF_GROOVE, RELIEF_SOLID
        :type sbar_relief:                  (str)
        :param key:                        Used with window.find_element and with return values to uniquely identify this element
        :type key:                         str | int | tuple | object
        :param k:                          Same as the Key. You can use either k or key. Which ever is set will be used.
        :type k:                           str | int | tuple | object
        :param pad:                        Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
        :type pad:                         (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param p:                          Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
        :type p:                           (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param tooltip:                    text, that will appear when mouse hovers over the element
        :type tooltip:                     (str)
        :param expand_x:                   If True the element will automatically expand in the X direction to fill available space
        :type expand_x:                    (bool)
        :param expand_y:                   If True the element will automatically expand in the Y direction to fill available space
        :type expand_y:                    (bool)
        :param right_click_menu:           A list of lists of Menu items to show when this element is right clicked. See user docs for exact format.
        :type right_click_menu:            List[List[ List[str] | str ]]
        :param visible:                    set visibility state of the element
        :type visible:                     (bool)
        :param metadata:                   User metadata that can be set to ANYTHING
        :type metadata:                    (Any)
        """
        ...
    
    def update(self, values=..., disabled=..., set_to_index=..., scroll_to_index=..., select_mode=..., visible=...): # -> None:
        """
        Changes some of the settings for the Listbox Element. Must call `Window.Read` or `Window.Finalize` prior
        Changes will not be visible in your window until you call window.read or window.refresh.

        If you change visibility, your element may MOVE. If you want it to remain stationary, use the "layout helper"
        function "pin" to ensure your element is "pinned" to that location in your layout so that it returns there
        when made visible.

        :param values:          new list of choices to be shown to user
        :type values:           List[Any]
        :param disabled:        disable or enable state of the element
        :type disabled:         (bool)
        :param set_to_index:    highlights the item(s) indicated. If parm is an int one entry will be set. If is a list, then each entry in list is highlighted
        :type set_to_index:     int | list | tuple
        :param scroll_to_index: scroll the listbox so that this index is the first shown
        :type scroll_to_index:  (int)
        :param select_mode:     changes the select mode according to tkinter's listbox widget
        :type select_mode:      (str)
        :param visible:         control visibility of element
        :type visible:          (bool)
        """
        ...
    
    def set_value(self, values): # -> None:
        """
        Set listbox highlighted choices

        :param values: new values to choose based on previously set values
        :type values:  List[Any] | Tuple[Any]

        """
        ...
    
    def get_list_values(self: Listbox) -> List[Any]:
        """
        Returns list of Values provided by the user in the user's format

        :return: List of values. Can be any / mixed types -> []
        :rtype:  List[Any]
        """
        ...
    
    def get_indexes(self):
        """
        Returns the items currently selected as a list of indexes

        :return: A list of offsets into values that is currently selected
        :rtype:  List[int]
        """
        ...
    
    def get(self): # -> list[Unknown]:
        """
        Returns the list of items currently selected in this listbox.  It should be identical
        to the value you would receive when performing a window.read() call.

        :return: The list of currently selected items. The actual items are returned, not the indexes
        :rtype:  List[Any]
        """
        ...
    
    GetIndexes = ...
    GetListValues = ...
    SetValue = ...
    Update = ...


LBox = Listbox
LB = Listbox
class Radio(Element):
    """
    Radio Button Element - Used in a group of other Radio Elements to provide user with ability to select only
    1 choice in a list of choices.
    """
    def __init__(self, text, group_id, default=..., disabled=..., size=..., s=..., auto_size_text=..., background_color=..., text_color=..., circle_color=..., font=..., key=..., k=..., pad=..., p=..., tooltip=..., change_submits=..., enable_events=..., right_click_menu=..., expand_x=..., expand_y=..., visible=..., metadata=...) -> None:
        """
        :param text:             Text to display next to button
        :type text:              (str)
        :param group_id:         Groups together multiple Radio Buttons. Any type works
        :type group_id:          (Any)
        :param default:          Set to True for the one element of the group you want initially selected
        :type default:           (bool)
        :param disabled:         set disable state
        :type disabled:          (bool)
        :param size:             (w, h) w=characters-wide, h=rows-high. If an int instead of a tuple is supplied, then height is auto-set to 1
        :type size:              (int, int)  | (None, None) | int
        :param s:                Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
        :type s:                 (int, int)  | (None, None) | int
        :param auto_size_text:   if True will size the element to match the length of the text
        :type auto_size_text:    (bool)
        :param background_color: color of background
        :type background_color:  (str)
        :param text_color:       color of the text
        :type text_color:        (str)
        :param circle_color:     color of background of the circle that has the dot selection indicator in it
        :type circle_color:      (str)
        :param font:             specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
        :type font:              (str or (str, int[, str]) or None)
        :param key:              Used with window.find_element and with return values to uniquely identify this element
        :type key:               str | int | tuple | object
        :param k:                Same as the Key. You can use either k or key. Which ever is set will be used.
        :type k:                 str | int | tuple | object
        :param pad:              Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
        :type pad:               (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param p:                Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
        :type p:                 (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param tooltip:          text, that will appear when mouse hovers over the element
        :type tooltip:           (str)
        :param change_submits:   DO NOT USE. Only listed for backwards compat - Use enable_events instead
        :type change_submits:    (bool)
        :param enable_events:    Turns on the element specific events. Radio Button events happen when an item is selected
        :type enable_events:     (bool)
        :param right_click_menu: A list of lists of Menu items to show when this element is right clicked. See user docs for exact format.
        :type right_click_menu:  List[List[ List[str] | str ]]
        :param expand_x:         If True the element will automatically expand in the X direction to fill available space
        :type expand_x:          (bool)
        :param expand_y:         If True the element will automatically expand in the Y direction to fill available space
        :type expand_y:          (bool)
        :param visible:          set visibility state of the element
        :type visible:           (bool)
        :param metadata:         User metadata that can be set to ANYTHING
        :type metadata:          (Any)
        """
        ...
    
    def update(self, value=..., text=..., background_color=..., text_color=..., circle_color=..., disabled=..., visible=...):
        """
        Changes some of the settings for the Radio Button Element. Must call `Window.read` or `Window.finalize` prior

        Changes will not be visible in your window until you call window.read or window.refresh.

        If you change visibility, your element may MOVE. If you want it to remain stationary, use the "layout helper"
        function "pin" to ensure your element is "pinned" to that location in your layout so that it returns there
        when made visible.

        :param value:            if True change to selected and set others in group to unselected
        :type value:             (bool)
        :param text:             Text to display next to radio button
        :type text:              (str)
        :param background_color: color of background
        :type background_color:  (str)
        :param text_color:       color of the text. Note this also changes the color of the selection dot
        :type text_color:        (str)
        :param circle_color:     color of background of the circle that has the dot selection indicator in it
        :type circle_color:      (str)
        :param disabled:         disable or enable state of the element
        :type disabled:          (bool)
        :param visible:          control visibility of element
        :type visible:           (bool)
        """
        ...
    
    def reset_group(self): # -> None:
        """
        Sets all Radio Buttons in the group to not selected
        """
        ...
    
    def get(self: Radio) -> bool:
        """
        A snapshot of the value of Radio Button -> (bool)

        :return: True if this radio button is selected
        :rtype:  (bool)
        """
        ...
    
    Get = ...
    ResetGroup = ...
    Update = ...


R = Radio
Rad = Radio
class Checkbox(Element):
    """
    Checkbox Element - Displays a checkbox and text next to it
    """
    def __init__(self, text, default=..., size=..., s=..., auto_size_text=..., font=..., background_color=..., text_color=..., checkbox_color=..., change_submits=..., enable_events=..., disabled=..., key=..., k=..., pad=..., p=..., tooltip=..., right_click_menu=..., expand_x=..., expand_y=..., visible=..., metadata=...) -> None:
        """
        :param text:             Text to display next to checkbox
        :type text:              (str)
        :param default:          Set to True if you want this checkbox initially checked
        :type default:           (bool)
        :param size:             (w, h) w=characters-wide, h=rows-high. If an int instead of a tuple is supplied, then height is auto-set to 1
        :type size:              (int, int)  | (None, None) | int
        :param s:                Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
        :type s:                 (int, int)  | (None, None) | int
        :param auto_size_text:   if True will size the element to match the length of the text
        :type auto_size_text:    (bool)
        :param font:             specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
        :type font:              (str or (str, int[, str]) or None)
        :param background_color: color of background
        :type background_color:  (str)
        :param text_color:       color of the text
        :type text_color:        (str)
        :param checkbox_color:   color of background of the box that has the check mark in it. The checkmark is the same color as the text
        :type checkbox_color:    (str)
        :param change_submits:   DO NOT USE. Only listed for backwards compat - Use enable_events instead
        :type change_submits:    (bool)
        :param enable_events:    Turns on the element specific events. Checkbox events happen when an item changes
        :type enable_events:     (bool)
        :param disabled:         set disable state
        :type disabled:          (bool)
        :param key:              Used with window.find_element and with return values to uniquely identify this element
        :type key:               str | int | tuple | object
        :param k:                Same as the Key. You can use either k or key. Which ever is set will be used.
        :type k:                 str | int | tuple | object
        :param pad:              Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
        :type pad:               (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param p:                Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
        :type p:                 (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param tooltip:          text, that will appear when mouse hovers over the element
        :type tooltip:           (str)
        :param right_click_menu: A list of lists of Menu items to show when this element is right clicked. See user docs for exact format.
        :type right_click_menu:  List[List[ List[str] | str ]]
        :param expand_x:         If True the element will automatically expand in the X direction to fill available space
        :type expand_x:          (bool)
        :param expand_y:         If True the element will automatically expand in the Y direction to fill available space
        :type expand_y:          (bool)
        :param visible:          set visibility state of the element
        :type visible:           (bool)
        :param metadata:         User metadata that can be set to ANYTHING
        :type metadata:          (Any)
        """
        ...
    
    def get(self: Checkbox) -> bool:
        """
        Return the current state of this checkbox

        :return: Current state of checkbox
        :rtype:  (bool)
        """
        ...
    
    def update(self, value=..., text=..., background_color=..., text_color=..., checkbox_color=..., disabled=..., visible=...): # -> None:
        """
        Changes some of the settings for the Checkbox Element. Must call `Window.Read` or `Window.Finalize` prior.
        Note that changing visibility may cause element to change locations when made visible after invisible

        Changes will not be visible in your window until you call window.read or window.refresh.

        If you change visibility, your element may MOVE. If you want it to remain stationary, use the "layout helper"
        function "pin" to ensure your element is "pinned" to that location in your layout so that it returns there
        when made visible.

        :param value:            if True checks the checkbox, False clears it
        :type value:             (bool)
        :param text:             Text to display next to checkbox
        :type text:              (str)
        :param background_color: color of background
        :type background_color:  (str)
        :param text_color:       color of the text. Note this also changes the color of the checkmark
        :type text_color:        (str)
        :param disabled:         disable or enable element
        :type disabled:          (bool)
        :param visible:          control visibility of element
        :type visible:           (bool)
        """
        ...
    
    Get = ...
    Update = ...


CB = Checkbox
CBox = Checkbox
Check = Checkbox
class Spin(Element):
    """
    A spinner with up/down buttons and a single line of text. Choose 1 values from list
    """
    def __init__(self, values, initial_value=..., disabled=..., change_submits=..., enable_events=..., readonly=..., size=..., s=..., auto_size_text=..., bind_return_key=..., font=..., background_color=..., text_color=..., key=..., k=..., pad=..., p=..., tooltip=..., right_click_menu=..., expand_x=..., expand_y=..., visible=..., metadata=...) -> None:
        """
        :param values:           List of valid values
        :type values:            Tuple[Any] or List[Any]
        :param initial_value:    Initial item to show in window. Choose from list of values supplied
        :type initial_value:     (Any)
        :param disabled:         set disable state
        :type disabled:          (bool)
        :param change_submits:   DO NOT USE. Only listed for backwards compat - Use enable_events instead
        :type change_submits:    (bool)
        :param enable_events:    Turns on the element specific events. Spin events happen when an item changes
        :type enable_events:     (bool)
        :param readonly:         Turns on the element specific events. Spin events happen when an item changes
        :type readonly:          (bool)
        :param size:             (w, h) w=characters-wide, h=rows-high. If an int instead of a tuple is supplied, then height is auto-set to 1
        :type size:              (int, int)  | (None, None) | int
        :param s:                Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
        :type s:                 (int, int)  | (None, None) | int
        :param auto_size_text:   if True will size the element to match the length of the text
        :type auto_size_text:    (bool)
        :param bind_return_key:  If True, then the return key will cause a the element to generate an event
        :type bind_return_key:   (bool)
        :param font:             specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
        :type font:              (str or (str, int[, str]) or None)
        :param background_color: color of background
        :type background_color:  (str)
        :param text_color:       color of the text
        :type text_color:        (str)
        :param key:              Used with window.find_element and with return values to uniquely identify this element
        :type key:               str | int | tuple | object
        :param k:                Same as the Key. You can use either k or key. Which ever is set will be used.
        :type k:                 str | int | tuple | object
        :param pad:              Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
        :type pad:               (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param p:                Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
        :type p:                 (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param tooltip:          text, that will appear when mouse hovers over the element
        :type tooltip:           (str)
        :param right_click_menu: A list of lists of Menu items to show when this element is right clicked. See user docs for exact format.
        :type right_click_menu:  List[List[ List[str] | str ]]
        :param expand_x:         If True the element will automatically expand in the X direction to fill available space
        :type expand_x:          (bool)
        :param expand_y:         If True the element will automatically expand in the Y direction to fill available space
        :type expand_y:          (bool)
        :param visible:          set visibility state of the element
        :type visible:           (bool)
        :param metadata:         User metadata that can be set to ANYTHING
        :type metadata:          (Any)
        """
        ...
    
    def update(self, value=..., values=..., disabled=..., readonly=..., visible=...): # -> None:
        """
        Changes some of the settings for the Spin Element. Must call `Window.Read` or `Window.Finalize` prior
        Note that the state can be in 3 states only.... enabled, disabled, readonly even
        though more combinations are available. The easy way to remember is that if you
        change the readonly parameter then you are enabling the element.

        Changes will not be visible in your window until you call window.read or window.refresh.

        If you change visibility, your element may MOVE. If you want it to remain stationary, use the "layout helper"
        function "pin" to ensure your element is "pinned" to that location in your layout so that it returns there
        when made visible.

        :param value:    set the current value from list of choices
        :type value:     (Any)
        :param values:   set available choices
        :type values:    List[Any]
        :param disabled: disable. Note disabled and readonly cannot be mixed. It must be one OR the other
        :type disabled:  (bool)
        :param readonly: make element readonly.  Note disabled and readonly cannot be mixed. It must be one OR the other
        :type readonly:  (bool)
        :param visible:  control visibility of element
        :type visible:   (bool)
        """
        ...
    
    def get(self):
        """
        Return the current chosen value showing in spinbox.
        This value will be the same as what was provided as list of choices.  If list items are ints, then the
        item returned will be an int (not a string)

        :return: The currently visible entry
        :rtype:  (Any)
        """
        ...
    
    Get = ...
    Update = ...


Sp: Spin = ...
class Multiline(Element):
    """
    Multiline Element - Display and/or read multiple lines of text.  This is both an input and output element.
    Other PySimpleGUI ports have a separate MultilineInput and MultilineOutput elements.  May want to split this
    one up in the future too.
    """
    def __init__(self, default_text=..., enter_submits=..., disabled=..., autoscroll=..., border_width=..., size=..., s=..., auto_size_text=..., background_color=..., text_color=..., horizontal_scroll=..., change_submits=..., enable_events=..., do_not_clear=..., key=..., k=..., write_only=..., auto_refresh=..., reroute_stdout=..., reroute_stderr=..., reroute_cprint=..., echo_stdout_stderr=..., focus=..., font=..., pad=..., p=..., tooltip=..., justification=..., no_scrollbar=..., sbar_trough_color=..., sbar_background_color=..., sbar_arrow_color=..., sbar_width=..., sbar_arrow_width=..., sbar_frame_color=..., sbar_relief=..., expand_x=..., expand_y=..., rstrip=..., right_click_menu=..., visible=..., metadata=...) -> None:
        """
        :param default_text:                 Initial text to show
        :type default_text:                  (Any)
        :param enter_submits:                if True, the Window.Read call will return is enter key is pressed in this element
        :type enter_submits:                 (bool)
        :param disabled:                     set disable state
        :type disabled:                      (bool)
        :param autoscroll:                   If True the contents of the element will automatically scroll as more data added to the end
        :type autoscroll:                    (bool)
        :param border_width:                 width of border around element in pixels
        :type border_width:                  (int)
        :param size:                         (w, h) w=characters-wide, h=rows-high. If an int instead of a tuple is supplied, then height is auto-set to 1
        :type size:                          (int, int)  | (None, None) | int
        :param s:                            Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
        :type s:                             (int, int)  | (None, None) | int
        :param auto_size_text:               if True will size the element to match the length of the text
        :type auto_size_text:                (bool)
        :param background_color:             color of background
        :type background_color:              (str)
        :param text_color:                   color of the text
        :type text_color:                    (str)
        :param horizontal_scroll:            Controls if a horizontal scrollbar should be shown.  If True a horizontal scrollbar will be shown in addition to vertical
        :type horizontal_scroll:             (bool)
        :param change_submits:               DO NOT USE. Only listed for backwards compat - Use enable_events instead
        :type change_submits:                (bool)
        :param enable_events:                Turns on the element specific events. Spin events happen when an item changes
        :type enable_events:                 (bool)
        :param do_not_clear:                 if False the element will be cleared any time the Window.Read call returns
        :type do_not_clear:                  (bool)
        :param key:                          Used with window.find_element and with return values to uniquely identify this element to uniquely identify this element
        :type key:                           str | int | tuple | object
        :param k:                            Same as the Key. You can use either k or key. Which ever is set will be used.
        :type k:                             str | int | tuple | object
        :param write_only:                   If True then no entry will be added to the values dictionary when the window is read
        :type write_only:                    bool
        :param auto_refresh:                 If True then anytime the element is updated, the window will be refreshed so that the change is immediately displayed
        :type auto_refresh:                  (bool)
        :param reroute_stdout:               If True then all output to stdout will be output to this element
        :type reroute_stdout:                (bool)
        :param reroute_stderr:               If True then all output to stderr will be output to this element
        :type reroute_stderr:                (bool)
        :param reroute_cprint:               If True your cprint calls will output to this element. It's the same as you calling cprint_set_output_destination
        :type reroute_cprint:                (bool)
        :param echo_stdout_stderr:           If True then output to stdout and stderr will be output to this element AND also to the normal console location
        :type echo_stdout_stderr:            (bool)
        :param focus:                        if True initial focus will go to this element
        :type focus:                         (bool)
        :param font:                         specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
        :type font:                          (str or (str, int[, str]) or None)
        :param pad:                          Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
        :type pad:                           (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param p:                            Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
        :type p:                             (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param tooltip:                      text, that will appear when mouse hovers over the element
        :type tooltip:                       (str)
        :param justification:                text justification. left, right, center. Can use single characters l, r, c.
        :type justification:                 (str)
        :param no_scrollbar:                 If False then a vertical scrollbar will be shown (the default)
        :type no_scrollbar:                  (bool)
        :param sbar_trough_color:           Scrollbar color of the trough
        :type sbar_trough_color:            (str)
        :param sbar_background_color:       Scrollbar color of the background of the arrow buttons at the ends AND the color of the "thumb" (the thing you grab and slide). Switches to arrow color when mouse is over
        :type sbar_background_color:        (str)
        :param sbar_arrow_color:            Scrollbar color of the arrow at the ends of the scrollbar (it looks like a button). Switches to background color when mouse is over
        :type sbar_arrow_color:             (str)
        :param sbar_width:                  Scrollbar width in pixels
        :type sbar_width:                   (int)
        :param sbar_arrow_width:            Scrollbar width of the arrow on the scrollbar. It will potentially impact the overall width of the scrollbar
        :type sbar_arrow_width:             (int)
        :param sbar_frame_color:            Scrollbar Color of frame around scrollbar (available only on some ttk themes)
        :type sbar_frame_color:             (str)
        :param sbar_relief:                 Scrollbar relief that will be used for the "thumb" of the scrollbar (the thing you grab that slides). Should be a constant that is defined at starting with "RELIEF_" - RELIEF_RAISED, RELIEF_SUNKEN, RELIEF_FLAT, RELIEF_RIDGE, RELIEF_GROOVE, RELIEF_SOLID
        :type sbar_relief:                  (str)
        :param expand_x:                     If True the element will automatically expand in the X direction to fill available space
        :type expand_x:                      (bool)
        :param expand_y:                     If True the element will automatically expand in the Y direction to fill available space
        :type expand_y:                      (bool)
        :param rstrip:                       If True the value returned in will have whitespace stripped from the right side
        :type rstrip:                        (bool)
        :param right_click_menu:             A list of lists of Menu items to show when this element is right clicked. See user docs for exact format.
        :type right_click_menu:              List[List[ List[str] | str ]]
        :param visible:                      set visibility state of the element
        :type visible:                       (bool)
        :param metadata:                     User metadata that can be set to ANYTHING
        :type metadata:                      (Any)
        """
        ...
    
    def update(self, value=..., disabled=..., append=..., font=..., text_color=..., background_color=..., text_color_for_value=..., background_color_for_value=..., visible=..., autoscroll=..., justification=..., font_for_value=...):
        """
        Changes some of the settings for the Multiline Element. Must call `Window.Read` or `Window.Finalize` prior

        Changes will not be visible in your window until you call window.read or window.refresh.

        If you change visibility, your element may MOVE. If you want it to remain stationary, use the "layout helper"
        function "pin" to ensure your element is "pinned" to that location in your layout so that it returns there
        when made visible.

        :param value:                      new text to display
        :type value:                       (Any)
        :param disabled:                   disable or enable state of the element
        :type disabled:                    (bool)
        :param append:                     if True then new value will be added onto the end of the current value. if False then contents will be replaced.
        :type append:                      (bool)
        :param font:                       specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike for the entire element
        :type font:                        (str or (str, int[, str]) or None)
        :param text_color:                 color of the text
        :type text_color:                  (str)
        :param background_color:           color of background
        :type background_color:            (str)
        :param text_color_for_value:       color of the new text being added (the value paramter)
        :type text_color_for_value:        (str)
        :param background_color_for_value: color of the new background of the text being added (the value paramter)
        :type background_color_for_value:  (str)
        :param visible:                    set visibility state of the element
        :type visible:                     (bool)
        :param autoscroll:                 if True then contents of element are scrolled down when new text is added to the end
        :type autoscroll:                  (bool)
        :param justification:              text justification. left, right, center. Can use single characters l, r, c. Sets only for this value, not entire element
        :type justification:               (str)
        :param font_for_value:             specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike for the value being updated
        :type font_for_value:              str | (str, int)
        """
        ...
    
    def get(self): # -> str:
        """
        Return current contents of the Multiline Element

        :return: current contents of the Multiline Element (used as an input type of Multiline
        :rtype:  (str)
        """
        ...
    
    def print(self, *args, end=..., sep=..., text_color=..., background_color=..., justification=..., font=..., colors=..., t=..., b=..., c=..., autoscroll=...): # -> None:
        """
        Print like Python normally prints except route the output to a multiline element and also add colors if desired

        colors -(str, str) or str.  A combined text/background color definition in a single parameter

        There are also "aliases" for text_color, background_color and colors (t, b, c)
        t - An alias for color of the text (makes for shorter calls)
        b - An alias for the background_color parameter
        c - (str, str) - "shorthand" way of specifying color. (foreground, backgrouned)
        c - str - can also be a string of the format "foreground on background"  ("white on red")

        With the aliases it's possible to write the same print but in more compact ways:
        cprint('This will print white text on red background', c=('white', 'red'))
        cprint('This will print white text on red background', c='white on red')
        cprint('This will print white text on red background', text_color='white', background_color='red')
        cprint('This will print white text on red background', t='white', b='red')

        :param args:             The arguments to print
        :type args:              (Any)
        :param end:              The end char to use just like print uses
        :type end:               (str)
        :param sep:              The separation character like print uses
        :type sep:               (str)
        :param text_color:       The color of the text
        :type text_color:        (str)
        :param background_color: The background color of the line
        :type background_color:  (str)
        :param justification:    text justification. left, right, center. Can use single characters l, r, c. Sets only for this value, not entire element
        :type justification:     (str)
        :param font:             specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike for the args being printed
        :type font:              (str or (str, int[, str]) or None)
        :param colors:           Either a tuple or a string that has both the text and background colors. Or just the text color
        :type colors:            (str) or (str, str)
        :param t:                Color of the text
        :type t:                 (str)
        :param b:                The background color of the line
        :type b:                 (str)
        :param c:                Either a tuple or a string that has both the text and background colors or just tex color (same as the color parm)
        :type c:                 (str) or (str, str)
        :param autoscroll:       If True the contents of the element will automatically scroll as more data added to the end
        :type autoscroll:        (bool)
        """
        ...
    
    def reroute_stdout_to_here(self): # -> None:
        """
        Sends stdout (prints) to this element
        """
        ...
    
    def reroute_stderr_to_here(self): # -> None:
        """
        Sends stderr to this element
        """
        ...
    
    def restore_stdout(self): # -> None:
        """
        Restore a previously re-reouted stdout back to the original destination
        """
        ...
    
    def restore_stderr(self): # -> None:
        """
        Restore a previously re-reouted stderr back to the original destination
        """
        ...
    
    def write(self, txt): # -> None:
        """
        Called by Python (not tkinter?) when stdout or stderr wants to write

        :param txt: text of output
        :type txt:  (str)
        """
        ...
    
    def flush(self): # -> None:
        """
        Flush parameter was passed into a print statement.
        For now doing nothing.  Not sure what action should be taken to ensure a flush happens regardless.
        """
        ...
    
    def __del__(self): # -> None:
        """
        If this Widget is deleted, be sure and restore the old stdout, stderr
        """
        ...
    
    Get = ...
    Update = ...


ML = Multiline
MLine = Multiline
class Text(Element):
    """
    Text - Display some text in the window.  Usually this means a single line of text.  However, the text can also be multiple lines.  If multi-lined there are no scroll bars.
    """
    def __init__(self, text=..., size=..., s=..., auto_size_text=..., click_submits=..., enable_events=..., relief=..., font=..., text_color=..., background_color=..., border_width=..., justification=..., pad=..., p=..., key=..., k=..., right_click_menu=..., expand_x=..., expand_y=..., grab=..., tooltip=..., visible=..., metadata=...) -> None:
        """
        :param text:             The text to display. Can include /n to achieve multiple lines.  Will convert (optional) parameter into a string
        :type text:              Any
        :param size:             (w, h) w=characters-wide, h=rows-high. If an int instead of a tuple is supplied, then height is auto-set to 1
        :type size:              (int, int) |  (int, None) | (None, None) | (int, ) | int
        :param s:                Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
        :type s:                 (int, int) |  (int, None) | (None, None) | (int, ) | int
        :param auto_size_text:   if True size of the Text Element will be sized to fit the string provided in 'text' parm
        :type auto_size_text:    (bool)
        :param click_submits:    DO NOT USE. Only listed for backwards compat - Use enable_events instead
        :type click_submits:     (bool)
        :param enable_events:    Turns on the element specific events. Text events happen when the text is clicked
        :type enable_events:     (bool)
        :param relief:           relief style around the text. Values are same as progress meter relief values. Should be a constant that is defined at starting with "RELIEF_" - RELIEF_RAISED, RELIEF_SUNKEN, RELIEF_FLAT, RELIEF_RIDGE, RELIEF_GROOVE, RELIEF_SOLID
        :type relief:            (str/enum)
        :param font:             specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
        :type font:              (str or (str, int[, str]) or None)
        :param text_color:       color of the text
        :type text_color:        (str)
        :param background_color: color of background
        :type background_color:  (str)
        :param border_width:     number of pixels for the border (if using a relief)
        :type border_width:      (int)
        :param justification:    how string should be aligned within space provided by size. Valid choices = `left`, `right`, `center`
        :type justification:     (str)
        :param pad:              Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
        :type pad:               (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param p:                Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
        :type p:                 (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param key:              Used with window.find_element and with return values to uniquely identify this element to uniquely identify this element
        :type key:               str or int or tuple or object
        :param k:                Same as the Key. You can use either k or key. Which ever is set will be used.
        :type k:                 str | int | tuple | object
        :param right_click_menu: A list of lists of Menu items to show when this element is right clicked. See user docs for exact format.
        :type right_click_menu:  List[List[ List[str] | str ]]
        :param expand_x:         If True the element will automatically expand in the X direction to fill available space
        :type expand_x:          (bool)
        :param expand_y:         If True the element will automatically expand in the Y direction to fill available space
        :type expand_y:          (bool)
        :param grab:             If True can grab this element and move the window around. Default is False
        :type grab:              (bool)
        :param tooltip:          text, that will appear when mouse hovers over the element
        :type tooltip:           (str)
        :param visible:          set visibility state of the element
        :type visible:           (bool)
        :param metadata:         User metadata that can be set to ANYTHING
        :type metadata:          (Any)
        """
        ...
    
    def update(self, value=..., background_color=..., text_color=..., font=..., visible=...): # -> None:
        """
        Changes some of the settings for the Text Element. Must call `Window.Read` or `Window.Finalize` prior

        Changes will not be visible in your window until you call window.read or window.refresh.

        If you change visibility, your element may MOVE. If you want it to remain stationary, use the "layout helper"
        function "pin" to ensure your element is "pinned" to that location in your layout so that it returns there
        when made visible.

        :param value:            new text to show
        :type value:             (str)
        :param background_color: color of background
        :type background_color:  (str)
        :param text_color:       color of the text
        :type text_color:        (str)
        :param font:             specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
        :type font:              (str or (str, int[, str]) or None)
        :param visible:          set visibility state of the element
        :type visible:           (bool)
        """
        ...
    
    def get(self): # -> Literal['']:
        """
        Gets the current value of the displayed text

        :return: The current value
        :rtype:  (str)
        """
        ...
    
    @classmethod
    def fonts_installed_list(cls): # -> list[str]:
        """
        Returns a list of strings that tkinter reports as the installed fonts

        :return:          List of the installed font names
        :rtype:           List[str]
        """
        ...
    
    @classmethod
    def char_width_in_pixels(cls, font, character=...): # -> int:
        """
        Get the with of the character "W" in pixels for the font being passed in or
        the character of your choosing if "W" is not a good representative character.
        Cannot be used until a window has been created.
        If an error occurs, 0 will be returned
        :param font:      specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike, to be measured
        :type font:       (str or (str, int[, str]) or None)
        :param character: specifies a SINGLE CHARACTER character to measure
        :type character:  (str)
        :return:          Width in pixels of "A"
        :rtype:           (int)
        """
        ...
    
    @classmethod
    def char_height_in_pixels(cls, font): # -> int:
        """
        Get the height of a string if using the supplied font in pixels.
        Cannot be used until a window has been created.
        If an error occurs, 0 will be returned
        :param font: specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike, to be measured
        :type font:  (str or (str, int[, str]) or None)
        :return:     Height in pixels of "A"
        :rtype:      (int)
        """
        ...
    
    @classmethod
    def string_width_in_pixels(cls, font, string): # -> int:
        """
        Get the with of the supplied string in pixels for the font being passed in.
        If an error occurs, 0 will be returned
        :param font:   specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike, to be measured
        :type font:    (str or (str, int[, str]) or None)
        :param string: the string to measure
        :type string:  str
        :return:       Width in pixels of string
        :rtype:        (int)
        """
        ...
    
    def print(self, *args, end=..., sep=..., text_color=..., background_color=..., justification=..., font=..., colors=..., t=..., b=..., c=..., autoscroll=..., append=...): # -> None:
        """
        Print like Python normally prints except route the output to a multiline element and also add colors if desired

        colors -(str, str) or str.  A combined text/background color definition in a single parameter

        There are also "aliases" for text_color, background_color and colors (t, b, c)
        t - An alias for color of the text (makes for shorter calls)
        b - An alias for the background_color parameter
        c - (str, str) - "shorthand" way of specifying color. (foreground, backgrouned)
        c - str - can also be a string of the format "foreground on background"  ("white on red")

        With the aliases it's possible to write the same print but in more compact ways:
        cprint('This will print white text on red background', c=('white', 'red'))
        cprint('This will print white text on red background', c='white on red')
        cprint('This will print white text on red background', text_color='white', background_color='red')
        cprint('This will print white text on red background', t='white', b='red')

        :param args:             The arguments to print
        :type args:              (Any)
        :param end:              The end char to use just like print uses
        :type end:               (str)
        :param sep:              The separation character like print uses
        :type sep:               (str)
        :param text_color:       The color of the text
        :type text_color:        (str)
        :param background_color: The background color of the line
        :type background_color:  (str)
        :param justification:    text justification. left, right, center. Can use single characters l, r, c. Sets only for this value, not entire element
        :type justification:     (str)
        :param font:             specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike for the args being printed
        :type font:              (str or (str, int[, str]) or None)
        :param colors:           Either a tuple or a string that has both the text and background colors. Or just the text color
        :type colors:            (str) or (str, str)
        :param t:                Color of the text
        :type t:                 (str)
        :param b:                The background color of the line
        :type b:                 (str)
        :param c:                Either a tuple or a string that has both the text and background colors or just tex color (same as the color parm)
        :type c:                 (str) or (str, str)
        :param autoscroll:       If True the contents of the element will automatically scroll as more data added to the end
        :type autoscroll:        (bool)
        """
        ...
    
    Get = ...
    Update = ...


Txt: Text = ...
T: Text = ...
class StatusBar(Element):
    """
    A StatusBar Element creates the sunken text-filled strip at the bottom. Many Windows programs have this line
    """
    def __init__(self, text, size=..., s=..., auto_size_text=..., click_submits=..., enable_events=..., relief=..., font=..., text_color=..., background_color=..., justification=..., pad=..., p=..., key=..., k=..., right_click_menu=..., expand_x=..., expand_y=..., tooltip=..., visible=..., metadata=...) -> None:
        """
        :param text:             Text that is to be displayed in the widget
        :type text:              (str)
        :param size:             (w, h) w=characters-wide, h=rows-high. If an int instead of a tuple is supplied, then height is auto-set to 1
        :type size:              (int, int) |  (int, None) | int
        :param s:                Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
        :type s:                 (int, int)  | (None, None) | int
        :param auto_size_text:   True if size should fit the text length
        :type auto_size_text:    (bool)
        :param click_submits:    DO NOT USE. Only listed for backwards compat - Use enable_events instead
        :type click_submits:     (bool)
        :param enable_events:    Turns on the element specific events. StatusBar events occur when the bar is clicked
        :type enable_events:     (bool)
        :param relief:           relief style. Values are same as progress meter relief values.  Can be a constant or a string: `RELIEF_RAISED RELIEF_SUNKEN RELIEF_FLAT RELIEF_RIDGE RELIEF_GROOVE RELIEF_SOLID`
        :type relief:            (enum)
        :param font:             specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
        :type font:              (str or (str, int[, str]) or None)
        :param text_color:       color of the text
        :type text_color:        (str)
        :param background_color: color of background
        :type background_color:  (str)
        :param justification:    how string should be aligned within space provided by size. Valid choices = `left`, `right`, `center`
        :type justification:     (str)
        :param pad:              Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
        :type pad:               (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param p:                Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
        :type p:                 (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param key:              Used with window.find_element and with return values to uniquely identify this element to uniquely identify this element
        :type key:               str | int | tuple | object
        :param k:                Same as the Key. You can use either k or key. Which ever is set will be used.
        :type k:                 str | int | tuple | object
        :param right_click_menu: A list of lists of Menu items to show when this element is right clicked. See user docs for exact format.
        :type right_click_menu:  List[List[ List[str] | str ]]
        :param expand_x:         If True the element will automatically expand in the X direction to fill available space
        :type expand_x:          (bool)
        :param expand_y:         If True the element will automatically expand in the Y direction to fill available space
        :type expand_y:          (bool)
        :param tooltip:          text, that will appear when mouse hovers over the element
        :type tooltip:           (str)
        :param visible:          set visibility state of the element
        :type visible:           (bool)
        :param metadata:         User metadata that can be set to ANYTHING
        :type metadata:          (Any)
        """
        ...
    
    def update(self, value=..., background_color=..., text_color=..., font=..., visible=...): # -> None:
        """
        Changes some of the settings for the Status Bar Element. Must call `Window.Read` or `Window.Finalize` prior

        Changes will not be visible in your window until you call window.read or window.refresh.

        If you change visibility, your element may MOVE. If you want it to remain stationary, use the "layout helper"
        function "pin" to ensure your element is "pinned" to that location in your layout so that it returns there
        when made visible.

        :param value:            new text to show
        :type value:             (str)
        :param background_color: color of background
        :type background_color:  (str)
        :param text_color:       color of the text
        :type text_color:        (str)
        :param font:             specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
        :type font:              (str or (str, int[, str]) or None)
        :param visible:          set visibility state of the element
        :type visible:           (bool)
        """
        ...
    
    Update = ...


SBar = StatusBar
class TKProgressBar:
    uniqueness_counter = ...
    def __init__(self, root, max, length=..., width=..., ttk_theme=..., style_name=..., relief=..., border_width=..., orientation=..., BarColor=..., key=...) -> None:
        """
        :param root:         The root window bar is to be shown in
        :type root:          tk.Tk | tk.TopLevel
        :param max:          Maximum value the bar will be measuring
        :type max:           (int)
        :param length:       length in pixels of the bar
        :type length:        (int)
        :param width:        width in pixels of the bar
        :type width:         (int)
        :param style_name:   Progress bar style to use.  Set in the packer function
        :type style_name:    (str)
        :param ttk_theme:    Progress bar style defined as one of these 'default', 'winnative', 'clam', 'alt', 'classic', 'vista', 'xpnative'
        :type ttk_theme:     (str)
        :param relief:       relief style. Values are same as progress meter relief values.  Can be a constant or a string: `RELIEF_RAISED RELIEF_SUNKEN RELIEF_FLAT RELIEF_RIDGE RELIEF_GROOVE RELIEF_SOLID` (Default value = DEFAULT_PROGRESS_BAR_RELIEF)
        :type relief:        (str)
        :param border_width: The amount of pixels that go around the outside of the bar
        :type border_width:  (int)
        :param orientation:  'horizontal' or 'vertical' ('h' or 'v' work) (Default value = 'vertical')
        :type orientation:   (str)
        :param BarColor:     The 2 colors that make up a progress bar. One is the background, the other is the bar
        :type BarColor:      (str, str)
        :param key:          Used with window.find_element and with return values to uniquely identify this element to uniquely identify this element
        :type key:           str | int | tuple | object
        """
        ...
    
    def Update(self, count=..., max=...): # -> bool:
        """
        Update the current value of the bar and/or update the maximum value the bar can reach
        :param count: current value
        :type count:  (int)
        :param max:   the maximum value
        :type max:    (int)
        """
        ...
    


class Output(Multiline):
    """
    ** NOTE - It's recommended to use Multiline Element instead **

    Output Element - a multi-lined text area where stdout and stderr are re-routed to.

    The Multiline Element is the superior and recommended method for showing the output of stdout.
    The Multiline Element has been added to significantly while the Output element has not.
    If you choose to use a Multiline element to replace an Output element, be sure an turn on the write_only paramter in the Multline

    Of course, Output Element continues to operate and be backwards compatible, but you're missing out on
    features such as routing the cprint output to the element.

    In Apr 2022, the Output Element was switched to be a subclass of the Multiline so that more code will be in common. Nowever
    you will not get all of the parms unless you switch to the Multline Specifically
    """
    def __init__(self, size=..., s=..., background_color=..., text_color=..., pad=..., p=..., echo_stdout_stderr=..., font=..., tooltip=..., key=..., k=..., right_click_menu=..., expand_x=..., expand_y=..., visible=..., metadata=..., sbar_trough_color=..., sbar_background_color=..., sbar_arrow_color=..., sbar_width=..., sbar_arrow_width=..., sbar_frame_color=..., sbar_relief=...) -> None:
        """
        :param size:                        (w, h) w=characters-wide, h=rows-high. If an int instead of a tuple is supplied, then height is auto-set to 1
        :type size:                         (int, int)  | (None, None) | int
        :param s:                           Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
        :type s:                            (int, int)  | (None, None) | int
        :param background_color:            color of background
        :type background_color:             (str)
        :param text_color:                  color of the text
        :type text_color:                   (str)
        :param pad:                         Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
        :type pad:                          (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param p:                           Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
        :type p:                            (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param echo_stdout_stderr:          If True then output to stdout will be output to this element AND also to the normal console location
        :type echo_stdout_stderr:           (bool)
        :param font:                        specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
        :type font:                         (str or (str, int[, str]) or None)
        :param tooltip:                     text, that will appear when mouse hovers over the element
        :type tooltip:                      (str)
        :param key:                         Used with window.find_element and with return values to uniquely identify this element to uniquely identify this element
        :type key:                          str | int | tuple | object
        :param k:                           Same as the Key. You can use either k or key. Which ever is set will be used.
        :type k:                            str | int | tuple | object
        :param right_click_menu:            A list of lists of Menu items to show when this element is right clicked. See user docs for exact format.
        :type right_click_menu:             List[List[ List[str] | str ]]
        :param expand_x:                    If True the element will automatically expand in the X direction to fill available space
        :type expand_x:                     (bool)
        :param expand_y:                    If True the element will automatically expand in the Y direction to fill available space
        :type expand_y:                     (bool)
        :param visible:                     set visibility state of the element
        :type visible:                      (bool)
        :param metadata:                    User metadata that can be set to ANYTHING
        :type metadata:                     (Any)
        :param sbar_trough_color:           Scrollbar color of the trough
        :type sbar_trough_color:            (str)
        :param sbar_background_color:       Scrollbar color of the background of the arrow buttons at the ends AND the color of the "thumb" (the thing you grab and slide). Switches to arrow color when mouse is over
        :type sbar_background_color:        (str)
        :param sbar_arrow_color:            Scrollbar color of the arrow at the ends of the scrollbar (it looks like a button). Switches to background color when mouse is over
        :type sbar_arrow_color:             (str)
        :param sbar_width:                  Scrollbar width in pixels
        :type sbar_width:                   (int)
        :param sbar_arrow_width:            Scrollbar width of the arrow on the scrollbar. It will potentially impact the overall width of the scrollbar
        :type sbar_arrow_width:             (int)
        :param sbar_frame_color:            Scrollbar Color of frame around scrollbar (available only on some ttk themes)
        :type sbar_frame_color:             (str)
        :param sbar_relief:                 Scrollbar relief that will be used for the "thumb" of the scrollbar (the thing you grab that slides). Should be a constant that is defined at starting with "RELIEF_" - RELIEF_RAISED, RELIEF_SUNKEN, RELIEF_FLAT, RELIEF_RIDGE, RELIEF_GROOVE, RELIEF_SOLID
        :type sbar_relief:                  (str)
        """
        ...
    


class Button(Element):
    """
    Button Element - Defines all possible buttons. The shortcuts such as Submit, FileBrowse, ... each create a Button
    """
    def __init__(self, button_text=..., button_type=..., target=..., tooltip=..., file_types=..., initial_folder=..., default_extension=..., disabled=..., change_submits=..., enable_events=..., image_filename=..., image_data=..., image_size=..., image_subsample=..., image_source=..., border_width=..., size=..., s=..., auto_size_button=..., button_color=..., disabled_button_color=..., highlight_colors=..., mouseover_colors=..., use_ttk_buttons=..., font=..., bind_return_key=..., focus=..., pad=..., p=..., key=..., k=..., right_click_menu=..., expand_x=..., expand_y=..., visible=..., metadata=...) -> None:
        """
        :param button_text:           Text to be displayed on the button
        :type button_text:            (str)
        :param button_type:           You  should NOT be setting this directly. ONLY the shortcut functions set this
        :type button_type:            (int)
        :param target:                key or (row,col) target for the button. Note that -1 for column means 1 element to the left of this one. The constant ThisRow is used to indicate the current row. The Button itself is a valid target for some types of button
        :type target:                 str | (int, int)
        :param tooltip:               text, that will appear when mouse hovers over the element
        :type tooltip:                (str)
        :param file_types:            the filetypes that will be used to match files. To indicate all files: (("ALL Files", "*.* *"),). NOT avoilable on the MAC
        :type file_types:             Tuple[(str, str), ...]
        :param initial_folder:        starting path for folders and files
        :type initial_folder:         (str)
        :param default_extension:     If no extension entered by user, add this to filename (only used in saveas dialogs)
        :type default_extension:      (str)
        :param disabled:              If True button will be created disabled. If BUTTON_DISABLED_MEANS_IGNORE then the button will be ignored rather than disabled using tkinter
        :type disabled:               (bool | str)
        :param change_submits:        DO NOT USE. Only listed for backwards compat - Use enable_events instead
        :type change_submits:         (bool)
        :param enable_events:         Turns on the element specific events. If this button is a target, should it generate an event when filled in
        :type enable_events:          (bool)
        :param image_source:          Image to place on button. Use INSTEAD of the image_filename and image_data. Unifies these into 1 easier to use parm
        :type image_source:           (str | bytes)
        :param image_filename:        image filename if there is a button image. GIFs and PNGs only.
        :type image_filename:         (str)
        :param image_data:            Raw or Base64 representation of the image to put on button. Choose either filename or data
        :type image_data:             bytes | str
        :param image_size:            Size of the image in pixels (width, height)
        :type image_size:             (int, int)
        :param image_subsample:       amount to reduce the size of the image. Divides the size by this number. 2=1/2, 3=1/3, 4=1/4, etc
        :type image_subsample:        (int)
        :param border_width:          width of border around button in pixels
        :type border_width:           (int)
        :param size:                  (w, h) w=characters-wide, h=rows-high. If an int instead of a tuple is supplied, then height is auto-set to 1
        :type size:                   (int | None, int | None)  | (None, None) | int
        :param s:                     Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
        :type s:                      (int | None, int | None)  | (None, None) | int
        :param auto_size_button:      if True the button size is sized to fit the text
        :type auto_size_button:       (bool)
        :param button_color:          Color of button. default is from theme or the window. Easy to remember which is which if you say "ON" between colors. "red" on "green". Normally a tuple, but can be a simplified-button-color-string "foreground on background". Can be a single color if want to set only the background.
        :type button_color:           (str, str) | str | (int, int) | None
        :param disabled_button_color: colors to use when button is disabled (text, background). Use None for a color if don't want to change. Only ttk buttons support both text and background colors. tk buttons only support changing text color
        :type disabled_button_color:  (str, str) | str
        :param highlight_colors:      colors to use when button has focus (has focus, does not have focus). None will use colors based on theme. Only used by Linux and only for non-TTK button
        :type highlight_colors:       (str, str)
        :param mouseover_colors:      Important difference between Linux & Windows! Linux - Colors when mouse moved over button.  Windows - colors when button is pressed. The default is to switch the text and background colors (an inverse effect)
        :type mouseover_colors:       (str, str) | str
        :param use_ttk_buttons:       True = use ttk buttons. False = do not use ttk buttons.  None (Default) = use ttk buttons only if on a Mac and not with button images
        :type use_ttk_buttons:        (bool)
        :param font:                  specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
        :type font:                   (str or (str, int[, str]) or None)
        :param bind_return_key:       If True the return key will cause this button to be pressed
        :type bind_return_key:        (bool)
        :param focus:                 if True, initial focus will be put on this button
        :type focus:                  (bool)
        :param pad:                   Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
        :type pad:                    (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param p:                     Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
        :type p:                      (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param key:                   Used with window.find_element and with return values to uniquely identify this element to uniquely identify this element
        :type key:                    str | int | tuple | object
        :param k:                     Same as the Key. You can use either k or key. Which ever is set will be used.
        :type k:                      str | int | tuple | object
        :param right_click_menu:      A list of lists of Menu items to show when this element is right clicked. See user docs for exact format.
        :type right_click_menu:       List[List[ List[str] | str ]]
        :param expand_x:              If True the element will automatically expand in the X direction to fill available space
        :type expand_x:               (bool)
        :param expand_y:              If True the element will automatically expand in the Y direction to fill available space
        :type expand_y:               (bool)
        :param visible:               set visibility state of the element
        :type visible:                (bool)
        :param metadata:              User metadata that can be set to ANYTHING
        :type metadata:               (Any)
        """
        ...
    
    def ButtonReleaseCallBack(self, parm): # -> None:
        """
        Not a user callable function.  Called by tkinter when a "realtime" button is released

        :param parm: the event info from tkinter
        :type parm:

        """
        ...
    
    def ButtonPressCallBack(self, parm): # -> None:
        """
        Not a user callable method. Callback called by tkinter when a "realtime" button is pressed

        :param parm: Event info passed in by tkinter
        :type parm:

        """
        ...
    
    def ButtonCallBack(self): # -> None:
        """
        Not user callable! Called by tkinter when a button is clicked.  This is where all the fun begins!
        """
        ...
    
    def update(self, text=..., button_color=..., disabled=..., image_data=..., image_filename=..., visible=..., image_subsample=..., disabled_button_color=..., image_size=...):
        """
        Changes some of the settings for the Button Element. Must call `Window.Read` or `Window.Finalize` prior

        Changes will not be visible in your window until you call window.read or window.refresh.

        If you change visibility, your element may MOVE. If you want it to remain stationary, use the "layout helper"
        function "pin" to ensure your element is "pinned" to that location in your layout so that it returns there
        when made visible.

        :param text:                  sets button text
        :type text:                   (str)
        :param button_color:          Color of button. default is from theme or the window. Easy to remember which is which if you say "ON" between colors. "red" on "green". Normally a tuple, but can be a simplified-button-color-string "foreground on background". Can be a single color if want to set only the background.
        :type button_color:           (str, str) | str | (int, int) | None
        :param disabled:              True/False to enable/disable at the GUI level. Use BUTTON_DISABLED_MEANS_IGNORE to ignore clicks (won't change colors)
        :type disabled:               (bool | str)
        :param image_data:            Raw or Base64 representation of the image to put on button. Choose either filename or data
        :type image_data:             bytes | str
        :param image_filename:        image filename if there is a button image. GIFs and PNGs only.
        :type image_filename:         (str)
        :param disabled_button_color: colors to use when button is disabled (text, background). Use None for a color if don't want to change. Only ttk buttons support both text and background colors. tk buttons only support changing text color
        :type disabled_button_color:  (str, str)
        :param visible:               control visibility of element
        :type visible:                (bool)
        :param image_subsample:       amount to reduce the size of the image. Divides the size by this number. 2=1/2, 3=1/3, 4=1/4, etc
        :type image_subsample:        (int)
        :param image_size:            Size of the image in pixels (width, height)
        :type image_size:             (int, int)
        """
        ...
    
    def get_text(self): # -> str:
        """
        Returns the current text shown on a button

        :return: The text currently displayed on the button
        :rtype:  (str)
        """
        ...
    
    def click(self): # -> None:
        """
        Generates a click of the button as if the user clicked the button
        Calls the tkinter invoke method for the button
        """
        ...
    
    Click = ...
    GetText = ...
    Update = ...


B = Button
Btn = Button
class ButtonMenu(Element):
    """
    The Button Menu Element.  Creates a button that when clicked will show a menu similar to right click menu
    """
    def __init__(self, button_text, menu_def, tooltip=..., disabled=..., image_source=..., image_filename=..., image_data=..., image_size=..., image_subsample=..., border_width=..., size=..., s=..., auto_size_button=..., button_color=..., text_color=..., background_color=..., disabled_text_color=..., font=..., item_font=..., pad=..., p=..., expand_x=..., expand_y=..., key=..., k=..., tearoff=..., visible=..., metadata=...) -> None:
        """
        :param button_text:         Text to be displayed on the button
        :type button_text:          (str)
        :param menu_def:            A list of lists of Menu items to show when this element is clicked. See docs for format as they are the same for all menu types
        :type menu_def:             List[List[str]]
        :param tooltip:             text, that will appear when mouse hovers over the element
        :type tooltip:              (str)
        :param disabled:            If True button will be created disabled
        :type disabled:             (bool)
        :param image_source:        Image to place on button. Use INSTEAD of the image_filename and image_data. Unifies these into 1 easier to use parm
        :type image_source:         (str | bytes)
        :param image_filename:      image filename if there is a button image. GIFs and PNGs only.
        :type image_filename:       (str)
        :param image_data:          Raw or Base64 representation of the image to put on button. Choose either filename or data
        :type image_data:           bytes | str
        :param image_size:          Size of the image in pixels (width, height)
        :type image_size:           (int, int)
        :param image_subsample:     amount to reduce the size of the image. Divides the size by this number. 2=1/2, 3=1/3, 4=1/4, etc
        :type image_subsample:      (int)
        :param border_width:        width of border around button in pixels
        :type border_width:         (int)
        :param size:                (w, h) w=characters-wide, h=rows-high. If an int instead of a tuple is supplied, then height is auto-set to 1
        :type size:                 (int, int)  | (None, None) | int
        :param s:                   Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
        :type s:                    (int, int)  | (None, None) | int
        :param auto_size_button:    if True the button size is sized to fit the text
        :type auto_size_button:     (bool)
        :param button_color:        of button. Easy to remember which is which if you say "ON" between colors. "red" on "green"
        :type button_color:         (str, str) or str
        :param background_color:    color of the background
        :type background_color:     (str)
        :param text_color:          element's text color. Can be in #RRGGBB format or a color name "black"
        :type text_color:           (str)
        :param disabled_text_color: color to use for text when item is disabled. Can be in #RRGGBB format or a color name "black"
        :type disabled_text_color:  (str)
        :param font:                specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
        :type font:                 (str or (str, int[, str]) or None)
        :param item_font:           specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike, for the menu items
        :type item_font:            (str or (str, int[, str]) or None)
        :param pad:                 Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
        :type pad:                  (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param p:                   Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
        :type p:                    (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param expand_x:            If True the element will automatically expand in the X direction to fill available space
        :type expand_x:             (bool)
        :param expand_y:            If True the element will automatically expand in the Y direction to fill available space
        :type expand_y:             (bool)
        :param key:                 Used with window.find_element and with return values to uniquely identify this element to uniquely identify this element
        :type key:                  str | int | tuple | object
        :param k:                   Same as the Key. You can use either k or key. Which ever is set will be used.
        :type k:                    str | int | tuple | object
        :param tearoff:             Determines if menus should allow them to be torn off
        :type tearoff:              (bool)
        :param visible:             set visibility state of the element
        :type visible:              (bool)
        :param metadata:            User metadata that can be set to ANYTHING
        :type metadata:             (Any)
        """
        ...
    
    def update(self, menu_definition=..., visible=..., image_source=..., image_size=..., image_subsample=..., button_text=...):
        """
        Changes some of the settings for the ButtonMenu Element. Must call `Window.Read` or `Window.Finalize` prior

        Changes will not be visible in your window until you call window.read or window.refresh.

        If you change visibility, your element may MOVE. If you want it to remain stationary, use the "layout helper"
        function "pin" to ensure your element is "pinned" to that location in your layout so that it returns there
        when made visible.

        :param menu_definition: (New menu definition (in menu definition format)
        :type menu_definition:  List[List]
        :param visible:         control visibility of element
        :type visible:          (bool)
        :param image_source:    new image if image is to be changed. Can be a filename or a base64 encoded byte-string
        :type image_source:     (str | bytes)
        :param image_size:      Size of the image in pixels (width, height)
        :type image_size:       (int, int)
        :param image_subsample: amount to reduce the size of the image. Divides the size by this number. 2=1/2, 3=1/3, 4=1/4, etc
        :type image_subsample:  (int)
        :param button_text:     Text to be shown on the button
        :type button_text:      (str)
        """
        ...
    
    def click(self): # -> None:
        """
        Generates a click of the button as if the user clicked the button
        Calls the tkinter invoke method for the button
        """
        ...
    
    Update = ...
    Click = ...


BMenu = ButtonMenu
BM = ButtonMenu
class ProgressBar(Element):
    """
    Progress Bar Element - Displays a colored bar that is shaded as progress of some operation is made
    """
    def __init__(self, max_value, orientation=..., size=..., s=..., size_px=..., auto_size_text=..., bar_color=..., style=..., border_width=..., relief=..., key=..., k=..., pad=..., p=..., right_click_menu=..., expand_x=..., expand_y=..., visible=..., metadata=...) -> None:
        """
        :param max_value:        max value of progressbar
        :type max_value:         (int)
        :param orientation:      'horizontal' or 'vertical'
        :type orientation:       (str)
        :param size:             Size of the bar.  If horizontal (chars long, pixels wide), vert (chars high, pixels wide). Vert height measured using horizontal chars units.
        :type size:              (int, int) |  (int, None)
        :param s:                Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
        :type s:                 (int, int)  | (None, None)
        :param size_px:          Size in pixels (length, width). Will be used in place of size parm if specified
        :type size_px:           (int, int) | (None, None)
        :param auto_size_text:   Not sure why this is here
        :type auto_size_text:    (bool)
        :param bar_color:        The 2 colors that make up a progress bar. Easy to remember which is which if you say "ON" between colors. "red" on "green".
        :type bar_color:         (str, str) or str
        :param style:            Progress bar style defined as one of these 'default', 'winnative', 'clam', 'alt', 'classic', 'vista', 'xpnative'
        :type style:             (str)
        :param border_width:     The amount of pixels that go around the outside of the bar
        :type border_width:      (int)
        :param relief:           relief style. Values are same as progress meter relief values.  Can be a constant or a string: `RELIEF_RAISED RELIEF_SUNKEN RELIEF_FLAT RELIEF_RIDGE RELIEF_GROOVE RELIEF_SOLID` (Default value = DEFAULT_PROGRESS_BAR_RELIEF)
        :type relief:            (str)
        :param key:              Used with window.find_element and with return values to uniquely identify this element to uniquely identify this element
        :type key:               str | int | tuple | object
        :param k:                Same as the Key. You can use either k or key. Which ever is set will be used.
        :type k:                 str | int | tuple | object
        :param pad:              Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
        :type pad:               (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param p:                Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
        :type p:                 (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param right_click_menu: A list of lists of Menu items to show when this element is right clicked. See user docs for exact format.
        :type right_click_menu:  List[List[ List[str] | str ]]
        :param expand_x:         If True the element will automatically expand in the X direction to fill available space
        :type expand_x:          (bool)
        :param expand_y:         If True the element will automatically expand in the Y direction to fill available space
        :type expand_y:          (bool)
        :param visible:          set visibility state of the element
        :type visible:           (bool)
        :param metadata:         User metadata that can be set to ANYTHING
        :type metadata:          (Any)
        """
        ...
    
    def update_bar(self, current_count, max=...): # -> bool:
        """
        DEPRECATED BUT STILL USABLE - has been combined with the normal ProgressBar.update method.
        Change what the bar shows by changing the current count and optionally the max count

        :param current_count: sets the current value
        :type current_count:  (int)
        :param max:           changes the max value
        :type max:            (int)
        """
        ...
    
    def update(self, current_count=..., max=..., bar_color=..., visible=...): # -> bool:
        """
        Changes some of the settings for the ProgressBar Element. Must call `Window.Read` or `Window.Finalize` prior
        Now has the ability to modify the count so that the update_bar method is not longer needed separately

        Changes will not be visible in your window until you call window.read or window.refresh.

        If you change visibility, your element may MOVE. If you want it to remain stationary, use the "layout helper"
        function "pin" to ensure your element is "pinned" to that location in your layout so that it returns there
        when made visible.

        :param current_count: sets the current value
        :type current_count:  (int)
        :param max:           changes the max value
        :type max:            (int)
        :param bar_color:     The 2 colors that make up a progress bar. Easy to remember which is which if you say "ON" between colors. "red" on "green".
        :type bar_color:      (str, str) or str
        :param visible:       control visibility of element
        :type visible:        (bool)
        :return:              Returns True if update was OK.  False means something wrong with window or it was closed
        :rtype:               (bool)
        """
        ...
    
    Update = ...
    UpdateBar = ...


PBar = ProgressBar
Prog = ProgressBar
Progress = ProgressBar
class Image(Element):
    """
    Image Element - show an image in the window. Should be a GIF or a PNG only
    """
    def __init__(self, source=..., filename=..., data=..., background_color=..., size=..., s=..., pad=..., p=..., key=..., k=..., tooltip=..., subsample=..., right_click_menu=..., expand_x=..., expand_y=..., visible=..., enable_events=..., metadata=...) -> None:
        """
        :param source:           A filename or a base64 bytes. Will automatically detect the type and fill in filename or data for you.
        :type source:            str | bytes | None
        :param filename:         image filename if there is a button image. GIFs and PNGs only.
        :type filename:          str | None
        :param data:             Raw or Base64 representation of the image to put on button. Choose either filename or data
        :type data:              bytes | str | None
        :param background_color: color of background
        :type background_color:
        :param size:             (width, height) size of image in pixels
        :type size:              (int, int)
        :param s:                Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
        :type s:                 (int, int)  | (None, None) | int
        :param pad:              Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
        :type pad:               (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param p:                Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
        :type p:                 (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param key:              Used with window.find_element and with return values to uniquely identify this element to uniquely identify this element
        :type key:               str | int | tuple | object
        :param k:                Same as the Key. You can use either k or key. Which ever is set will be used.
        :type k:                 str | int | tuple | object
        :param tooltip:          text, that will appear when mouse hovers over the element
        :type tooltip:           (str)
        :param subsample:        amount to reduce the size of the image. Divides the size by this number. 2=1/2, 3=1/3, 4=1/4, etc
        :type subsample:         (int)
        :param right_click_menu: A list of lists of Menu items to show when this element is right clicked. See user docs for exact format.
        :type right_click_menu:  List[List[ List[str] | str ]]
        :param expand_x:         If True the element will automatically expand in the X direction to fill available space
        :type expand_x:          (bool)
        :param expand_y:         If True the element will automatically expand in the Y direction to fill available space
        :type expand_y:          (bool)
        :param visible:          set visibility state of the element
        :type visible:           (bool)
        :param enable_events:    Turns on the element specific events. For an Image element, the event is "image clicked"
        :type enable_events:     (bool)
        :param metadata:         User metadata that can be set to ANYTHING
        :type metadata:          (Any)
        """
        ...
    
    def update(self, source=..., filename=..., data=..., size=..., subsample=..., visible=...):
        """
        Changes some of the settings for the Image Element. Must call `Window.Read` or `Window.Finalize` prior.
        To clear an image that's been displayed, call with NONE of the options set.  A blank update call will
        delete the previously shown image.

        Changes will not be visible in your window until you call window.read or window.refresh.

        If you change visibility, your element may MOVE. If you want it to remain stationary, use the "layout helper"
        function "pin" to ensure your element is "pinned" to that location in your layout so that it returns there
        when made visible.

        :param source:   A filename or a base64 bytes. Will automatically detect the type and fill in filename or data for you.
        :type source:    str | bytes | None
        :param filename: filename to the new image to display.
        :type filename:  (str)
        :param data:     Base64 encoded string OR a tk.PhotoImage object
        :type data:      str | tkPhotoImage
        :param size:     (width, height) size of image in pixels
        :type size:      Tuple[int,int]
        :param subsample:  amount to reduce the size of the image. Divides the size by this number. 2=1/2, 3=1/3, 4=1/4, etc
        :type subsample:   (int)
        :param visible:  control visibility of element
        :type visible:   (bool)
        """
        ...
    
    def update_animation(self, source, time_between_frames=...): # -> None:
        """
        Show an Animated GIF. Call the function as often as you like. The function will determine when to show the next frame and will automatically advance to the next frame at the right time.
        NOTE - does NOT perform a sleep call to delay
        :param source:              Filename or Base64 encoded string containing Animated GIF
        :type source:               str | bytes | None
        :param time_between_frames: Number of milliseconds to wait between showing frames
        :type time_between_frames:  (int)
        """
        ...
    
    def update_animation_no_buffering(self, source, time_between_frames=...): # -> None:
        """
        Show an Animated GIF. Call the function as often as you like. The function will determine when to show the next frame and will automatically advance to the next frame at the right time.
        NOTE - does NOT perform a sleep call to delay

        :param source:              Filename or Base64 encoded string containing Animated GIF
        :type source:               str | bytes
        :param time_between_frames: Number of milliseconds to wait between showing frames
        :type time_between_frames:  (int)
        """
        ...
    
    Update = ...
    UpdateAnimation = ...


Im = Image
class Canvas(Element):
    def __init__(self, canvas=..., background_color=..., size=..., s=..., pad=..., p=..., key=..., k=..., tooltip=..., right_click_menu=..., expand_x=..., expand_y=..., visible=..., border_width=..., metadata=...) -> None:
        """
        :param canvas:           Your own tk.Canvas if you already created it. Leave blank to create a Canvas
        :type canvas:            (tk.Canvas)
        :param background_color: color of background
        :type background_color:  (str)
        :param size:             (width in char, height in rows) size in pixels to make canvas
        :type size:              (int,int) | (None, None)
        :param s:                Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
        :type s:                 (int, int)  | (None, None) | int
        :param pad:              Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
        :type pad:               (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param p:                Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
        :type p:                 (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param key:              Used with window.find_element and with return values to uniquely identify this element
        :type key:               str | int | tuple | object
        :param k:                Same as the Key. You can use either k or key. Which ever is set will be used.
        :type k:                 str | int | tuple | object
        :param tooltip:          text, that will appear when mouse hovers over the element
        :type tooltip:           (str)
        :param right_click_menu: A list of lists of Menu items to show when this element is right clicked. See user docs for exact format.
        :type right_click_menu:  List[List[ List[str] | str ]]
        :param expand_x:         If True the element will automatically expand in the X direction to fill available space
        :type expand_x:          (bool)
        :param expand_y:         If True the element will automatically expand in the Y direction to fill available space
        :type expand_y:          (bool)
        :param visible:          set visibility state of the element
        :type visible:           (bool)
        :param border_width:     width of border around element in pixels. Not normally used with Canvas element
        :type border_width:      (int)
        :param metadata:         User metadata that can be set to ANYTHING
        :type metadata:          (Any)
        """
        ...
    
    def update(self, background_color=..., visible=...): # -> None:
        """

        :param background_color: color of background
        :type background_color:  (str)
        :param visible:          set visibility state of the element
        :type visible:           (bool)
        """
        ...
    
    @property
    def tk_canvas(self): # -> None:
        """
        Returns the underlying tkiner Canvas widget

        :return: The tkinter canvas widget
        :rtype:  (tk.Canvas)
        """
        ...
    
    TKCanvas = ...


class Graph(Element):
    """
    Creates an area for you to draw on.  The MAGICAL property this Element has is that you interact
    with the element using your own coordinate system.  This is an important point!!  YOU define where the location
    is for (0,0).  Want (0,0) to be in the middle of the graph like a math 4-quadrant graph?  No problem!  Set your
    lower left corner to be (-100,-100) and your upper right to be (100,100) and you've got yourself a graph with
    (0,0) at the center.
    One of THE coolest of the Elements.
    You can also use float values. To do so, be sure and set the float_values parameter.
    Mouse click and drag events are possible and return the (x,y) coordinates of the mouse
    Drawing primitives return an "id" that is referenced when you want to operation on that item (e.g. to erase it)
    """
    def __init__(self, canvas_size, graph_bottom_left, graph_top_right, background_color=..., pad=..., p=..., change_submits=..., drag_submits=..., enable_events=..., motion_events=..., key=..., k=..., tooltip=..., right_click_menu=..., expand_x=..., expand_y=..., visible=..., float_values=..., border_width=..., metadata=...) -> None:
        """
        :param canvas_size:       size of the canvas area in pixels
        :type canvas_size:        (int, int)
        :param graph_bottom_left: (x,y) The bottoms left corner of your coordinate system
        :type graph_bottom_left:  (int, int)
        :param graph_top_right:   (x,y) The top right corner of  your coordinate system
        :type graph_top_right:    (int, int)
        :param background_color:  background color of the drawing area
        :type background_color:   (str)
        :param pad:               Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
        :type pad:                (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param p:                 Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
        :type p:                  (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param change_submits:    * DEPRICATED DO NOT USE. Use `enable_events` instead
        :type change_submits:     (bool)
        :param drag_submits:      if True and Events are enabled for the Graph, will report Events any time the mouse moves while button down.  When the mouse button is released, you'll get an event = graph key + '+UP' (if key is a string.. if not a string, it'll be made into a tuple)
        :type drag_submits:       (bool)
        :param enable_events:     If True then clicks on the Graph are immediately reported as an event. Use this instead of change_submits
        :type enable_events:      (bool)
        :param motion_events:     If True then if no button is down and the mouse is moved, an event is generated with key = graph key + '+MOVE' (if key is a string, it not a string then a tuple is returned)
        :type motion_events:      (bool)
        :param key:               Value that uniquely identifies this element from all other elements. Used when Finding an element or in return values. Must be unique to the window
        :type key:                str | int | tuple | object
        :param k:                 Same as the Key. You can use either k or key. Which ever is set will be used.
        :type k:                  str | int | tuple | object
        :param tooltip:           text, that will appear when mouse hovers over the element
        :type tooltip:            (str)
        :param right_click_menu:  A list of lists of Menu items to show when this element is right clicked. See user docs for exact format.
        :type right_click_menu:   List[List[ List[str] | str ]]
        :param expand_x:          If True the element will automatically expand in the X direction to fill available space
        :type expand_x:           (bool)
        :param expand_y:          If True the element will automatically expand in the Y direction to fill available space
        :type expand_y:           (bool)
        :param visible:           set visibility state of the element (Default = True)
        :type visible:            (bool)
        :param float_values:      If True x,y coordinates are returned as floats, not ints
        :type float_values:       (bool)
        :param border_width:      width of border around element in pixels. Not normally used for Graph Elements
        :type border_width:       (int)
        :param metadata:          User metadata that can be set to ANYTHING
        :type metadata:           (Any)
        """
        ...
    
    def draw_line(self, point_from, point_to, color=..., width=...): # -> _CanvasItemId | None:
        """
        Draws a line from one point to another point using USER'S coordinates. Can set the color and width of line
        :param point_from: Starting point for line
        :type point_from:  (int, int) | Tuple[float, float]
        :param point_to:   Ending point for line
        :type point_to:    (int, int) | Tuple[float, float]
        :param color:      Color of the line
        :type color:       (str)
        :param width:      width of line in pixels
        :type width:       (int)
        :return:           id returned from tktiner or None if user closed the window. id is used when you
        :rtype:            int | None
        """
        ...
    
    def draw_lines(self, points, color=..., width=...): # -> None:
        """
        Draw a series of lines given list of points

        :param points: list of points that define the polygon
        :type points:  List[(int, int) | Tuple[float, float]]
        :param color:  Color of the line
        :type color:   (str)
        :param width:  width of line in pixels
        :type width:   (int)
        :return:       id returned from tktiner or None if user closed the window. id is used when you
        :rtype:        int | None
        """
        ...
    
    def draw_point(self, point, size=..., color=...): # -> _CanvasItemId | None:
        """
        Draws a "dot" at the point you specify using the USER'S coordinate system
        :param point: Center location using USER'S coordinate system
        :type point:  (int, int) | Tuple[float, float]
        :param size:  Radius? (Or is it the diameter?) in user's coordinate values.
        :type size:   int | float
        :param color: color of the point to draw
        :type color:  (str)
        :return:      id returned from tkinter that you'll need if you want to manipulate the point
        :rtype:       int | None
        """
        ...
    
    def draw_circle(self, center_location, radius, fill_color=..., line_color=..., line_width=...): # -> _CanvasItemId | None:
        """
        Draws a circle, cenetered at the location provided.  Can set the fill and outline colors
        :param center_location: Center location using USER'S coordinate system
        :type center_location:  (int, int) | Tuple[float, float]
        :param radius:          Radius in user's coordinate values.
        :type radius:           int | float
        :param fill_color:      color of the point to draw
        :type fill_color:       (str)
        :param line_color:      color of the outer line that goes around the circle (sorry, can't set thickness)
        :type line_color:       (str)
        :param line_width:      width of the line around the circle, the outline, in pixels
        :type line_width:       (int)
        :return:                id returned from tkinter that you'll need if you want to manipulate the circle
        :rtype:                 int | None
        """
        ...
    
    def draw_oval(self, top_left, bottom_right, fill_color=..., line_color=..., line_width=...): # -> _CanvasItemId | None:
        """
        Draws an oval based on coordinates in user coordinate system. Provide the location of a "bounding rectangle"
        :param top_left:     the top left point of bounding rectangle
        :type top_left:      (int, int) | Tuple[float, float]
        :param bottom_right: the bottom right point of bounding rectangle
        :type bottom_right:  (int, int) | Tuple[float, float]
        :param fill_color:   color of the interrior
        :type fill_color:    (str)
        :param line_color:   color of outline of oval
        :type line_color:    (str)
        :param line_width:   width of the line around the oval, the outline, in pixels
        :type line_width:    (int)
        :return:             id returned from tkinter that you'll need if you want to manipulate the oval
        :rtype:              int | None
        """
        ...
    
    def draw_arc(self, top_left, bottom_right, extent, start_angle, style=..., arc_color=..., line_width=..., fill_color=...): # -> _CanvasItemId | None:
        """
        Draws different types of arcs.  Uses a "bounding box" to define location
        :param top_left:     the top left point of bounding rectangle
        :type top_left:      (int, int) | Tuple[float, float]
        :param bottom_right: the bottom right point of bounding rectangle
        :type bottom_right:  (int, int) | Tuple[float, float]
        :param extent:       Andle to end drawing. Used in conjunction with start_angle
        :type extent:        (float)
        :param start_angle:  Angle to begin drawing. Used in conjunction with extent
        :type start_angle:   (float)
        :param style:        Valid choices are One of these Style strings- 'pieslice', 'chord', 'arc', 'first', 'last', 'butt', 'projecting', 'round', 'bevel', 'miter'
        :type style:         (str)
        :param arc_color:    color to draw arc with
        :type arc_color:     (str)
        :param fill_color:   color to fill the area
        :type fill_color:    (str)
        :return:             id returned from tkinter that you'll need if you want to manipulate the arc
        :rtype:              int | None
        """
        ...
    
    def draw_rectangle(self, top_left, bottom_right, fill_color=..., line_color=..., line_width=...): # -> _CanvasItemId | None:
        """
        Draw a rectangle given 2 points. Can control the line and fill colors

        :param top_left:     the top left point of rectangle
        :type top_left:      (int, int) | Tuple[float, float]
        :param bottom_right: the bottom right point of rectangle
        :type bottom_right:  (int, int) | Tuple[float, float]
        :param fill_color:   color of the interior
        :type fill_color:    (str)
        :param line_color:   color of outline
        :type line_color:    (str)
        :param line_width:   width of the line in pixels
        :type line_width:    (int)
        :return:             int | None id returned from tkinter that you'll need if you want to manipulate the rectangle
        :rtype:              int | None
        """
        ...
    
    def draw_polygon(self, points, fill_color=..., line_color=..., line_width=...): # -> _CanvasItemId | None:
        """
        Draw a polygon given list of points

        :param points:     list of points that define the polygon
        :type points:      List[(int, int) | Tuple[float, float]]
        :param fill_color: color of the interior
        :type fill_color:  (str)
        :param line_color: color of outline
        :type line_color:  (str)
        :param line_width: width of the line in pixels
        :type line_width:  (int)
        :return:           id returned from tkinter that you'll need if you want to manipulate the rectangle
        :rtype:            int | None
        """
        ...
    
    def draw_text(self, text, location, color=..., font=..., angle=..., text_location=...): # -> None:
        """
        Draw some text on your graph.  This is how you label graph number lines for example

        :param text:          text to display
        :type text:           (Any)
        :param location:      location to place first letter
        :type location:       (int, int) | Tuple[float, float]
        :param color:         text color
        :type color:          (str)
        :param font:          specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
        :type font:           (str or (str, int[, str]) or None)
        :param angle:         Angle 0 to 360 to draw the text.  Zero represents horizontal text
        :type angle:          (float)
        :param text_location: "anchor" location for the text. Values start with TEXT_LOCATION_
        :type text_location:  (enum)
        :return:              id returned from tkinter that you'll need if you want to manipulate the text
        :rtype:               int | None
        """
        ...
    
    def draw_image(self, filename=..., data=..., location=...): # -> _CanvasItemId | None:
        """
        Places an image onto your canvas.  It's a really important method for this element as it enables so much

        :param filename: if image is in a file, path and filename for the image. (GIF and PNG only!)
        :type filename:  (str)
        :param data:     if image is in Base64 format or raw? format then use instead of filename
        :type data:      str | bytes
        :param location: the (x,y) location to place image's top left corner
        :type location:  (int, int) | Tuple[float, float]
        :return:         id returned from tkinter that you'll need if you want to manipulate the image
        :rtype:          int | None
        """
        ...
    
    def erase(self): # -> None:
        """
        Erase the Graph - Removes all figures previously "drawn" using the Graph methods (e.g. DrawText)
        """
        ...
    
    def delete_figure(self, id): # -> None:
        """
        Remove from the Graph the figure represented by id. The id is given to you anytime you call a drawing primitive

        :param id: the id returned to you when calling one of the drawing methods
        :type id:  (int)
        """
        ...
    
    def update(self, background_color=..., visible=...): # -> None:
        """
        Changes some of the settings for the Graph Element. Must call `Window.Read` or `Window.Finalize` prior

        Changes will not be visible in your window until you call window.read or window.refresh.

        If you change visibility, your element may MOVE. If you want it to remain stationary, use the "layout helper"
        function "pin" to ensure your element is "pinned" to that location in your layout so that it returns there
        when made visible.

        :param background_color: color of background
        :type background_color:  ???
        :param visible:          control visibility of element
        :type visible:           (bool)
        """
        ...
    
    def move(self, x_direction, y_direction): # -> None:
        """
        Moves the entire drawing area (the canvas) by some delta from the current position.  Units are indicated in your coordinate system indicated number of ticks in your coordinate system

        :param x_direction: how far to move in the "X" direction in your coordinates
        :type x_direction:  int | float
        :param y_direction: how far to move in the "Y" direction in your coordinates
        :type y_direction:  int | float
        """
        ...
    
    def move_figure(self, figure, x_direction, y_direction): # -> None:
        """
        Moves a previously drawn figure using a "delta" from current position

        :param figure:      Previously obtained figure-id. These are returned from all Draw methods
        :type figure:       (id)
        :param x_direction: delta to apply to position in the X direction
        :type x_direction:  int | float
        :param y_direction: delta to apply to position in the Y direction
        :type y_direction:  int | float
        """
        ...
    
    def relocate_figure(self, figure, x, y): # -> None:
        """
        Move a previously made figure to an arbitrary (x,y) location. This differs from the Move methods because it
        uses absolute coordinates versus relative for Move

        :param figure: Previously obtained figure-id. These are returned from all Draw methods
        :type figure:  (id)
        :param x:      location on X axis (in user coords) to move the upper left corner of the figure
        :type x:       int | float
        :param y:      location on Y axis (in user coords) to move the upper left corner of the figure
        :type y:       int | float
        """
        ...
    
    def send_figure_to_back(self, figure): # -> None:
        """
        Changes Z-order of figures on the Graph.  Sends the indicated figure to the back of all other drawn figures

        :param figure: value returned by tkinter when creating the figure / drawing
        :type figure:  (int)
        """
        ...
    
    def bring_figure_to_front(self, figure): # -> None:
        """
        Changes Z-order of figures on the Graph.  Brings the indicated figure to the front of all other drawn figures

        :param figure: value returned by tkinter when creating the figure / drawing
        :type figure:  (int)
        """
        ...
    
    def get_figures_at_location(self, location): # -> tuple[_CanvasItemId, ...]:
        """
        Returns a list of figures located at a particular x,y location within the Graph

        :param location: point to check
        :type location:  (int, int) | Tuple[float, float]
        :return:         a list of previously drawn "Figures" (returned from the drawing primitives)
        :rtype:          List[int]
        """
        ...
    
    def get_bounding_box(self, figure): # -> tuple[tuple[None, None] | tuple[Unknown, Unknown] | tuple[int, int], tuple[None, None] | tuple[Unknown, Unknown] | tuple[int, int]]:
        """
        Given a figure, returns the upper left and lower right bounding box coordinates

        :param figure: a previously drawing figure
        :type figure:  object
        :return:       upper left x, upper left y, lower right x, lower right y
        :rtype:        Tuple[int, int, int, int] | Tuple[float, float, float, float]
        """
        ...
    
    def change_coordinates(self, graph_bottom_left, graph_top_right): # -> None:
        """
        Changes the corrdinate system to a new one.  The same 2 points in space are used to define the coorinate
        system - the bottom left and the top right values of your graph.

        :param graph_bottom_left: The bottoms left corner of your coordinate system
        :type graph_bottom_left:  (int, int) (x,y)
        :param graph_top_right:   The top right corner of  your coordinate system
        :type graph_top_right:    (int, int)  (x,y)
        """
        ...
    
    @property
    def tk_canvas(self): # -> Canvas:
        """
        Returns the underlying tkiner Canvas widget

        :return: The tkinter canvas widget
        :rtype:  (tk.Canvas)
        """
        ...
    
    def button_release_call_back(self, event): # -> None:
        """
        Not a user callable method.  Used to get Graph click events. Called by tkinter when button is released

        :param event: (event) event info from tkinter. Note not used in this method
        :type event:
        """
        ...
    
    def button_press_call_back(self, event): # -> None:
        """
        Not a user callable method.  Used to get Graph click events. Called by tkinter when button is released

        :param event: (event) event info from tkinter. Contains the x and y coordinates of a click
        :type event:
        """
        ...
    
    def motion_call_back(self, event): # -> None:
        """
        Not a user callable method.  Used to get Graph mouse motion events. Called by tkinter when mouse moved

        :param event: (event) event info from tkinter. Contains the x and y coordinates of a mouse
        :type event:
        """
        ...
    
    BringFigureToFront = ...
    ButtonPressCallBack = ...
    ButtonReleaseCallBack = ...
    DeleteFigure = ...
    DrawArc = ...
    DrawCircle = ...
    DrawImage = ...
    DrawLine = ...
    DrawOval = ...
    DrawPoint = ...
    DrawPolygon = ...
    DrawLines = ...
    DrawRectangle = ...
    DrawText = ...
    GetFiguresAtLocation = ...
    GetBoundingBox = ...
    Erase = ...
    MotionCallBack = ...
    Move = ...
    MoveFigure = ...
    RelocateFigure = ...
    SendFigureToBack = ...
    TKCanvas = ...
    Update = ...


G = Graph
class Frame(Element):
    """
    A Frame Element that contains other Elements. Encloses with a line around elements and a text label.
    """
    def __init__(self, title, layout, title_color=..., background_color=..., title_location=..., relief=..., size=..., s=..., font=..., pad=..., p=..., border_width=..., key=..., k=..., tooltip=..., right_click_menu=..., expand_x=..., expand_y=..., grab=..., visible=..., element_justification=..., vertical_alignment=..., metadata=...) -> None:
        """
        :param title:                 text that is displayed as the Frame's "label" or title
        :type title:                  (str)
        :param layout:                The layout to put inside the Frame
        :type layout:                 List[List[Elements]]
        :param title_color:           color of the title text
        :type title_color:            (str)
        :param background_color:      background color of the Frame
        :type background_color:       (str)
        :param title_location:        location to place the text title.  Choices include: TITLE_LOCATION_TOP TITLE_LOCATION_BOTTOM TITLE_LOCATION_LEFT TITLE_LOCATION_RIGHT TITLE_LOCATION_TOP_LEFT TITLE_LOCATION_TOP_RIGHT TITLE_LOCATION_BOTTOM_LEFT TITLE_LOCATION_BOTTOM_RIGHT
        :type title_location:         (enum)
        :param relief:                relief style. Values are same as other elements with reliefs. Choices include RELIEF_RAISED RELIEF_SUNKEN RELIEF_FLAT RELIEF_RIDGE RELIEF_GROOVE RELIEF_SOLID
        :type relief:                 (enum)
        :param size:                  (width, height) Sets an initial hard-coded size for the Frame. This used to be a problem, but was fixed in 4.53.0 and works better than Columns when using the size paramter
        :type size:                   (int, int)
        :param s:                     Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
        :type s:                      (int, int)  | (None, None) | int
        :param font:                  specifies the  font family, size, etc. for the TITLE. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
        :type font:                   (str or (str, int[, str]) or None)
        :param pad:                   Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
        :type pad:                    (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param p:                     Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
        :type p:                      (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param border_width:          width of border around element in pixels
        :type border_width:           (int)
        :param key:                   Value that uniquely identifies this element from all other elements. Used when Finding an element or in return values. Must be unique to the window
        :type key:                    str | int | tuple | object
        :param k:                     Same as the Key. You can use either k or key. Which ever is set will be used.
        :type k:                      str | int | tuple | object
        :param tooltip:               text, that will appear when mouse hovers over the element
        :type tooltip:                (str)
        :param right_click_menu:      A list of lists of Menu items to show when this element is right clicked. See user docs for exact format.
        :type right_click_menu:       List[List[ List[str] | str ]]
        :param expand_x:              If True the element will automatically expand in the X direction to fill available space
        :type expand_x:               (bool)
        :param expand_y:              If True the element will automatically expand in the Y direction to fill available space
        :type expand_y:               (bool)
        :param grab:                  If True can grab this element and move the window around. Default is False
        :type grab:                   (bool)
        :param visible:               set visibility state of the element
        :type visible:                (bool)
        :param element_justification: All elements inside the Frame will have this justification 'left', 'right', 'center' are valid values
        :type element_justification:  (str)
        :param vertical_alignment:    Place the Frame at the 'top', 'center', 'bottom' of the row (can also use t,c,r). Defaults to no setting (tkinter decides)
        :type vertical_alignment:     (str)
        :param metadata:              User metadata that can be set to ANYTHING
        :type metadata:               (Any)
        """
        ...
    
    def add_row(self, *args): # -> None:
        """
        Not recommended user call.  Used to add rows of Elements to the Frame Element.

        :param *args: The list of elements for this row
        :type *args:  List[Element]
        """
        ...
    
    def layout(self, rows): # -> Self@Frame:
        """
        Can use like the Window.Layout method, but it's better to use the layout parameter when creating

        :param rows: The rows of Elements
        :type rows:  List[List[Element]]
        :return:     Used for chaining
        :rtype:      (Frame)
        """
        ...
    
    def update(self, value=..., visible=...): # -> None:
        """
        Changes some of the settings for the Frame Element. Must call `Window.Read` or `Window.Finalize` prior

        Changes will not be visible in your window until you call window.read or window.refresh.

        If you change visibility, your element may MOVE. If you want it to remain stationary, use the "layout helper"
        function "pin" to ensure your element is "pinned" to that location in your layout so that it returns there
        when made visible.

        :param value:   New text value to show on frame
        :type value:    (Any)
        :param visible: control visibility of element
        :type visible:  (bool)
        """
        ...
    
    AddRow = ...
    Layout = ...
    Update = ...


Fr = Frame
class VerticalSeparator(Element):
    """
    Vertical Separator Element draws a vertical line at the given location. It will span 1 "row". Usually paired with
    Column Element if extra height is needed
    """
    def __init__(self, color=..., pad=..., p=..., key=..., k=...) -> None:
        """
        :param color: Color of the line. Defaults to theme's text color. Can be name or #RRGGBB format
        :type color:  (str)
        :param pad:   Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
        :type pad:    (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param p:     Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
        :type p:      (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param key:   Value that uniquely identifies this element from all other elements. Used when Finding an element or in return values. Must be unique to the window
        :type key:    str | int | tuple | object
        :param k:     Same as the Key. You can use either k or key. Which ever is set will be used.
        :type k:      str | int | tuple | object
        """
        ...
    


VSeperator = VerticalSeparator
VSeparator = VerticalSeparator
VSep = VerticalSeparator
class HorizontalSeparator(Element):
    """
    Horizontal Separator Element draws a Horizontal line at the given location.
    """
    def __init__(self, color=..., pad=..., p=..., key=..., k=...) -> None:
        """
        :param color: Color of the line. Defaults to theme's text color. Can be name or #RRGGBB format
        :type color:  (str)
        :param pad:   Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
        :type pad:    (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param p:     Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
        :type p:      (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param key:   Value that uniquely identifies this element from all other elements. Used when Finding an element or in return values. Must be unique to the window
        :type key:    str | int | tuple | object
        :param k:     Same as the Key. You can use either k or key. Which ever is set will be used.
        :type k:      str | int | tuple | object
        """
        ...
    


HSeparator = HorizontalSeparator
HSep = HorizontalSeparator
class Sizegrip(Element):
    """
        Sizegrip element will be added to the bottom right corner of your window.
        It should be placed on the last row of your window along with any other elements on that row.
        The color will match the theme's background color.
    """
    def __init__(self, background_color=..., pad=..., p=..., key=..., k=...) -> None:
        """
        Sizegrip Element
        :param background_color: color to use for the background of the grip
        :type background_color:  str
        :param pad:   Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
        :type pad:    (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param p:     Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
        :type p:      (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param key:   Value that uniquely identifies this element from all other elements. Used when Finding an element or in return values. Must be unique to the window
        :type key:    str | int | tuple | object
        :param k:     Same as the Key. You can use either k or key. Which ever is set will be used.
        :type k:      str | int | tuple | object
        """
        ...
    


SGrip = Sizegrip
class Tab(Element):
    """
    Tab Element is another "Container" element that holds a layout and displays a tab with text. Used with TabGroup only
    Tabs are never placed directly into a layout.  They are always "Contained" in a TabGroup layout
    """
    def __init__(self, title, layout, title_color=..., background_color=..., font=..., pad=..., p=..., disabled=..., border_width=..., key=..., k=..., tooltip=..., right_click_menu=..., expand_x=..., expand_y=..., visible=..., element_justification=..., image_source=..., image_subsample=..., metadata=...) -> None:
        """
        :param title:                 text to show on the tab
        :type title:                  (str)
        :param layout:                The element layout that will be shown in the tab
        :type layout:                 List[List[Element]]
        :param title_color:           color of the tab text (note not currently working on tkinter)
        :type title_color:            (str)
        :param background_color:      color of background of the entire layout
        :type background_color:       (str)
        :param font:                  NOT USED in the tkinter port
        :type font:                   (str or (str, int[, str]) or None)
        :param pad:                   Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
        :type pad:                    (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param p:                     Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
        :type p:                      (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param disabled:              If True button will be created disabled
        :type disabled:               (bool)
        :param border_width:          NOT USED in tkinter port
        :type border_width:           (int)
        :param key:                   Value that uniquely identifies this element from all other elements. Used when Finding an element or in return values. Must be unique to the window
        :type key:                    str | int | tuple | object
        :param k:                     Same as the Key. You can use either k or key. Which ever is set will be used.
        :type k:                      str | int | tuple | object
        :param tooltip:               text, that will appear when mouse hovers over the element
        :type tooltip:                (str)
        :param right_click_menu:      A list of lists of Menu items to show when this element is right clicked. See user docs for exact format.
        :type right_click_menu:       List[List[ List[str] | str ]]
        :param expand_x:              If True the element will automatically expand in the X direction to fill available space
        :type expand_x:               (bool)
        :param expand_y:              If True the element will automatically expand in the Y direction to fill available space
        :type expand_y:               (bool)
        :param visible:               set visibility state of the element
        :type visible:                (bool)
        :param element_justification: All elements inside the Tab will have this justification 'left', 'right', 'center' are valid values
        :type element_justification:  (str)
        :param image_source:          A filename or a base64 bytes of an image to place on the Tab
        :type image_source:            str | bytes | None
        :param image_subsample:       amount to reduce the size of the image. Divides the size by this number. 2=1/2, 3=1/3, 4=1/4, etc
        :type image_subsample:        (int)
        :param metadata:              User metadata that can be set to ANYTHING
        :type metadata:               (Any)
        """
        ...
    
    def add_row(self, *args): # -> None:
        """
        Not recommended use call.  Used to add rows of Elements to the Frame Element.

        :param *args: The list of elements for this row
        :type *args:  List[Element]
        """
        ...
    
    def layout(self, rows): # -> Self@Tab:
        """
        Not user callable.  Use layout parameter instead. Creates the layout using the supplied rows of Elements

        :param rows: List[List[Element]] The list of rows
        :type rows:  List[List[Element]]
        :return:     (Tab) used for chaining
        :rtype:
        """
        ...
    
    def update(self, title=..., disabled=..., visible=...): # -> Self@Tab | None:
        """
        Changes some of the settings for the Tab Element. Must call `Window.Read` or `Window.Finalize` prior

        Changes will not be visible in your window until you call window.read or window.refresh.

        If you change visibility, your element may MOVE. If you want it to remain stationary, use the "layout helper"
        function "pin" to ensure your element is "pinned" to that location in your layout so that it returns there
        when made visible.

        :param title:    tab title
        :type title:     (str)
        :param disabled: disable or enable state of the element
        :type disabled:  (bool)
        :param visible:  control visibility of element
        :type visible:   (bool)
        """
        ...
    
    def select(self): # -> None:
        """
        Create a tkinter event that mimics user clicking on a tab. Must have called window.Finalize / Read first!

        """
        ...
    
    AddRow = ...
    Layout = ...
    Select = ...
    Update = ...


class TabGroup(Element):
    """
    TabGroup Element groups together your tabs into the group of tabs you see displayed in your window
    """
    def __init__(self, layout, tab_location=..., title_color=..., tab_background_color=..., selected_title_color=..., selected_background_color=..., background_color=..., focus_color=..., font=..., change_submits=..., enable_events=..., pad=..., p=..., border_width=..., tab_border_width=..., theme=..., key=..., k=..., size=..., s=..., tooltip=..., right_click_menu=..., expand_x=..., expand_y=..., visible=..., metadata=...) -> None:
        """
        :param layout:                    Layout of Tabs. Different than normal layouts. ALL Tabs should be on first row
        :type layout:                     List[List[Tab]]
        :param tab_location:              location that tabs will be displayed. Choices are left, right, top, bottom, lefttop, leftbottom, righttop, rightbottom, bottomleft, bottomright, topleft, topright
        :type tab_location:               (str)
        :param title_color:               color of text on tabs
        :type title_color:                (str)
        :param tab_background_color:      color of all tabs that are not selected
        :type tab_background_color:       (str)
        :param selected_title_color:      color of tab text when it is selected
        :type selected_title_color:       (str)
        :param selected_background_color: color of tab when it is selected
        :type selected_background_color:  (str)
        :param background_color:          color of background area that tabs are located on
        :type background_color:           (str)
        :param focus_color:               color of focus indicator on the tabs
        :type focus_color:                (str)
        :param font:                      specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
        :type font:                       (str or (str, int[, str]) or None)
        :param change_submits:            * DEPRICATED DO NOT USE. Use `enable_events` instead
        :type change_submits:             (bool)
        :param enable_events:             If True then switching tabs will generate an Event
        :type enable_events:              (bool)
        :param pad:                       Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
        :type pad:                        (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param p:                         Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
        :type p:                          (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param border_width:              width of border around element in pixels
        :type border_width:               (int)
        :param tab_border_width:          width of border around the tabs
        :type tab_border_width:           (int)
        :param theme:                     DEPRICATED - You can only specify themes using set options or when window is created. It's not possible to do it on an element basis
        :type theme:                      (enum)
        :param key:                       Value that uniquely identifies this element from all other elements. Used when Finding an element or in return values. Must be unique to the window
        :type key:                        str | int | tuple | object
        :param k:                         Same as the Key. You can use either k or key. Which ever is set will be used.
        :type k:                          str | int | tuple | object
        :param size:                      (width, height) w=pixels-wide, h=pixels-high. Either item in tuple can be None to indicate use the computed value and set only 1 direction
        :type size:                       (int|None, int|None)
        :param s:                         Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
        :type s:                          (int|None, int|None)
        :param tooltip:                   text, that will appear when mouse hovers over the element
        :type tooltip:                    (str)
        :param right_click_menu:          A list of lists of Menu items to show when this element is right clicked. See user docs for exact format.
        :type right_click_menu:           List[List[ List[str] | str ]]
        :param expand_x:                  If True the element will automatically expand in the X direction to fill available space
        :type expand_x:                   (bool)
        :param expand_y:                  If True the element will automatically expand in the Y direction to fill available space
        :type expand_y:                   (bool)
        :param visible:                   set visibility state of the element
        :type visible:                    (bool)
        :param metadata:                  User metadata that can be set to ANYTHING
        :type metadata:                   (Any)
        """
        ...
    
    def add_row(self, *args): # -> None:
        """
        Not recommended user call.  Used to add rows of Elements to the Frame Element.

        :param *args:     The list of elements for this row
        :type *args:      List[Element]
        """
        ...
    
    def layout(self, rows): # -> Self@TabGroup:
        """
        Can use like the Window.Layout method, but it's better to use the layout parameter when creating

        :param rows: The rows of Elements
        :type rows:  List[List[Element]]
        :return:     Used for chaining
        :rtype:      (Frame)
        """
        ...
    
    def find_key_from_tab_name(self, tab_name): # -> None:
        """
        Searches through the layout to find the key that matches the text on the tab. Implies names should be unique

        :param tab_name: name of a tab
        :type tab_name:  str
        :return:         Returns the key or None if no key found
        :rtype:          key | None
        """
        ...
    
    def get(self): # -> None:
        """
        Returns the current value for the Tab Group, which will be the currently selected tab's KEY or the text on
        the tab if no key is defined.  Returns None if an error occurs.
        Note that this is exactly the same data that would be returned from a call to Window.Read. Are you sure you
        are using this method correctly?

        :return: The key of the currently selected tab or the tab's text if it has no key
        :rtype:  Any | None
        """
        ...
    
    def add_tab(self, tab_element):
        """
        Add a new tab to an existing TabGroup
        This call was written so that tabs can be added at runtime as your user performs operations.
        Your Window should already be created and finalized.

        :param tab_element: A Tab Element that has a layout in it
        :type tab_element:  Tab
        """
        ...
    
    AddRow = ...
    FindKeyFromTabName = ...
    Get = ...
    Layout = ...


class Slider(Element):
    """
    A slider, horizontal or vertical
    """
    def __init__(self, range=..., default_value=..., resolution=..., tick_interval=..., orientation=..., disable_number_display=..., border_width=..., relief=..., change_submits=..., enable_events=..., disabled=..., size=..., s=..., font=..., background_color=..., text_color=..., trough_color=..., key=..., k=..., pad=..., p=..., expand_x=..., expand_y=..., tooltip=..., visible=..., metadata=...) -> None:
        """
        :param range:                  slider's range (min value, max value)
        :type range:                   (int, int) | Tuple[float, float]
        :param default_value:          starting value for the slider
        :type default_value:           int | float
        :param resolution:             the smallest amount the slider can be moved
        :type resolution:              int | float
        :param tick_interval:          how often a visible tick should be shown next to slider
        :type tick_interval:           int | float
        :param orientation:            'horizontal' or 'vertical' ('h' or 'v' also work)
        :type orientation:             (str)
        :param disable_number_display: if True no number will be displayed by the Slider Element
        :type disable_number_display:  (bool)
        :param border_width:           width of border around element in pixels
        :type border_width:            (int)
        :param relief:                 relief style. Use constants - RELIEF_RAISED RELIEF_SUNKEN RELIEF_FLAT RELIEF_RIDGE RELIEF_GROOVE RELIEF_SOLID
        :type relief:                  str | None
        :param change_submits:         * DEPRICATED DO NOT USE. Use `enable_events` instead
        :type change_submits:          (bool)
        :param enable_events:          If True then moving the slider will generate an Event
        :type enable_events:           (bool)
        :param disabled:               set disable state for element
        :type disabled:                (bool)
        :param size:                   (l=length chars/rows, w=width pixels)
        :type size:                    (int, int)
        :param s:                      Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
        :type s:                       (int, int)  | (None, None)
        :param font:                   specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
        :type font:                    (str or (str, int[, str]) or None)
        :param background_color:       color of slider's background
        :type background_color:        (str)
        :param text_color:             color of the slider's text
        :type text_color:              (str)
        :param trough_color:           color of the slider's trough
        :type trough_color:            (str)
        :param key:                    Value that uniquely identifies this element from all other elements. Used when Finding an element or in return values. Must be unique to the window
        :type key:                     str | int | tuple | object
        :param k:                      Same as the Key. You can use either k or key. Which ever is set will be used.
        :type k:                       str | int | tuple | object
        :param pad:                    Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
        :type pad:                     (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param p:                      Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
        :type p:                       (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param expand_x:               If True the element will automatically expand in the X direction to fill available space
        :type expand_x:                (bool)
        :param expand_y:               If True the element will automatically expand in the Y direction to fill available space
        :type expand_y:                (bool)
        :param tooltip:                text, that will appear when mouse hovers over the element
        :type tooltip:                 (str)
        :param visible:                set visibility state of the element
        :type visible:                 (bool)
        :param metadata:               User metadata that can be set to ANYTHING
        :type metadata:                (Any)
        """
        ...
    
    def update(self, value=..., range=..., disabled=..., visible=...): # -> None:
        """
        Changes some of the settings for the Slider Element. Must call `Window.Read` or `Window.Finalize` prior

        Changes will not be visible in your window until you call window.read or window.refresh.

        If you change visibility, your element may MOVE. If you want it to remain stationary, use the "layout helper"
        function "pin" to ensure your element is "pinned" to that location in your layout so that it returns there
        when made visible.

        :param value:    sets current slider value
        :type value:     int | float
        :param range:    Sets a new range for slider
        :type range:     (int, int) | Tuple[float, float
        :param disabled: disable or enable state of the element
        :type disabled:  (bool)
        :param visible:  control visibility of element
        :type visible:   (bool)
        """
        ...
    
    Update = ...


Sl = Slider
class TkFixedFrame(tk.Frame):
    """
    A tkinter frame that is used with Column Elements that do not have a scrollbar
    """
    def __init__(self, master, **kwargs) -> None:
        """
        :param master:   The parent widget
        :type master:    (tk.Widget)
        :param **kwargs: The keyword args
        :type **kwargs:
        """
        ...
    


class TkScrollableFrame(tk.Frame):
    """
    A frame with one or two scrollbars.  Used to make Columns with scrollbars
    """
    def __init__(self, master, vertical_only, element, window, **kwargs) -> None:
        """
        :param master:        The parent widget
        :type master:         (tk.Widget)
        :param vertical_only: if True the only a vertical scrollbar will be shown
        :type vertical_only:  (bool)
        :param element:       The element containing this object
        :type element:        (Column)
        """
        ...
    
    def hookMouseWheel(self, e): # -> None:
        ...
    
    def unhookMouseWheel(self, e): # -> None:
        ...
    
    def resize_frame(self, e): # -> None:
        ...
    
    def yscroll(self, event): # -> None:
        ...
    
    def xscroll(self, event): # -> None:
        ...
    
    def bind_mouse_scroll(self, parent, mode): # -> None:
        ...
    
    def set_scrollregion(self, event=...): # -> None:
        """ Set the scroll region on the canvas """
        ...
    


class Column(Element):
    """
    A container element that is used to create a layout within your window's layout
    """
    def __init__(self, layout, background_color=..., size=..., s=..., size_subsample_width=..., size_subsample_height=..., pad=..., p=..., scrollable=..., vertical_scroll_only=..., right_click_menu=..., key=..., k=..., visible=..., justification=..., element_justification=..., vertical_alignment=..., grab=..., expand_x=..., expand_y=..., metadata=..., sbar_trough_color=..., sbar_background_color=..., sbar_arrow_color=..., sbar_width=..., sbar_arrow_width=..., sbar_frame_color=..., sbar_relief=...) -> None:
        """
        :param layout:                      Layout that will be shown in the Column container
        :type layout:                       List[List[Element]]
        :param background_color:            color of background of entire Column
        :type background_color:             (str)
        :param size:                        (width, height) size in pixels (doesn't work quite right, sometimes only 1 dimension is set by tkinter. Use a Sizer Element to help set sizes
        :type size:                         (int | None, int | None)
        :param s:                           Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
        :type s:                            (int | None, int | None)
        :param size_subsample_width:        Determines the size of a scrollable column width based on 1/size_subsample * required size. 1 = match the contents exactly, 2 = 1/2 contents size, 3 = 1/3. Can be a fraction to make larger than required.
        :type size_subsample_width:         (float)
        :param size_subsample_height:       Determines the size of a scrollable height based on 1/size_subsample * required size. 1 = match the contents exactly, 2 = 1/2 contents size, 3 = 1/3. Can be a fraction to make larger than required..
        :type size_subsample_height:        (float)
        :param pad:                         Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
        :type pad:                          (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param p:                           Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
        :type p:                            (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param scrollable:                  if True then scrollbars will be added to the column
        :type scrollable:                   (bool)
        :param vertical_scroll_only:        if Truen then no horizontal scrollbar will be shown
        :type vertical_scroll_only:         (bool)
        :param right_click_menu:            A list of lists of Menu items to show when this element is right clicked. See user docs for exact format.
        :type right_click_menu:             List[List[ List[str] | str ]]
        :param key:                         Value that uniquely identifies this element from all other elements. Used when Finding an element or in return values. Must be unique to the window
        :type key:                          str | int | tuple | object
        :param k:                           Same as the Key. You can use either k or key. Which ever is set will be used.
        :type k:                            str | int | tuple | object
        :param visible:                     set visibility state of the element
        :type visible:                      (bool)
        :param justification:               set justification for the Column itself. Note entire row containing the Column will be affected
        :type justification:                (str)
        :param element_justification:       All elements inside the Column will have this justification 'left', 'right', 'center' are valid values
        :type element_justification:        (str)
        :param vertical_alignment:          Place the column at the 'top', 'center', 'bottom' of the row (can also use t,c,r). Defaults to no setting (tkinter decides)
        :type vertical_alignment:           (str)
        :param grab:                        If True can grab this element and move the window around. Default is False
        :type grab:                         (bool)
        :param expand_x:                    If True the column will automatically expand in the X direction to fill available space
        :type expand_x:                     (bool)
        :param expand_y:                    If True the column will automatically expand in the Y direction to fill available space
        :type expand_y:                     (bool)
        :param metadata:                    User metadata that can be set to ANYTHING
        :type metadata:                     (Any)
        :param sbar_trough_color:           Scrollbar color of the trough
        :type sbar_trough_color:            (str)
        :param sbar_background_color:       Scrollbar color of the background of the arrow buttons at the ends AND the color of the "thumb" (the thing you grab and slide). Switches to arrow color when mouse is over
        :type sbar_background_color:        (str)
        :param sbar_arrow_color:            Scrollbar color of the arrow at the ends of the scrollbar (it looks like a button). Switches to background color when mouse is over
        :type sbar_arrow_color:             (str)
        :param sbar_width:                  Scrollbar width in pixels
        :type sbar_width:                   (int)
        :param sbar_arrow_width:            Scrollbar width of the arrow on the scrollbar. It will potentially impact the overall width of the scrollbar
        :type sbar_arrow_width:             (int)
        :param sbar_frame_color:            Scrollbar Color of frame around scrollbar (available only on some ttk themes)
        :type sbar_frame_color:             (str)
        :param sbar_relief:                 Scrollbar relief that will be used for the "thumb" of the scrollbar (the thing you grab that slides). Should be a constant that is defined at starting with "RELIEF_" - RELIEF_RAISED, RELIEF_SUNKEN, RELIEF_FLAT, RELIEF_RIDGE, RELIEF_GROOVE, RELIEF_SOLID
        :type sbar_relief:                  (str)
        """
        ...
    
    def add_row(self, *args): # -> None:
        """
        Not recommended user call.  Used to add rows of Elements to the Column Element.

        :param *args: The list of elements for this row
        :type *args:  List[Element]
        """
        ...
    
    def layout(self, rows): # -> Self@Column:
        """
        Can use like the Window.Layout method, but it's better to use the layout parameter when creating

        :param rows: The rows of Elements
        :type rows:  List[List[Element]]
        :return:     Used for chaining
        :rtype:      (Column)
        """
        ...
    
    def update(self, visible=...): # -> None:
        """
        Changes some of the settings for the Column Element. Must call `Window.Read` or `Window.Finalize` prior

        Changes will not be visible in your window until you call window.read or window.refresh.

        If you change visibility, your element may MOVE. If you want it to remain stationary, use the "layout helper"
        function "pin" to ensure your element is "pinned" to that location in your layout so that it returns there
        when made visible.

        :param visible: control visibility of element
        :type visible:  (bool)
        """
        ...
    
    def contents_changed(self): # -> None:
        """
        When a scrollable column has part of its layout changed by making elements visible or invisible or the
        layout is extended for the Column, then this method needs to be called so that the new scroll area
        is computed to match the new contents.
        """
        ...
    
    AddRow = ...
    Layout = ...
    Update = ...


Col = Column
class Pane(Element):
    """
    A sliding Pane that is unique to tkinter.  Uses Columns to create individual panes
    """
    def __init__(self, pane_list, background_color=..., size=..., s=..., pad=..., p=..., orientation=..., show_handle=..., relief=..., handle_size=..., border_width=..., key=..., k=..., expand_x=..., expand_y=..., visible=..., metadata=...) -> None:
        """
        :param pane_list:        Must be a list of Column Elements. Each Column supplied becomes one pane that's shown
        :type pane_list:         List[Column] | Tuple[Column]
        :param background_color: color of background
        :type background_color:  (str)
        :param size:             (width, height) w=characters-wide, h=rows-high How much room to reserve for the Pane
        :type size:              (int, int)
        :param s:                Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
        :type s:                 (int, int)  | (None, None)
        :param pad:              Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
        :type pad:               (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param p:                Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
        :type p:                 (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param orientation:      'horizontal' or 'vertical' or ('h' or 'v'). Direction the Pane should slide
        :type orientation:       (str)
        :param show_handle:      if True, the handle is drawn that makes it easier to grab and slide
        :type show_handle:       (bool)
        :param relief:           relief style. Values are same as other elements that use relief values. RELIEF_RAISED RELIEF_SUNKEN RELIEF_FLAT RELIEF_RIDGE RELIEF_GROOVE RELIEF_SOLID
        :type relief:            (enum)
        :param handle_size:      Size of the handle in pixels
        :type handle_size:       (int)
        :param border_width:     width of border around element in pixels
        :type border_width:      (int)
        :param key:              Value that uniquely identifies this element from all other elements. Used when Finding an element or in return values. Must be unique to the window
        :type key:               str | int | tuple | object
        :param k:                Same as the Key. You can use either k or key. Which ever is set will be used.
        :type k:                 str | int | tuple | object
        :param expand_x:         If True the column will automatically expand in the X direction to fill available space
        :type expand_x:          (bool)
        :param expand_y:         If True the column will automatically expand in the Y direction to fill available space
        :type expand_y:          (bool)
        :param visible:          set visibility state of the element
        :type visible:           (bool)
        :param metadata:         User metadata that can be set to ANYTHING
        :type metadata:          (Any)
        """
        ...
    
    def update(self, visible=...): # -> None:
        """
        Changes some of the settings for the Pane Element. Must call `Window.Read` or `Window.Finalize` prior

        Changes will not be visible in your window until you call window.read or window.refresh.

        If you change visibility, your element may MOVE. If you want it to remain stationary, use the "layout helper"
        function "pin" to ensure your element is "pinned" to that location in your layout so that it returns there
        when made visible.

        :param visible: control visibility of element
        :type visible:  (bool)
        """
        ...
    
    Update = ...


class TKCalendar(ttk.Frame):
    """
    This code was shamelessly lifted from moshekaplan's repository - moshekaplan/tkinter_components
    NONE of this code is user callable.  Stay away!
    """
    datetime = ...
    timedelta = ...
    def __init__(self, master=..., target_element=..., close_when_chosen=..., default_date=..., **kw) -> None:
        """WIDGET-SPECIFIC OPTIONS: locale, firstweekday, year, month, selectbackground, selectforeground """
        ...
    
    def __setitem__(self, item, value): # -> None:
        ...
    
    def __getitem__(self, item): # -> Any:
        ...
    
    @property
    def selection(self): # -> None:
        ...
    


class Menu(Element):
    """
    Menu Element is the Element that provides a Menu Bar that goes across the top of the window, just below titlebar.
    Here is an example layout.  The "&" are shortcut keys ALT+key.
    Is a List of -  "Item String" + List
    Where Item String is what will be displayed on the Menubar itself.
    The List that follows the item represents the items that are shown then Menu item is clicked
    Notice how an "entry" in a mennu can be a list which means it branches out and shows another menu, etc. (resursive)
    menu_def = [['&File', ['!&Open', '&Save::savekey', '---', '&Properties', 'E&xit']],
                ['!&Edit', ['!&Paste', ['Special', 'Normal', ], 'Undo'], ],
                ['&Debugger', ['Popout', 'Launch Debugger']],
                ['&Toolbar', ['Command &1', 'Command &2', 'Command &3', 'Command &4']],
                ['&Help', '&About...'], ]
    Finally, "keys" can be added to entries so make them unique.  The "Save" entry has a key associated with it. You
    can see it has a "::" which signifies the beginning of a key.  The user will not see the key portion when the
    menu is shown.  The key portion is returned as part of the event.
    """
    def __init__(self, menu_definition, background_color=..., text_color=..., disabled_text_color=..., size=..., s=..., tearoff=..., font=..., pad=..., p=..., key=..., k=..., visible=..., metadata=...) -> None:
        """
        :param menu_definition:     The Menu definition specified using lists (docs explain the format)
        :type menu_definition:      List[List[Tuple[str, List[str]]]
        :param background_color:    color of the background
        :type background_color:     (str)
        :param text_color:          element's text color. Can be in #RRGGBB format or a color name "black"
        :type text_color:           (str)
        :param disabled_text_color: color to use for text when item is disabled. Can be in #RRGGBB format or a color name "black"
        :type disabled_text_color:  (str)
        :param size:                Not used in the tkinter port
        :type size:                 (int, int)
        :param s:                   Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
        :type s:                    (int, int)  | (None, None)
        :param tearoff:             if True, then can tear the menu off from the window ans use as a floating window. Very cool effect
        :type tearoff:              (bool)
        :param pad:                 Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
        :type pad:                  (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param p:                   Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
        :type p:                    (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param font:                specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
        :type font:                 (str or (str, int[, str]) or None)
        :param key:                 Value that uniquely identifies this element from all other elements. Used when Finding an element or in return values. Must be unique to the window
        :type key:                  str | int | tuple | object
        :param k:                   Same as the Key. You can use either k or key. Which ever is set will be used.
        :type k:                    str | int | tuple | object
        :param visible:             set visibility state of the element
        :type visible:              (bool)
        :param metadata:            User metadata that can be set to ANYTHING
        :type metadata:             (Any)
        """
        ...
    
    def update(self, menu_definition=..., visible=...): # -> None:
        """
        Update a menubar - can change the menu definition and visibility.  The entire menu has to be specified

        Changes will not be visible in your window until you call window.read or window.refresh.

        If you change visibility, your element may MOVE. If you want it to remain stationary, use the "layout helper"
        function "pin" to ensure your element is "pinned" to that location in your layout so that it returns there
        when made visible.

        :param menu_definition: The menu definition list
        :type menu_definition:  List[List[Tuple[str, List[str]]]
        :param visible:         control visibility of element
        :type visible:          (bool)
        """
        ...
    
    Update = ...


MenuBar = Menu
Menubar = Menu
class Table(Element):
    def __init__(self, values, headings=..., visible_column_map=..., col_widths=..., def_col_width=..., auto_size_columns=..., max_col_width=..., select_mode=..., display_row_numbers=..., num_rows=..., row_height=..., font=..., justification=..., text_color=..., background_color=..., alternating_row_color=..., selected_row_colors=..., header_text_color=..., header_background_color=..., header_font=..., header_border_width=..., header_relief=..., row_colors=..., vertical_scroll_only=..., hide_vertical_scroll=..., border_width=..., sbar_trough_color=..., sbar_background_color=..., sbar_arrow_color=..., sbar_width=..., sbar_arrow_width=..., sbar_frame_color=..., sbar_relief=..., size=..., s=..., change_submits=..., enable_events=..., enable_click_events=..., right_click_selects=..., bind_return_key=..., pad=..., p=..., key=..., k=..., tooltip=..., right_click_menu=..., expand_x=..., expand_y=..., visible=..., metadata=...) -> None:
        """
        :param values:                  Your table data represented as a 2-dimensions table... a list of rows, with each row representing a row in your table.
        :type values:                   List[List[str | int | float]]
        :param headings:                The headings to show on the top line
        :type headings:                 List[str]
        :param visible_column_map:      One entry for each column. False indicates the column is not shown
        :type visible_column_map:       List[bool]
        :param col_widths:              Number of characters that each column will occupy
        :type col_widths:               List[int]
        :param def_col_width:           Default column width in characters
        :type def_col_width:            (int)
        :param auto_size_columns:       if True columns will be sized automatically
        :type auto_size_columns:        (bool)
        :param max_col_width:           Maximum width for all columns in characters
        :type max_col_width:            (int)
        :param select_mode:             Select Mode. Valid values start with "TABLE_SELECT_MODE_".  Valid values are: TABLE_SELECT_MODE_NONE TABLE_SELECT_MODE_BROWSE TABLE_SELECT_MODE_EXTENDED
        :type select_mode:              (enum)
        :param display_row_numbers:     if True, the first column of the table will be the row #
        :type display_row_numbers:      (bool)
        :param num_rows:                The number of rows of the table to display at a time
        :type num_rows:                 (int)
        :param row_height:              height of a single row in pixels
        :type row_height:               (int)
        :param font:                    specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
        :type font:                     (str or (str, int[, str]) or None)
        :param justification:           'left', 'right', 'center' are valid choices
        :type justification:            (str)
        :param text_color:              color of the text
        :type text_color:               (str)
        :param background_color:        color of background
        :type background_color:         (str)
        :param alternating_row_color:   if set then every other row will have this color in the background.
        :type alternating_row_color:    (str)
        :param selected_row_colors:     Sets the text color and background color for a selected row. Same format as button colors - tuple ('red', 'yellow') or string 'red on yellow'. Defaults to theme's button color
        :type selected_row_colors:      str or (str, str)
        :param header_text_color:       sets the text color for the header
        :type header_text_color:        (str)
        :param header_background_color: sets the background color for the header
        :type header_background_color:  (str)
        :param header_font:             specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
        :type header_font:              (str or (str, int[, str]) or None)
        :param header_border_width:     Border width for the header portion
        :type header_border_width:      (int | None)
        :param header_relief:           Relief style for the header. Values are same as other elements that use relief. RELIEF_RAISED RELIEF_SUNKEN RELIEF_FLAT RELIEF_RIDGE RELIEF_GROOVE RELIEF_SOLID
        :type header_relief:            (str | None)
        :param row_colors:              list of tuples of (row, background color) OR (row, foreground color, background color). Sets the colors of listed rows to the color(s) provided (note the optional foreground color)
        :type row_colors:               List[Tuple[int, str] | Tuple[Int, str, str]]
        :param vertical_scroll_only:    if True only the vertical scrollbar will be visible
        :type vertical_scroll_only:     (bool)
        :param hide_vertical_scroll:    if True vertical scrollbar will be hidden
        :type hide_vertical_scroll:     (bool)
        :param border_width:            Border width/depth in pixels
        :type border_width:             (int)
        :param sbar_trough_color:           Scrollbar color of the trough
        :type sbar_trough_color:            (str)
        :param sbar_background_color:       Scrollbar color of the background of the arrow buttons at the ends AND the color of the "thumb" (the thing you grab and slide). Switches to arrow color when mouse is over
        :type sbar_background_color:        (str)
        :param sbar_arrow_color:            Scrollbar color of the arrow at the ends of the scrollbar (it looks like a button). Switches to background color when mouse is over
        :type sbar_arrow_color:             (str)
        :param sbar_width:                  Scrollbar width in pixels
        :type sbar_width:                   (int)
        :param sbar_arrow_width:            Scrollbar width of the arrow on the scrollbar. It will potentially impact the overall width of the scrollbar
        :type sbar_arrow_width:             (int)
        :param sbar_frame_color:            Scrollbar Color of frame around scrollbar (available only on some ttk themes)
        :type sbar_frame_color:             (str)
        :param sbar_relief:                 Scrollbar relief that will be used for the "thumb" of the scrollbar (the thing you grab that slides). Should be a constant that is defined at starting with "RELIEF_" - RELIEF_RAISED, RELIEF_SUNKEN, RELIEF_FLAT, RELIEF_RIDGE, RELIEF_GROOVE, RELIEF_SOLID
        :type sbar_relief:                  (str)
        :param size:                    DO NOT USE! Use num_rows instead
        :type size:                     (int, int)
        :param change_submits:          DO NOT USE. Only listed for backwards compat - Use enable_events instead
        :type change_submits:           (bool)
        :param enable_events:           Turns on the element specific events. Table events happen when row is clicked
        :type enable_events:            (bool)
        :param enable_click_events:     Turns on the element click events that will give you (row, col) click data when the table is clicked
        :type enable_click_events:      (bool)
        :param right_click_selects:     If True, then right clicking a row will select that row if multiple rows are not currently selected
        :type right_click_selects:      (bool)
        :param bind_return_key:         if True, pressing return key will cause event coming from Table, ALSO a left button double click will generate an event if this parameter is True
        :type bind_return_key:          (bool)
        :param pad:                     Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
        :type pad:                      (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param p:                       Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
        :type p:                        (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param key:                     Used with window.find_element and with return values to uniquely identify this element to uniquely identify this element
        :type key:                      str | int | tuple | object
        :param k:                       Same as the Key. You can use either k or key. Which ever is set will be used.
        :type k:                        str | int | tuple | object
        :param tooltip:                 text, that will appear when mouse hovers over the element
        :type tooltip:                  (str)
        :param right_click_menu:        A list of lists of Menu items to show when this element is right clicked. See user docs for exact format.
        :type right_click_menu:         List[List[ List[str] | str ]]
        :param expand_x:                If True the element will automatically expand in the X direction to fill available space
        :type expand_x:                 (bool)
        :param expand_y:                If True the element will automatically expand in the Y direction to fill available space
        :type expand_y:                 (bool)
        :param visible:                 set visibility state of the element
        :type visible:                  (bool)
        :param metadata:                User metadata that can be set to ANYTHING
        :type metadata:                 (Any)
        """
        ...
    
    def update(self, values=..., num_rows=..., visible=..., select_rows=..., alternating_row_color=..., row_colors=...): # -> None:
        """
        Changes some of the settings for the Table Element. Must call `Window.Read` or `Window.Finalize` prior

        Changes will not be visible in your window until you call window.read or window.refresh.

        If you change visibility, your element may MOVE. If you want it to remain stationary, use the "layout helper"
        function "pin" to ensure your element is "pinned" to that location in your layout so that it returns there
        when made visible.

        :param values:                A new 2-dimensional table to show
        :type values:                 List[List[str | int | float]]
        :param num_rows:              How many rows to display at a time
        :type num_rows:               (int)
        :param visible:               if True then will be visible
        :type visible:                (bool)
        :param select_rows:           List of rows to select as if user did
        :type select_rows:            List[int]
        :param alternating_row_color: the color to make every other row
        :type alternating_row_color:  (str)
        :param row_colors:            list of tuples of (row, background color) OR (row, foreground color, background color). Changes the colors of listed rows to the color(s) provided (note the optional foreground color)
        :type row_colors:             List[Tuple[int, str] | Tuple[Int, str, str]]
        """
        ...
    
    def get(self): # -> Unknown:
        """
        Dummy function for tkinter port.  In the Qt port you can read back the values in the table in case they were
        edited.  Don't know yet how to enable editing of a Tree in tkinter so just returning the values provided by
        user when Table was created or Updated.

        :return: the current table values (for now what was originally provided up updated)
        :rtype:  List[List[Any]]
        """
        ...
    
    def get_last_clicked_position(self): # -> tuple[None, None] | tuple[int | None, int | None]:
        """
        Returns a tuple with the row and column of the cell that was last clicked.
        Headers will have a row == -1 and the Row Number Column (if present) will have a column == -1
        :return: The (row,col) position of the last cell clicked in the table
        :rtype:  (int | None, int | None)
        """
        ...
    
    Update = ...
    Get = ...


class Tree(Element):
    """
    Tree Element - Presents data in a tree-like manner, much like a file/folder browser.  Uses the TreeData class
    to hold the user's data and pass to the element for display.
    """
    def __init__(self, data=..., headings=..., visible_column_map=..., col_widths=..., col0_width=..., col0_heading=..., def_col_width=..., auto_size_columns=..., max_col_width=..., select_mode=..., show_expanded=..., change_submits=..., enable_events=..., font=..., justification=..., text_color=..., border_width=..., background_color=..., selected_row_colors=..., header_text_color=..., header_background_color=..., header_font=..., header_border_width=..., header_relief=..., num_rows=..., sbar_trough_color=..., sbar_background_color=..., sbar_arrow_color=..., sbar_width=..., sbar_arrow_width=..., sbar_frame_color=..., sbar_relief=..., row_height=..., vertical_scroll_only=..., hide_vertical_scroll=..., pad=..., p=..., key=..., k=..., tooltip=..., right_click_menu=..., expand_x=..., expand_y=..., visible=..., metadata=...) -> None:
        """
        :param data:                    The data represented using a PySimpleGUI provided TreeData class
        :type data:                     (TreeData)
        :param headings:                List of individual headings for each column
        :type headings:                 List[str]
        :param visible_column_map:      Determines if a column should be visible. If left empty, all columns will be shown
        :type visible_column_map:       List[bool]
        :param col_widths:              List of column widths so that individual column widths can be controlled
        :type col_widths:               List[int]
        :param col0_width:              Size of Column 0 which is where the row numbers will be optionally shown
        :type col0_width:               (int)
        :param col0_heading:            Text to be shown in the header for the left-most column
        :type col0_heading:             (str)
        :param def_col_width:           default column width
        :type def_col_width:            (int)
        :param auto_size_columns:       if True, the size of a column is determined  using the contents of the column
        :type auto_size_columns:        (bool)
        :param max_col_width:           the maximum size a column can be
        :type max_col_width:            (int)
        :param select_mode:             Use same values as found on Table Element.  Valid values include: TABLE_SELECT_MODE_NONE TABLE_SELECT_MODE_BROWSE TABLE_SELECT_MODE_EXTENDED
        :type select_mode:              (enum)
        :param show_expanded:           if True then the tree will be initially shown with all nodes completely expanded
        :type show_expanded:            (bool)
        :param change_submits:          DO NOT USE. Only listed for backwards compat - Use enable_events instead
        :type change_submits:           (bool)
        :param enable_events:           Turns on the element specific events. Tree events happen when row is clicked
        :type enable_events:            (bool)
        :param font:                    specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
        :type font:                     (str or (str, int[, str]) or None)
        :param justification:           'left', 'right', 'center' are valid choices
        :type justification:            (str)
        :param text_color:              color of the text
        :type text_color:               (str)
        :param border_width:            Border width/depth in pixels
        :type border_width:             (int)
        :param background_color:        color of background
        :type background_color:         (str)
        :param selected_row_colors:     Sets the text color and background color for a selected row. Same format as button colors - tuple ('red', 'yellow') or string 'red on yellow'. Defaults to theme's button color
        :type selected_row_colors:      str or (str, str)
        :param header_text_color:       sets the text color for the header
        :type header_text_color:        (str)
        :param header_background_color: sets the background color for the header
        :type header_background_color:  (str)
        :param header_font:             specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
        :type header_font:              (str or (str, int[, str]) or None)
        :param header_border_width:     Border width for the header portion
        :type header_border_width:      (int | None)
        :param header_relief:           Relief style for the header. Values are same as other elements that use relief. RELIEF_RAISED RELIEF_SUNKEN RELIEF_FLAT RELIEF_RIDGE RELIEF_GROOVE RELIEF_SOLID
        :type header_relief:            (str | None)
        :param num_rows:                The number of rows of the table to display at a time
        :type num_rows:                 (int)
        :param row_height:              height of a single row in pixels
        :type row_height:               (int)
        :param vertical_scroll_only:    if True only the vertical scrollbar will be visible
        :type vertical_scroll_only:     (bool)
        :param hide_vertical_scroll:    if True vertical scrollbar will be hidden
        :type hide_vertical_scroll:     (bool)
        :param sbar_trough_color:           Scrollbar color of the trough
        :type sbar_trough_color:            (str)
        :param sbar_background_color:       Scrollbar color of the background of the arrow buttons at the ends AND the color of the "thumb" (the thing you grab and slide). Switches to arrow color when mouse is over
        :type sbar_background_color:        (str)
        :param sbar_arrow_color:            Scrollbar color of the arrow at the ends of the scrollbar (it looks like a button). Switches to background color when mouse is over
        :type sbar_arrow_color:             (str)
        :param sbar_width:                  Scrollbar width in pixels
        :type sbar_width:                   (int)
        :param sbar_arrow_width:            Scrollbar width of the arrow on the scrollbar. It will potentially impact the overall width of the scrollbar
        :type sbar_arrow_width:             (int)
        :param sbar_frame_color:            Scrollbar Color of frame around scrollbar (available only on some ttk themes)
        :type sbar_frame_color:             (str)
        :param sbar_relief:                 Scrollbar relief that will be used for the "thumb" of the scrollbar (the thing you grab that slides). Should be a constant that is defined at starting with "RELIEF_" - RELIEF_RAISED, RELIEF_SUNKEN, RELIEF_FLAT, RELIEF_RIDGE, RELIEF_GROOVE, RELIEF_SOLID
        :type sbar_relief:                  (str)
        :param pad:                     Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
        :type pad:                      (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param p:                       Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
        :type p:                        (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param key:                     Used with window.find_element and with return values to uniquely identify this element to uniquely identify this element
        :type key:                      str | int | tuple | object
        :param k:                       Same as the Key. You can use either k or key. Which ever is set will be used.
        :type k:                        str | int | tuple | object
        :param tooltip:                 text, that will appear when mouse hovers over the element
        :type tooltip:                  (str)
        :param right_click_menu:        A list of lists of Menu items to show when this element is right clicked. See user docs for exact format.
        :type right_click_menu:         List[List[str] | str]]
        :param expand_x:                If True the element will automatically expand in the X direction to fill available space
        :type expand_x:                 (bool)
        :param expand_y:                If True the element will automatically expand in the Y direction to fill available space
        :type expand_y:                 (bool)
        :param visible:                 set visibility state of the element
        :type visible:                  (bool)
        :param metadata:                User metadata that can be set to ANYTHING
        :type metadata:                 (Any)
        """
        ...
    
    def add_treeview_data(self, node): # -> None:
        """
        Not a user function.  Recursive method that inserts tree data into the tkinter treeview widget.

        :param node: The node to insert.  Will insert all nodes from starting point downward, recursively
        :type node:  (TreeData)
        """
        ...
    
    def update(self, values=..., key=..., value=..., text=..., icon=..., visible=...): # -> Self@Tree | None:
        """
        Changes some of the settings for the Tree Element. Must call `Window.Read` or `Window.Finalize` prior

        Changes will not be visible in your window until you call window.read or window.refresh.

        If you change visibility, your element may MOVE. If you want it to remain stationary, use the "layout helper"
        function "pin" to ensure your element is "pinned" to that location in your layout so that it returns there
        when made visible.

        :param values:  Representation of the tree
        :type values:   (TreeData)
        :param key:     identifies a particular item in tree to update
        :type key:      str | int | tuple | object
        :param value:   sets the node identified by key to a particular value
        :type value:    (Any)
        :param text:    sets the node identified by key to this string
        :type text:     (str)
        :param icon:    can be either a base64 icon or a filename for the icon
        :type icon:     bytes | str
        :param visible: control visibility of element
        :type visible:  (bool)
        """
        ...
    
    Update = ...


class TreeData:
    """
    Class that user fills in to represent their tree data. It's a very simple tree representation with a root "Node"
    with possibly one or more children "Nodes".  Each Node contains a key, text to display, list of values to display
    and an icon.  The entire tree is built using a single method, Insert.  Nothing else is required to make the tree.
    """
    class Node:
        """
        Contains information about the individual node in the tree
        """
        def __init__(self, parent, key, text, values, icon=...) -> None:
            """
            Represents a node within the TreeData class

            :param parent: The parent Node
            :type parent:  (TreeData.Node)
            :param key:    Used to uniquely identify this node
            :type key:     str | int | tuple | object
            :param text:   The text that is displayed at this node's location
            :type text:    (str)
            :param values: The list of values that are displayed at this node
            :type values:  List[Any]
            :param icon:   just a icon
            :type icon:    str | bytes
            """
            ...
        
    
    
    def __init__(self) -> None:
        """
        Instantiate the object, initializes the Tree Data, creates a root node for you
        """
        ...
    
    def insert(self, parent, key, text, values, icon=...): # -> None:
        """
        Inserts a node into the tree. This is how user builds their tree, by Inserting Nodes
        This is the ONLY user callable method in the TreeData class

        :param parent: the parent Node
        :type parent:  (Node)
        :param key:    Used to uniquely identify this node
        :type key:     str | int | tuple | object
        :param text:   The text that is displayed at this node's location
        :type text:    (str)
        :param values: The list of values that are displayed at this node
        :type values:  List[Any]
        :param icon:   icon
        :type icon:    str | bytes
        """
        ...
    
    def __repr__(self): # -> str:
        """
        Converts the TreeData into a printable version, nicely formatted

        :return: (str) A formatted, text version of the TreeData
        :rtype:
        """
        ...
    
    Insert = ...


class ErrorElement(Element):
    """
    A "dummy Element" that is returned when there are error conditions, like trying to find an element that's invalid
    """
    def __init__(self, key=..., metadata=...) -> None:
        """
        :param key: Used with window.find_element and with return values to uniquely identify this element
        :type key:
        """
        ...
    
    def update(self, silent_on_error=..., *args, **kwargs): # -> Self@ErrorElement:
        """
        Update method for the Error Element, an element that should not be directly used by developer

        :param silent_on_error: if False, then a Popup window will be shown
        :type silent_on_error:  (bool)
        :param *args:           meant to "soak up" any normal parameters passed in
        :type *args:            (Any)
        :param **kwargs:        meant to "soak up" any keyword parameters that were passed in
        :type **kwargs:         (Any)
        :return:                returns 'self' so call can be chained
        :rtype:                 (ErrorElement)
        """
        ...
    
    def get(self): # -> Literal['This is NOT a valid Element!\nSTOP trying to do thi']:
        """
        One of the method names found in other Elements. Used here to return an error string in case it's called

        :return: A warning text string.
        :rtype:  (str)
        """
        ...
    
    Get = ...
    Update = ...


def Stretch(background_color=...): # -> Text:
    """
    Acts like a Stretch element found in the Qt port.
    Used in a Horizontal fashion.  Placing one on each side of an element will enter the element.
    Place one to the left and the element to the right will be right justified.  See VStretch for vertical type
    :param background_color: color of background may be needed because of how this is implemented
    :type background_color:  (str)
    :return:                 (Text)
    """
    ...

Push = ...
P = ...
def VStretch(background_color=...): # -> Text:
    """
    Acts like a Stretch element found in the Qt port.
    Used in a Vertical fashion.
    :param background_color: color of background may be needed because of how this is implemented
    :type background_color:  (str)
    :return:                 (Text)
    """
    ...

VPush = ...
VP = ...
class Window:
    """
    Represents a single Window
    """
    NumOpenWindows = ...
    _user_defined_icon = ...
    hidden_master_root: tk.Tk = ...
    _animated_popup_dict: Dict = ...
    _active_windows: Dict[Window, tk.Tk()] = ...
    _move_all_windows = ...
    _window_that_exited: Window = ...
    _root_running_mainloop: tk.Tk() = ...
    _timeout_key = ...
    _TKAfterID = ...
    _window_running_mainloop = ...
    _container_element_counter = ...
    _read_call_from_debugger = ...
    _timeout_0_counter = ...
    _counter_for_ttk_widgets = ...
    _floating_debug_window_build_needed = ...
    _main_debug_window_build_needed = ...
    def __init__(self, title, layout=..., default_element_size=..., default_button_element_size=..., auto_size_text=..., auto_size_buttons=..., location=..., relative_location=..., size=..., element_padding=..., margins=..., button_color=..., font=..., progress_bar_color=..., background_color=..., border_depth=..., auto_close=..., auto_close_duration=..., icon=..., force_toplevel=..., alpha_channel=..., return_keyboard_events=..., use_default_focus=..., text_justification=..., no_titlebar=..., grab_anywhere=..., grab_anywhere_using_control=..., keep_on_top=..., resizable=..., disable_close=..., disable_minimize=..., right_click_menu=..., transparent_color=..., debugger_enabled=..., right_click_menu_background_color=..., right_click_menu_text_color=..., right_click_menu_disabled_text_color=..., right_click_menu_selected_colors=..., right_click_menu_font=..., right_click_menu_tearoff=..., finalize=..., element_justification=..., ttk_theme=..., use_ttk_buttons=..., modal=..., enable_close_attempted_event=..., titlebar_background_color=..., titlebar_text_color=..., titlebar_font=..., titlebar_icon=..., use_custom_titlebar=..., scaling=..., sbar_trough_color=..., sbar_background_color=..., sbar_arrow_color=..., sbar_width=..., sbar_arrow_width=..., sbar_frame_color=..., sbar_relief=..., metadata=...) -> None:
        """
        :param title:                                The title that will be displayed in the Titlebar and on the Taskbar
        :type title:                                 (str)
        :param layout:                               The layout for the window. Can also be specified in the Layout method
        :type layout:                                List[List[Element]] | Tuple[Tuple[Element]]
        :param default_element_size:                 size in characters (wide) and rows (high) for all elements in this window
        :type default_element_size:                  (int, int) - (width, height)
        :param default_button_element_size:          (width, height) size in characters (wide) and rows (high) for all Button elements in this window
        :type default_button_element_size:           (int, int)
        :param auto_size_text:                       True if Elements in Window should be sized to exactly fir the length of text
        :type auto_size_text:                        (bool)
        :param auto_size_buttons:                    True if Buttons in this Window should be sized to exactly fit the text on this.
        :type auto_size_buttons:                     (bool)
        :param relative_location:                    (x,y) location relative to the default location of the window, in pixels. Normally the window centers.  This location is relative to the location the window would be created. Note they can be negative.
        :type relative_location:                     (int, int)
        :param location:                             (x,y) location, in pixels, to locate the upper left corner of the window on the screen. Default is to center on screen.
        :type location:                              (int, int)
        :param size:                                 (width, height) size in pixels for this window. Normally the window is autosized to fit contents, not set to an absolute size by the user. Try not to set this value. You risk, the contents being cut off, etc. Let the layout determine the window size instead
        :type size:                                  (int, int)
        :param element_padding:                      Default amount of padding to put around elements in window (left/right, top/bottom) or ((left, right), (top, bottom)), or an int. If an int, then it's converted into a tuple (int, int)
        :type element_padding:                       (int, int) or ((int, int),(int,int)) or int
        :param margins:                              (left/right, top/bottom) Amount of pixels to leave inside the window's frame around the edges before your elements are shown.
        :type margins:                               (int, int)
        :param button_color:                         Default button colors for all buttons in the window
        :type button_color:                          (str, str) or str
        :param font:                                 specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
        :type font:                                  (str or (str, int[, str]) or None)
        :param progress_bar_color:                   (bar color, background color) Sets the default colors for all progress bars in the window
        :type progress_bar_color:                    (str, str)
        :param background_color:                     color of background
        :type background_color:                      (str)
        :param border_depth:                         Default border depth (width) for all elements in the window
        :type border_depth:                          (int)
        :param auto_close:                           If True, the window will automatically close itself
        :type auto_close:                            (bool)
        :param auto_close_duration:                  Number of seconds to wait before closing the window
        :type auto_close_duration:                   (int)
        :param icon:                                 Can be either a filename or Base64 value. For Windows if filename, it MUST be ICO format. For Linux, must NOT be ICO. Most portable is to use a Base64 of a PNG file. This works universally across all OS's
        :type icon:                                  (str | bytes)
        :param force_toplevel:                       If True will cause this window to skip the normal use of a hidden master window
        :type force_toplevel:                        (bool)
        :param alpha_channel:                        Sets the opacity of the window. 0 = invisible 1 = completely visible. Values bewteen 0 & 1 will produce semi-transparent windows in SOME environments (The Raspberry Pi always has this value at 1 and cannot change.
        :type alpha_channel:                         (float)
        :param return_keyboard_events:               if True key presses on the keyboard will be returned as Events from Read calls
        :type return_keyboard_events:                (bool)
        :param use_default_focus:                    If True will use the default focus algorithm to set the focus to the "Correct" element
        :type use_default_focus:                     (bool)
        :param text_justification:                   Default text justification for all Text Elements in window
        :type text_justification:                    'left' | 'right' | 'center'
        :param no_titlebar:                          If true, no titlebar nor frame will be shown on window. This means you cannot minimize the window and it will not show up on the taskbar
        :type no_titlebar:                           (bool)
        :param grab_anywhere:                        If True can use mouse to click and drag to move the window. Almost every location of the window will work except input fields on some systems
        :type grab_anywhere:                         (bool)
        :param grab_anywhere_using_control:          If True can use CONTROL key + left mouse mouse to click and drag to move the window. DEFAULT is TRUE. Unlike normal grab anywhere, it works on all elements.
        :type grab_anywhere_using_control:           (bool)
        :param keep_on_top:                          If True, window will be created on top of all other windows on screen. It can be bumped down if another window created with this parm
        :type keep_on_top:                           (bool)
        :param resizable:                            If True, allows the user to resize the window. Note the not all Elements will change size or location when resizing.
        :type resizable:                             (bool)
        :param disable_close:                        If True, the X button in the top right corner of the window will no work.  Use with caution and always give a way out toyour users
        :type disable_close:                         (bool)
        :param disable_minimize:                     if True the user won't be able to minimize window.  Good for taking over entire screen and staying that way.
        :type disable_minimize:                      (bool)
        :param right_click_menu:                     A list of lists of Menu items to show when this element is right clicked. See user docs for exact format.
        :type right_click_menu:                      List[List[ List[str] | str ]]
        :param transparent_color:                    Any portion of the window that has this color will be completely transparent. You can even click through these spots to the window under this window.
        :type transparent_color:                     (str)
        :param debugger_enabled:                     If True then the internal debugger will be enabled
        :type debugger_enabled:                      (bool)
        :param right_click_menu_background_color:    Background color for right click menus
        :type right_click_menu_background_color:     (str)
        :param right_click_menu_text_color:          Text color for right click menus
        :type right_click_menu_text_color:           (str)
        :param right_click_menu_disabled_text_color: Text color for disabled right click menu items
        :type right_click_menu_disabled_text_color:  (str)
        :param right_click_menu_selected_colors:     Text AND background colors for a selected item. Can be a Tuple OR a color string. simplified-button-color-string "foreground on background". Can be a single color if want to set only the background. Normally a tuple, but can be a simplified-dual-color-string "foreground on background". Can be a single color if want to set only the background.
        :type right_click_menu_selected_colors:      (str, str) | str | Tuple
        :param right_click_menu_font:                Font for right click menus
        :type right_click_menu_font:                 (str or (str, int[, str]) or None)
        :param right_click_menu_tearoff:             If True then all right click menus can be torn off
        :type right_click_menu_tearoff:              bool
        :param finalize:                             If True then the Finalize method will be called. Use this rather than chaining .Finalize for cleaner code
        :type finalize:                              (bool)
        :param element_justification:                All elements in the Window itself will have this justification 'left', 'right', 'center' are valid values
        :type element_justification:                 (str)
        :param ttk_theme:                            Set the tkinter ttk "theme" of the window.  Default = DEFAULT_TTK_THEME.  Sets all ttk widgets to this theme as their default
        :type ttk_theme:                             (str)
        :param use_ttk_buttons:                      Affects all buttons in window. True = use ttk buttons. False = do not use ttk buttons.  None = use ttk buttons only if on a Mac
        :type use_ttk_buttons:                       (bool)
        :param modal:                                If True then this window will be the only window a user can interact with until it is closed
        :type modal:                                 (bool)
        :param enable_close_attempted_event:         If True then the window will not close when "X" clicked. Instead an event WINDOW_CLOSE_ATTEMPTED_EVENT if returned from window.read
        :type enable_close_attempted_event:          (bool)
        :param titlebar_background_color:            If custom titlebar indicated by use_custom_titlebar, then use this as background color
        :type titlebar_background_color:             (str | None)
        :param titlebar_text_color:                  If custom titlebar indicated by use_custom_titlebar, then use this as text color
        :type titlebar_text_color:                   (str | None)
        :param titlebar_font:                        If custom titlebar indicated by use_custom_titlebar, then use this as title font
        :type titlebar_font:                         (str or (str, int[, str]) or None)
        :param titlebar_icon:                        If custom titlebar indicated by use_custom_titlebar, then use this as the icon (file or base64 bytes)
        :type titlebar_icon:                         (bytes | str)
        :param use_custom_titlebar:                  If True, then a custom titlebar will be used instead of the normal titlebar
        :type use_custom_titlebar:                   bool
        :param scaling:                              Apply scaling to the elements in the window. Can be set on a global basis using set_options
        :type scaling:                               float
        :param sbar_trough_color:                    Scrollbar color of the trough
        :type sbar_trough_color:                     (str)
        :param sbar_background_color:                Scrollbar color of the background of the arrow buttons at the ends AND the color of the "thumb" (the thing you grab and slide). Switches to arrow color when mouse is over
        :type sbar_background_color:                 (str)
        :param sbar_arrow_color:                     Scrollbar color of the arrow at the ends of the scrollbar (it looks like a button). Switches to background color when mouse is over
        :type sbar_arrow_color:                      (str)
        :param sbar_width:                           Scrollbar width in pixels
        :type sbar_width:                            (int)
        :param sbar_arrow_width:                     Scrollbar width of the arrow on the scrollbar. It will potentially impact the overall width of the scrollbar
        :type sbar_arrow_width:                      (int)
        :param sbar_frame_color:                     Scrollbar Color of frame around scrollbar (available only on some ttk themes)
        :type sbar_frame_color:                      (str)
        :param sbar_relief:                          Scrollbar relief that will be used for the "thumb" of the scrollbar (the thing you grab that slides). Should be a constant that is defined at starting with "RELIEF_" - RELIEF_RAISED, RELIEF_SUNKEN, RELIEF_FLAT, RELIEF_RIDGE, RELIEF_GROOVE, RELIEF_SOLID
        :type sbar_relief:                           (str)
        :param metadata:                             User metadata that can be set to ANYTHING
        :type metadata:                              (Any)
        """
        ...
    
    @classmethod
    def get_screen_size(self): # -> tuple[int, int]:
        """
        This is a "Class Method" meaning you call it by writing: width, height = Window.get_screen_size()
        Returns the size of the "screen" as determined by tkinter.  This can vary depending on your operating system and the number of monitors installed on your system.  For Windows, the primary monitor's size is returns. On some multi-monitored Linux systems, the monitors are combined and the total size is reported as if one screen.

        :return: Size of the screen in pixels as determined by tkinter
        :rtype:  (int, int)
        """
        ...
    
    @property
    def metadata(self): # -> Any:
        """
        Metadata is available for all windows. You can set to any value.
        :return: the current metadata value
        :rtype:  (Any)
        """
        ...
    
    @metadata.setter
    def metadata(self, value): # -> None:
        """
        Metadata is available for all windows. You can set to any value.
        :param value: Anything you want it to be
        :type value:  (Any)
        """
        ...
    
    def add_row(self, *args): # -> None:
        """
        Adds a single row of elements to a window's self.Rows variables.
        Generally speaking this is NOT how users should be building Window layouts.
        Users, create a single layout (a list of lists) and pass as a parameter to Window object, or call Window.Layout(layout)

        :param *args: List[Elements]
        :type *args:
        """
        ...
    
    def add_rows(self, rows): # -> None:
        """
        Loops through a list of lists of elements and adds each row, list, to the layout.
        This is NOT the best way to go about creating a window.  Sending the entire layout at one time and passing
        it as a parameter to the Window call is better.

        :param rows: A list of a list of elements
        :type rows:  List[List[Elements]]
        """
        ...
    
    def layout(self, rows): # -> Self@Window:
        """
        Second of two preferred ways of telling a Window what its layout is. The other way is to pass the layout as
        a parameter to Window object.  The parameter method is the currently preferred method. This call to Layout
        has been removed from examples contained in documents and in the Demo Programs. Trying to remove this call
        from history and replace with sending as a parameter to Window.

        :param rows: Your entire layout
        :type rows:  List[List[Elements]]
        :return:     self so that you can chain method calls
        :rtype:      (Window)
        """
        ...
    
    def extend_layout(self, container, rows): # -> Self@Window:
        """
        Adds new rows to an existing container element inside of this window
        If the container is a scrollable Column, you need to also call the contents_changed() method

        :param container: The container Element the layout will be placed inside of
        :type container:  Frame | Column | Tab
        :param rows:      The layout to be added
        :type rows:       (List[List[Element]])
        :return:          (Window) self so could be chained
        :rtype:           (Window)
        """
        ...
    
    def LayoutAndRead(self, rows, non_blocking=...):
        """
        Deprecated!!  Now your layout your window's rows (layout) and then separately call Read.

        :param rows:         The layout of the window
        :type rows:          List[List[Element]]
        :param non_blocking: if True the Read call will not block
        :type non_blocking:  (bool)
        """
        ...
    
    def LayoutAndShow(self, rows):
        """
        Deprecated - do not use any longer.  Layout your window and then call Read.  Or can add a Finalize call before the Read
        """
        ...
    
    def set_icon(self, icon=..., pngbase64=...): # -> None:
        """
        Changes the icon that is shown on the title bar and on the task bar.
        NOTE - The file type is IMPORTANT and depends on the OS!
        Can pass in:
        * filename which must be a .ICO icon file for windows, PNG file for Linux
        * bytes object
        * BASE64 encoded file held in a variable

        :param icon:      Filename or bytes object
        :type icon:       (str)
        :param pngbase64: Base64 encoded image
        :type pngbase64:  (bytes)
        """
        ...
    
    def read(self, timeout=..., timeout_key=..., close=...): # -> tuple[str, Unknown] | None:
        """
        THE biggest deal method in the Window class! This is how you get all of your data from your Window.
            Pass in a timeout (in milliseconds) to wait for a maximum of timeout milliseconds. Will return timeout_key
            if no other GUI events happen first.

        :param timeout:     Milliseconds to wait until the Read will return IF no other GUI events happen first
        :type timeout:      (int)
        :param timeout_key: The value that will be returned from the call if the timer expired
        :type timeout_key:  (Any)
        :param close:       if True the window will be closed prior to returning
        :type close:        (bool)
        :return:            (event, values)
        :rtype:             Tuple[(Any), Dict[Any, Any], List[Any], None]
        """
        ...
    
    def finalize(self): # -> Self@Window:
        """
        Use this method to cause your layout to built into a real tkinter window.  In reality this method is like
        Read(timeout=0).  It doesn't block and uses your layout to create tkinter widgets to represent the elements.
        Lots of action!

        :return: Returns 'self' so that method "Chaining" can happen (read up about it as it's very cool!)
        :rtype:  (Window)
        """
        ...
    
    def refresh(self): # -> Self@Window:
        """
        Refreshes the window by calling tkroot.update().  Can sometimes get away with a refresh instead of a Read.
        Use this call when you want something to appear in your Window immediately (as soon as this function is called).
        If you change an element in a window, your change will not be visible until the next call to Window.read
        or a call to Window.refresh()

        :return: `self` so that method calls can be easily "chained"
        :rtype:  (Window)
        """
        ...
    
    def fill(self, values_dict): # -> Self@Window:
        """
        Fill in elements that are input fields with data based on a 'values dictionary'

        :param values_dict: pairs
        :type values_dict:  (Dict[Any, Any]) - {Element_key : value}
        :return:            returns self so can be chained with other methods
        :rtype:             (Window)
        """
        ...
    
    def FindElement(self, key, silent_on_error=...): # -> ErrorElement:
        """
        ** Warning ** This call will eventually be depricated. **

        It is suggested that you modify your code to use the recommended window[key] lookup or the PEP8 compliant window.find_element(key)

        For now, you'll only see a message printed and the call will continue to funcation as before.

        :param key:             Used with window.find_element and with return values to uniquely identify this element
        :type key:              str | int | tuple | object
        :param silent_on_error: If True do not display popup nor print warning of key errors
        :type silent_on_error:  (bool)
        :return:                Return value can be: the Element that matches the supplied key if found; an Error Element if silent_on_error is False; None if silent_on_error True;
        :rtype:                 Element | Error Element | None
        """
        ...
    
    def find_element(self, key, silent_on_error=...): # -> ErrorElement:
        """
        Find element object associated with the provided key.
        THIS METHOD IS NO LONGER NEEDED to be called by the user

        You can perform the same operation by writing this statement:
        element = window[key]

        You can drop the entire "find_element" function name and use [ ] instead.

        However, if you wish to perform a lookup without error checking, and don't have error popups turned
        off globally, you'll need to make this call so that you can disable error checks on this call.

        find_element is yypically used in combination with a call to element's Update method (or any other element method!):
        window[key].update(new_value)

        Versus the "old way"
        window.FindElement(key).Update(new_value)

        This call can be abbreviated to any of these:
        find_element = FindElement == Element == Find
        With find_element being the PEP8 compliant call that should be used.

        Rememeber that this call will return None if no match is found which may cause your code to crash if not
        checked for.

        :param key:             Used with window.find_element and with return values to uniquely identify this element
        :type key:              str | int | tuple | object
        :param silent_on_error: If True do not display popup nor print warning of key errors
        :type silent_on_error:  (bool)
        :return:                Return value can be: the Element that matches the supplied key if found; an Error Element if silent_on_error is False; None if silent_on_error True;
        :rtype:                 Element | Error Element | None
        """
        ...
    
    Element = ...
    Find = ...
    Elem = ...
    def find_element_with_focus(self): # -> None:
        """
        Returns the Element that currently has focus as reported by tkinter. If no element is found None is returned!
        :return: An Element if one has been found with focus or None if no element found
        :rtype:  Element | None
        """
        ...
    
    def widget_to_element(self, widget): # -> None:
        """
        Returns the element that matches a supplied tkinter widget.
        If no matching element is found, then None is returned.


        :return:    Element that uses the specified widget
        :rtype:     Element | None
        """
        ...
    
    def element_list(self): # -> list[Unknown]:
        """
        Returns a list of all elements in the window

        :return: List of all elements in the window and container elements in the window
        :rtype:  List[Element]
        """
        ...
    
    def save_to_disk(self, filename): # -> None:
        """
        Saves the values contained in each of the input areas of the form. Basically saves what would be returned from a call to Read.  It takes these results and saves them to disk using pickle.
         Note that every element in your layout that is to be saved must have a key assigned to it.

        :param filename: Filename to save the values to in pickled form
        :type filename:  str
        """
        ...
    
    def load_from_disk(self, filename): # -> None:
        """
        Restore values from a previous call to SaveToDisk which saves the returned values dictionary in Pickle format

        :param filename: Pickle Filename to load
        :type filename:  (str)
        """
        ...
    
    def get_screen_dimensions(self): # -> tuple[int, int]:
        """
        Get the screen dimensions.  NOTE - you must have a window already open for this to work (blame tkinter not me)

        :return: Tuple containing width and height of screen in pixels
        :rtype:  Tuple[None, None] | Tuple[width, height]
        """
        ...
    
    def move(self, x, y): # -> None:
        """
        Move the upper left corner of this window to the x,y coordinates provided
        :param x: x coordinate in pixels
        :type x:  (int)
        :param y: y coordinate in pixels
        :type y:  (int)
        """
        ...
    
    def move_to_center(self): # -> None:
        """
        Recenter your window after it's been moved or the size changed.

        This is a conveinence method. There are no tkinter calls involved, only pure PySimpleGUI API calls.
        """
        ...
    
    def minimize(self): # -> None:
        """
        Minimize this window to the task bar
        """
        ...
    
    def maximize(self): # -> None:
        """
        Maximize the window. This is done differently on a windows system versus a linux or mac one.  For non-Windows
        the root attribute '-fullscreen' is set to True.  For Windows the "root" state is changed to "zoomed"
        The reason for the difference is the title bar is removed in some cases when using fullscreen option
        """
        ...
    
    def normal(self): # -> None:
        """
        Restore a window to a non-maximized state.  Does different things depending on platform.  See Maximize for more.
        """
        ...
    
    def close(self): # -> None:
        """
        Closes window.  Users can safely call even if window has been destroyed.   Should always call when done with
        a window so that resources are properly freed up within your thread.
        """
        ...
    
    def is_closed(self): # -> bool:
        """
        Returns True is the window is maybe closed.  Can be difficult to tell sometimes

        :return:    True if the window was closed or destroyed
        :rtype:     (bool)
        """
        ...
    
    def disable(self): # -> None:
        """
        Disables window from taking any input from the user
        """
        ...
    
    def enable(self): # -> None:
        """
        Re-enables window to take user input after having it be Disabled previously
        """
        ...
    
    def hide(self): # -> None:
        """
        Hides the window from the screen and the task bar
        """
        ...
    
    def un_hide(self): # -> None:
        """
        Used to bring back a window that was previously hidden using the Hide method
        """
        ...
    
    def disappear(self): # -> None:
        """
        Causes a window to "disappear" from the screen, but remain on the taskbar. It does this by turning the alpha
        channel to 0.  NOTE that on some platforms alpha is not supported. The window will remain showing on these
        platforms.  The Raspberry Pi for example does not have an alpha setting
        """
        ...
    
    def reappear(self): # -> None:
        """
        Causes a window previously made to "Disappear" (using that method). Does this by restoring the alpha channel
        """
        ...
    
    def set_alpha(self, alpha): # -> None:
        """
        Sets the Alpha Channel for a window.  Values are between 0 and 1 where 0 is completely transparent

        :param alpha: 0 to 1. 0 is completely transparent.  1 is completely visible and solid (can't see through)
        :type alpha:  (float)
        """
        ...
    
    @property
    def alpha_channel(self): # -> float:
        """
        A property that changes the current alpha channel value (internal value)
        :return: the current alpha channel setting according to self, not read directly from tkinter
        :rtype:  (float)
        """
        ...
    
    @alpha_channel.setter
    def alpha_channel(self, alpha): # -> None:
        """
        The setter method for this "property".
        Planning on depricating so that a Set call is always used by users. This is more in line with the SDK
        :param alpha: 0 to 1. 0 is completely transparent.  1 is completely visible and solid (can't see through)
        :type alpha:  (float)
        """
        ...
    
    def bring_to_front(self): # -> None:
        """
        Brings this window to the top of all other windows (perhaps may not be brought before a window made to "stay
        on top")
        """
        ...
    
    def send_to_back(self): # -> None:
        """
        Pushes this window to the bottom of the stack of windows. It is the opposite of BringToFront
        """
        ...
    
    def keep_on_top_set(self): # -> None:
        """
        Sets keep_on_top after a window has been created.  Effect is the same
        as if the window was created with this set.  The Window is also brought
        to the front
        """
        ...
    
    def keep_on_top_clear(self): # -> None:
        """
        Clears keep_on_top after a window has been created.  Effect is the same
        as if the window was created with this set.
        """
        ...
    
    def current_location(self, more_accurate=...): # -> tuple[None, None] | tuple[int | None, int | None]:
        """
        Get the current location of the window's top left corner.
        Sometimes, depending on the environment, the value returned does not include the titlebar,etc
        A new option, more_accurate, can be used to get the theoretical upper leftmost corner of the window.
        The titlebar and menubar are crated by the OS. It gets really confusing when running in a webpage (repl, trinket)
        Thus, the values can appear top be "off" due to the sometimes unpredictable way the location is calculated.

        :param more_accurate: If True, will use the window's geometry to get the topmost location with titlebar, menubar taken into account
        :type more_accurate:  (bool)
        :return:              The x and y location in tuple form (x,y)
        :rtype:               Tuple[(int | None), (int | None)]
        """
        ...
    
    def current_size_accurate(self): # -> tuple[None, None] | tuple[int | None, int | None]:
        """
        Get the current location of the window based on tkinter's geometry setting

        :return:              The x and y size in tuple form (x,y)
        :rtype:               Tuple[(int | None), (int | None)]
        """
        ...
    
    @property
    def size(self): # -> tuple[None, None] | tuple[int, int]:
        """
        Return the current size of the window in pixels

        :return: (width, height) of the window
        :rtype:  Tuple[(int), (int)] or Tuple[None, None]
        """
        ...
    
    @size.setter
    def size(self, size): # -> None:
        """
        Changes the size of the window, if possible

        :param size: (width, height) of the desired window size
        :type size:  (int, int)
        """
        ...
    
    def set_min_size(self, size): # -> None:
        """
        Changes the minimum size of the window. Note Window must be read or finalized first.

        :param size: (width, height) tuple (int, int) of the desired window size in pixels
        :type size:  (int, int)
        """
        ...
    
    def visibility_changed(self): # -> None:
        """
        When making an element in a column or someplace that has a scrollbar, then you'll want to call this function
        prior to the column's contents_changed() method.
        """
        ...
    
    def set_transparent_color(self, color): # -> None:
        """
        Set the color that will be transparent in your window. Areas with this color will be SEE THROUGH.

        :param color: Color string that defines the transparent color
        :type color:  (str)
        """
        ...
    
    def mouse_location(self): # -> tuple[Literal[0], Literal[0]] | tuple[int, int]:
        """
        Return the (x,y) location of the mouse relative to the entire screen.  It's the same location that
        you would use to create a window, popup, etc.

        :return:    The location of the mouse pointer
        :rtype:     (int, int)
        """
        ...
    
    def grab_any_where_on(self): # -> None:
        """
        Turns on Grab Anywhere functionality AFTER a window has been created.  Don't try on a window that's not yet
        been Finalized or Read.
        """
        ...
    
    def grab_any_where_off(self): # -> None:
        """
        Turns off Grab Anywhere functionality AFTER a window has been created.  Don't try on a window that's not yet
        been Finalized or Read.
        """
        ...
    
    def bind(self, bind_string, key, propagate=...): # -> None:
        """
        Used to add tkinter events to a Window.
        The tkinter specific data is in the Window's member variable user_bind_event
        :param bind_string: The string tkinter expected in its bind function
        :type bind_string:  (str)
        :param key:         The event that will be generated when the tkinter event occurs
        :type key:          str | int | tuple | object
        :param propagate:   If True then tkinter will be told to propagate the event
        :type propagate:    (bool)
        """
        ...
    
    def enable_debugger(self): # -> None:
        """
        Enables the internal debugger. By default, the debugger IS enabled
        """
        ...
    
    def disable_debugger(self): # -> None:
        """
        Disable the internal debugger. By default the debugger is ENABLED
        """
        ...
    
    def set_title(self, title): # -> None:
        """
        Change the title of the window

        :param title: The string to set the title to
        :type title:  (str)
        """
        ...
    
    def make_modal(self): # -> None:
        """
        Makes a window into a "Modal Window"
        This means user will not be able to interact with other windows until this one is closed

        NOTE - Sorry Mac users - you can't have modal windows.... lobby your tkinter Mac devs
        """
        ...
    
    def force_focus(self): # -> None:
        """
        Forces this window to take focus
        """
        ...
    
    def was_closed(self): # -> bool:
        """
        Returns True if the window was closed

        :return: True if the window is closed
        :rtype:  bool
        """
        ...
    
    def set_cursor(self, cursor): # -> None:
        """
        Sets the cursor for the window.
        If you do not want any mouse pointer, then use the string "none"

        :param cursor: The tkinter cursor name
        :type cursor:  (str)
        """
        ...
    
    def ding(self, display_number=...): # -> None:
        """
        Make a "bell" sound. A capability provided by tkinter.  Your window needs to be finalized prior to calling.
        Ring a display's bell is the tkinter description of the call.
        :param display_number: Passed to tkinter's bell method as parameter "displayof".
        :type display_number:  int
        """
        ...
    
    def write_event_value(self, key, value): # -> None:
        """
        Adds a key & value tuple to the queue that is used by threads to communicate with the window

        :param key:   The key that will be returned as the event when reading the window
        :type key:    Any
        :param value: The value that will be in the values dictionary
        :type value:  Any
        """
        ...
    
    def save_window_screenshot_to_disk(self, filename=...): # -> Image | None:
        """
        Saves an image of the PySimpleGUI window provided into the filename provided

        :param filename:        Optional filename to save screenshot to. If not included, the User Settinds are used to get the filename
        :return:                A PIL ImageGrab object that can be saved or manipulated
        :rtype:                 (PIL.ImageGrab | None)
        """
        ...
    
    def perform_long_operation(self, func, end_key): # -> Thread:
        """
        Call your function that will take a long time to execute.  When it's complete, send an event
        specified by the end_key.

        Starts a thread on your behalf.

        This is a way for you to "ease into" threading without learning the details of threading.
        Your function will run, and when it returns 2 things will happen:
        1. The value you provide for end_key will be returned to you when you call window.read()
        2. If your function returns a value, then the value returned will also be included in your windows.read call in the values dictionary

        IMPORTANT - This method uses THREADS... this means you CANNOT make any PySimpleGUI calls from
        the function you provide with the exception of one function, Window.write_event_value.

        :param func:    A lambda or a function name with no parms
        :type func:     Any
        :param end_key: The key that will be generated when the function returns
        :type end_key:  (Any)
        :return:        The id of the thread
        :rtype:         threading.Thread
        """
        ...
    
    @property
    def key_dict(self): # -> dict[Unknown, Unknown]:
        """
        Returns a dictionary with all keys and their corresponding elements
        { key : Element }
        :return: Dictionary of keys and elements
        :rtype:  Dict[Any, Element]
        """
        ...
    
    def __getitem__(self, key): # -> ErrorElement:
        """
        Returns Element that matches the passed in key.
        This is "called" by writing code as thus:
        window['element key'].Update

        :param key: The key to find
        :type key:  str | int | tuple | object
        :rtype:     Element | Input | Combo | OptionMenu | Listbox | Radio | Checkbox | Spin | Multiline | Text | StatusBar | Output | Button | ButtonMenu | ProgressBar | Image | Canvas | Graph | Frame | VerticalSeparator | HorizontalSeparator | Tab | TabGroup | Slider | Column | Pane | Menu | Table | Tree | ErrorElement | None
        """
        ...
    
    def __call__(self, *args, **kwargs): # -> tuple[str, Unknown] | None:
        """
        Call window.read but without having to type it out.
        window() == window.read()
        window(timeout=50) == window.read(timeout=50)

        :return: The famous event, values that Read returns.
        :rtype:  Tuple[Any, Dict[Any, Any]]
        """
        ...
    
    AddRow = ...
    AddRows = ...
    AlphaChannel = ...
    BringToFront = ...
    Close = ...
    CurrentLocation = ...
    Disable = ...
    DisableDebugger = ...
    Disappear = ...
    Enable = ...
    EnableDebugger = ...
    Fill = ...
    Finalize = ...
    FindElementWithFocus = ...
    GetScreenDimensions = ...
    GrabAnyWhereOff = ...
    GrabAnyWhereOn = ...
    Hide = ...
    Layout = ...
    LoadFromDisk = ...
    Maximize = ...
    Minimize = ...
    Move = ...
    Normal = ...
    Read = ...
    Reappear = ...
    Refresh = ...
    SaveToDisk = ...
    SendToBack = ...
    SetAlpha = ...
    SetIcon = ...
    SetTransparentColor = ...
    Size = ...
    UnHide = ...
    VisibilityChanged = ...
    CloseNonBlocking = ...
    CloseNonBlockingForm = ...
    start_thread = ...


FlexForm = Window
def read_all_windows(timeout=..., timeout_key=...): # -> tuple[None, None, None] | tuple[Window, Unknown | str, Unknown] | tuple[Window, str | Unknown | None, Unknown | None] | tuple[None, str, None]:
    """
    Reads all windows that are "active" when the call is made. "Active" means that it's been finalized or read.
    If a window has not been finalized then it will not be considered an "active window"

    If any of the active windows returns a value then the window and its event and values
    are returned.

    If no windows are open, then the value (None, WIN_CLOSED, None) will be returned
        Since WIN_CLOSED is None, it means (None, None, None) is what's returned when no windows remain opened

    :param timeout:     Time in milliseconds to delay before a returning a timeout event
    :type timeout:      (int)
    :param timeout_key: Key to return when a timeout happens. Defaults to the standard TIMEOUT_KEY
    :type timeout_key:  (Any)
    :return:            A tuple with the  (Window, event, values dictionary/list)
    :rtype:             (Window, Any, Dict | List)
    """
    ...

SYSTEM_TRAY_WIN_MARGINS = ...
SYSTEM_TRAY_MESSAGE_MAX_LINE_LENGTH = ...
SYSTEM_TRAY_MESSAGE_WIN_COLOR = ...
SYSTEM_TRAY_MESSAGE_TEXT_COLOR = ...
SYSTEM_TRAY_MESSAGE_DISPLAY_DURATION_IN_MILLISECONDS = ...
SYSTEM_TRAY_MESSAGE_FADE_IN_DURATION = ...
EVENT_SYSTEM_TRAY_ICON_DOUBLE_CLICKED = ...
EVENT_SYSTEM_TRAY_ICON_ACTIVATED = ...
EVENT_SYSTEM_TRAY_MESSAGE_CLICKED = ...
_tray_icon_error = ...
_tray_icon_success = ...
_tray_icon_halt = ...
_tray_icon_notallowed = ...
_tray_icon_stop = ...
_tray_icon_exclamation = ...
_tray_icon_none = ...
SYSTEM_TRAY_MESSAGE_ICON_INFORMATION = ...
SYSTEM_TRAY_MESSAGE_ICON_WARNING = ...
SYSTEM_TRAY_MESSAGE_ICON_CRITICAL = ...
SYSTEM_TRAY_MESSAGE_ICON_NOICON = ...
class SystemTray:
    """
    A "Simulated System Tray" that duplicates the API calls available to PySimpleGUIWx and PySimpleGUIQt users.

    All of the functionality works. The icon is displayed ABOVE the system tray rather than inside of it.
    """
    def __init__(self, menu=..., filename=..., data=..., data_base64=..., tooltip=..., metadata=...) -> None:
        """
        SystemTray - create an icon in the system tray
        :param menu:        Menu definition. Example - ['UNUSED', ['My', 'Simple', '---', 'Menu', 'Exit']]
        :type menu:         List[List[List[str] or str]]
        :param filename:    filename for icon
        :type filename:     (str)
        :param data:        in-ram image for icon (same as data_base64 parm)
        :type data:         (bytes)
        :param data_base64: base-64 data for icon
        :type data_base64:  (bytes)
        :param tooltip:     tooltip string
        :type tooltip:      (str)
        :param metadata:    User metadata that can be set to ANYTHING
        :type metadata:     (Any)
        """
        ...
    
    @property
    def metadata(self): # -> None:
        """
        Metadata is an SystemTray property that you can use at any time to hold any value
        :return: the current metadata value
        :rtype:  (Any)
        """
        ...
    
    @metadata.setter
    def metadata(self, value): # -> None:
        """
        Metadata is an SystemTray property that you can use at any time to hold any value
        :param value: Anything you want it to be
        :type value:  (Any)
        """
        ...
    
    def read(self, timeout=...): # -> str:
        """
        Reads the context menu
        :param timeout: Optional.  Any value other than None indicates a non-blocking read
        :type timeout:
        :return:
        :rtype:
        """
        ...
    
    def hide(self): # -> None:
        """
        Hides the icon
        """
        ...
    
    def un_hide(self): # -> None:
        """
        Restores a previously hidden icon
        """
        ...
    
    def show_message(self, title, message, filename=..., data=..., data_base64=..., messageicon=..., time=...): # -> str:
        """
        Shows a balloon above icon in system tray
        :param title:       Title shown in balloon
        :type title:        str
        :param message:     Message to be displayed
        :type message:      str
        :param filename:    Optional icon filename
        :type filename:     str
        :param data:        Optional in-ram icon
        :type data:         b''
        :param data_base64: Optional base64 icon
        :type data_base64:  b''
        :param time:        Amount of time to display message in milliseconds. If tuple, first item is fade in/out duration
        :type time:         int | (int, int)
        :return:            The event that happened during the display such as user clicked on message
        :rtype:             Any
        """
        ...
    
    def close(self): # -> None:
        """
        Close the system tray window
        """
        ...
    
    def update(self, menu=..., tooltip=..., filename=..., data=..., data_base64=...): # -> None:
        """
        Updates the menu, tooltip or icon
        :param menu:        menu defintion
        :type menu:         ???
        :param tooltip:     string representing tooltip
        :type tooltip:      ???
        :param filename:    icon filename
        :type filename:     ???
        :param data:        icon raw image
        :type data:         ???
        :param data_base64: icon base 64 image
        :type data_base64:  ???
        """
        ...
    
    @classmethod
    def notify(cls, title, message, icon=..., display_duration_in_ms=..., fade_in_duration=..., alpha=..., location=...): # -> str:
        """
        Displays a "notification window", usually in the bottom right corner of your display.  Has an icon, a title, and a message
        The window will slowly fade in and out if desired.  Clicking on the window will cause it to move through the end the current "phase". For example, if the window was fading in and it was clicked, then it would immediately stop fading in and instead be fully visible.  It's a way for the user to quickly dismiss the window.
        :param title:                  Text to be shown at the top of the window in a larger font
        :type title:                   (str)
        :param message:                Text message that makes up the majority of the window
        :type message:                 (str)
        :param icon:                   A base64 encoded PNG/GIF image or PNG/GIF filename that will be displayed in the window
        :type icon:                    bytes | str
        :param display_duration_in_ms: Number of milliseconds to show the window
        :type display_duration_in_ms:  (int)
        :param fade_in_duration:       Number of milliseconds to fade window in and out
        :type fade_in_duration:        (int)
        :param alpha:                  Alpha channel. 0 - invisible 1 - fully visible
        :type alpha:                   (float)
        :param location:               Location on the screen to display the window
        :type location:                (int, int)
        :return:                       (int) reason for returning
        :rtype:                        (int)
        """
        ...
    
    Close = ...
    Hide = ...
    Read = ...
    ShowMessage = ...
    UnHide = ...
    Update = ...


def Sizer(h_pixels=..., v_pixels=...): # -> Column:
    """
    "Pushes" out the size of whatever it is placed inside of.  This includes Columns, Frames, Tabs and Windows

    :param h_pixels: number of horizontal pixels
    :type h_pixels:  (int)
    :param v_pixels: number of vertical pixels
    :type v_pixels:  (int)
    :return:         (Column) A column element that has a pad setting set according to parameters
    :rtype:          (Column)
    """
    ...

def pin(elem, vertical_alignment=..., shrink=..., expand_x=..., expand_y=...): # -> Column:
    """
    Pin's an element provided into a layout so that when it's made invisible and visible again, it will
     be in the correct place.  Otherwise it will be placed at the end of its containing window/column.

    :param elem:               the element to put into the layout
    :type elem:                Element
    :param vertical_alignment: Aligns elements vertically. 'top', 'center', 'bottom'. Can be shortened to 't', 'c', 'b'
    :type vertical_alignment:  str | None
    :param shrink:             If True, then the space will shrink down to a single pixel when hidden. False leaves the area large and blank
    :type shrink:              bool
    :param expand_x:           If True/False the value will be passed to the Column Elements used to make this feature
    :type expand_x:            (bool)
    :param expand_y:           If True/False the value will be passed to the Column Elements used to make this feature
    :type expand_y:            (bool)
    :return:                   A column element containing the provided element
    :rtype:                    Column
    """
    ...

def vtop(elem_or_row, expand_x=..., expand_y=...): # -> list[Column] | Column:
    """
    Align an element or a row of elements to the top of the row that contains it

    :param elem_or_row: the element or row of elements
    :type elem_or_row:  Element | List[Element] | Tuple[Element]
    :param expand_x:    If True/False the value will be passed to the Column Elements used to make this feature
    :type expand_x:     (bool)
    :param expand_y:    If True/False the value will be passed to the Column Elements used to make this feature
    :type expand_y:     (bool)
    :return:            A column element containing the provided element aligned to the top or list of elements (a row)
    :rtype:             Column | List[Column]
    """
    ...

def vcenter(elem_or_row, expand_x=..., expand_y=...): # -> list[Column] | Column:
    """
    Align an element or a row of elements to the center of the row that contains it

    :param elem_or_row: the element or row of elements
    :type elem_or_row:  Element | List[Element] | Tuple[Element]
    :param expand_x:    If True/False the value will be passed to the Column Elements used to make this feature
    :type expand_x:     (bool)
    :param expand_y:    If True/False the value will be passed to the Column Elements used to make this feature
    :type expand_y:     (bool)
    :return:            A column element containing the provided element aligned to the center or list of elements (a row)
    :rtype:             Column | List[Column]
    """
    ...

def vbottom(elem_or_row, expand_x=..., expand_y=...): # -> list[Column] | Column:
    """
    Align an element or a row of elements to the bottom of the row that contains it

    :param elem_or_row: the element or row of elements
    :type elem_or_row:  Element | List[Element] | Tuple[Element]
    :param expand_x:    If True/False the value will be passed to the Column Elements used to make this feature
    :type expand_x:     (bool)
    :param expand_y:    If True/False the value will be passed to the Column Elements used to make this feature
    :type expand_y:     (bool)
    :return:            A column element containing the provided element aligned to the bottom or list of elements (a row)
    :rtype:             Column | List[Column]
    """
    ...

def Titlebar(title=..., icon=..., text_color=..., background_color=..., font=..., key=..., k=...): # -> Column:
    """
    A custom titlebar that replaces the OS provided titlebar, thus giving you control
    the is not possible using the OS provided titlebar such as the color.

    NOTE LINUX USERS - at the moment the minimize function is not yet working.  Windows users
    should have no problem and it should function as a normal window would.

    This titlebar is created from a row of elements that is then encapsulated into a
    one Column element which is what this Titlebar function returns to you.

    A custom titlebar removes the margins from your window.  If you want the  remainder
    of your Window to have margins, place the layout after the Titlebar into a Column and
    set the pad of that Column to the dimensions you would like your margins to have.

    The Titlebar is a COLUMN element.  You can thus call the update method for the column and
    perform operations such as making the column visible/invisible

    :param icon:             Can be either a filename or Base64 byte string of a PNG or GIF. This is used in an Image element to create the titlebar
    :type icon:              str or bytes or None
    :param title:            The "title" to show in the titlebar
    :type title:             str
    :param text_color:       Text color for titlebar
    :type text_color:        str | None
    :param background_color: Background color for titlebar
    :type background_color:  str | None
    :param font:             Font to be used for the text and the symbols
    :type font:              (str or (str, int[, str]) or None)
    :param key:              Identifies an Element. Should be UNIQUE to this window.
    :type key:               str | int | tuple | object | None
    :param k:                Exactly the same as key.  Choose one of them to use
    :type k:                 str | int | tuple | object | None
    :return:                 A single Column element that has eveything in 1 element
    :rtype:                  Column
    """
    ...

def MenubarCustom(menu_definition, disabled_text_color=..., bar_font=..., font=..., tearoff=..., pad=..., p=..., background_color=..., text_color=..., bar_background_color=..., bar_text_color=..., key=..., k=...): # -> Column:
    """
    A custom Menubar that replaces the OS provided Menubar

    Why?
    Two reasons - 1. they look great (see custom titlebar) 2. if you have a custom titlebar, then you have to use a custom menubar if you want a menubar

    :param menu_definition:      The Menu definition specified using lists (docs explain the format)
    :type menu_definition:       List[List[Tuple[str, List[str]]]
    :param disabled_text_color:  color to use for text when item is disabled. Can be in #RRGGBB format or a color name "black"
    :type disabled_text_color:   (str)
    :param bar_font:             specifies the font family, size to be used for the chars in the bar itself
    :type bar_font:              (str or (str, int[, str]) or None)
    :param font:                 specifies the font family, size to be used for the menu items
    :type font:                  (str or (str, int[, str]) or None)
    :param tearoff:              if True, then can tear the menu off from the window ans use as a floating window. Very cool effect
    :type tearoff:               (bool)
    :param pad:                  Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int).  TIP - 0 will make flush with titlebar
    :type pad:                   (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param p:                    Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
    :type p:                     (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param background_color:     color to use for background of the menus that are displayed after making a section. Can be in #RRGGBB format or a color name "black". Defaults to the color of the bar text
    :type background_color:      (str)
    :param text_color:           color to use for the text of the many items in the displayed menus. Can be in #RRGGBB format or a color name "black". Defaults to the bar background
    :type text_color:            (str)
    :param bar_background_color: color to use for the menubar. Can be in #RRGGBB format or a color name "black". Defaults to theme's button text color
    :type bar_background_color:  (str)
    :param bar_text_color:       color to use for the menu items text when item is disabled. Can be in #RRGGBB format or a color name "black". Defaults to theme's button background color
    :type bar_text_color:        (str)
    :param key:                  Value that uniquely identifies this element from all other elements. Used when Finding an element or in return values. Must be unique to the window
    :type key:                   str | int | tuple | object
    :param k:                    Same as the Key. You can use either k or key. Which ever is set will be used.
    :type k:                     str | int | tuple | object
    :returns:                    A Column element that has a series of ButtonMenu elements
    :rtype:                      Column
    """
    ...

def FolderBrowse(button_text=..., target=..., initial_folder=..., tooltip=..., size=..., s=..., auto_size_button=..., button_color=..., disabled=..., change_submits=..., enable_events=..., font=..., pad=..., p=..., key=..., k=..., visible=..., metadata=...): # -> Button:
    """
    :param button_text:      text in the button (Default value = 'Browse')
    :type button_text:       (str)
    :param target:           target for the button (Default value = (ThisRow, -1))
    :type target:            str | (int, int)
    :param initial_folder:   starting path for folders and files
    :type initial_folder:    (str)
    :param tooltip:          text, that will appear when mouse hovers over the element
    :type tooltip:           (str)
    :param size:             (w,h) w=characters-wide, h=rows-high
    :type size:              (int, int)
    :param s:                Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
    :type s:                 (int, int)  | (None, None) | int
    :param auto_size_button: True if button size is determined by button text
    :type auto_size_button:  (bool)
    :param button_color:     button color (foreground, background)
    :type button_color:
    :param disabled:         set disable state for element (Default = False)
    :type disabled:          (bool)
    :param change_submits:   If True, pressing Enter key submits window (Default = False)
    :type enable_events:     (bool)
    :param enable_events:    Turns on the element specific events.(Default = False)
    :type enable_events:     (bool)
    :param font:             specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:              (str or (str, int[, str]) or None)
    :param pad:              Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
    :type pad:               (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param p:                Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
    :type p:                 (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param key:              Used with window.find_element and with return values to uniquely identify this element
    :type key:               str | int | tuple | object
    :param k:                Same as the Key. You can use either k or key. Which ever is set will be used.
    :type k:                 str | int | tuple | object
    :param visible:          set initial visibility state of the Button
    :type visible:           (bool)
    :param metadata:         Anything you want to store along with this button
    :type metadata:          (Any)
    :return:                 The Button created
    :rtype:                  (Button)
    """
    ...

def FileBrowse(button_text=..., target=..., file_types=..., initial_folder=..., tooltip=..., size=..., s=..., auto_size_button=..., button_color=..., change_submits=..., enable_events=..., font=..., disabled=..., pad=..., p=..., key=..., k=..., visible=..., metadata=...): # -> Button:
    """

    :param button_text:      text in the button (Default value = 'Browse')
    :type button_text:       (str)
    :param target:           key or (row,col) target for the button (Default value = (ThisRow, -1))
    :type target:            str | (int, int)
    :param file_types:       filter file types Default value = (("ALL Files", "*.* *"),). NOT avoilable on the MAC
    :type file_types:        Tuple[(str, str), ...]
    :param initial_folder:   starting path for folders and files
    :type initial_folder:
    :param tooltip:          text, that will appear when mouse hovers over the element
    :type tooltip:           (str)
    :param size:             (w,h) w=characters-wide, h=rows-high
    :type size:              (int, int)
    :param s:                Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
    :type s:                 (int, int)  | (None, None) | int
    :param auto_size_button: True if button size is determined by button text
    :type auto_size_button:  (bool)
    :param button_color:     button color (foreground, background)
    :type button_color:      (str, str) or str
    :param change_submits:   If True, pressing Enter key submits window (Default = False)
    :type change_submits:    (bool)
    :param enable_events:    Turns on the element specific events.(Default = False)
    :type enable_events:     (bool)
    :param font:             specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:              (str or (str, int[, str]) or None)
    :param disabled:         set disable state for element (Default = False)
    :type disabled:          (bool)
    :param pad:              Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
    :type pad:               (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param p:                Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
    :type p:                 (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param key:              key for uniquely identify this element (for window.find_element)
    :type key:               str | int | tuple | object
    :param k:                Same as the Key. You can use either k or key. Which ever is set will be used.
    :type k:                 str | int | tuple | object
    :param visible:          set initial visibility state of the Button
    :type visible:           (bool)
    :param metadata:         Anything you want to store along with this button
    :type metadata:          (Any)
    :return:                 returns a button
    :rtype:                  (Button)
    """
    ...

def FilesBrowse(button_text=..., target=..., file_types=..., disabled=..., initial_folder=..., tooltip=..., size=..., s=..., auto_size_button=..., button_color=..., change_submits=..., enable_events=..., font=..., pad=..., p=..., key=..., k=..., visible=..., files_delimiter=..., metadata=...): # -> Button:
    """
    Allows browsing of multiple files. File list is returned as a single list with the delimiter defined using the files_delimiter parameter.

    :param button_text:      text in the button (Default value = 'Browse')
    :type button_text:       (str)
    :param target:           key or (row,col) target for the button (Default value = (ThisRow, -1))
    :type target:            str | (int, int)
    :param file_types:       Default value = (("ALL Files", "*.* *"),). NOT avoilable on the MAC
    :type file_types:        Tuple[(str, str), ...]
    :param disabled:         set disable state for element (Default = False)
    :type disabled:          (bool)
    :param initial_folder:   starting path for folders and files
    :type initial_folder:    (str)
    :param tooltip:          text, that will appear when mouse hovers over the element
    :type tooltip:           (str)
    :param size:             (w,h) w=characters-wide, h=rows-high
    :type size:              (int, int)
    :param s:                Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
    :type s:                 (int, int)  | (None, None) | int
    :param auto_size_button: True if button size is determined by button text
    :type auto_size_button:  (bool)
    :param button_color:     button color (foreground, background)
    :type button_color:      (str, str) or str
    :param change_submits:   If True, pressing Enter key submits window (Default = False)
    :type change_submits:    (bool)
    :param enable_events:    Turns on the element specific events.(Default = False)
    :type enable_events:     (bool)
    :param font:             specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:              (str or (str, int[, str]) or None)
    :param pad:              Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
    :type pad:               (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param p:                Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
    :type p:                 (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param key:              key for uniquely identify this element (for window.find_element)
    :type key:               str | int | tuple | object
    :param k:                Same as the Key. You can use either k or key. Which ever is set will be used.
    :type k:                 str | int | tuple | object
    :param visible:          set initial visibility state of the Button
    :type visible:           (bool)
    :param files_delimiter:  String to place between files when multiple files are selected. Normally a ;
    :type files_delimiter:   str
    :param metadata:         Anything you want to store along with this button
    :type metadata:          (Any)
    :return:                 returns a button
    :rtype:                  (Button)
    """
    ...

def FileSaveAs(button_text=..., target=..., file_types=..., initial_folder=..., default_extension=..., disabled=..., tooltip=..., size=..., s=..., auto_size_button=..., button_color=..., change_submits=..., enable_events=..., font=..., pad=..., p=..., key=..., k=..., visible=..., metadata=...): # -> Button:
    """

    :param button_text:       text in the button (Default value = 'Save As...')
    :type button_text:        (str)
    :param target:            key or (row,col) target for the button (Default value = (ThisRow, -1))
    :type target:             str | (int, int)
    :param file_types:        Default value = (("ALL Files", "*.* *"),). NOT avoilable on the MAC
    :type file_types:         Tuple[(str, str), ...]
    :param default_extension: If no extension entered by user, add this to filename (only used in saveas dialogs)
    :type default_extension:  (str)
    :param initial_folder:    starting path for folders and files
    :type initial_folder:     (str)
    :param disabled:          set disable state for element (Default = False)
    :type disabled:           (bool)
    :param tooltip:           text, that will appear when mouse hovers over the element
    :type tooltip:            (str)
    :param size:              (w,h) w=characters-wide, h=rows-high
    :type size:               (int, int)
    :param s:                 Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
    :type s:                  (int, int)  | (None, None) | int
    :param auto_size_button:  True if button size is determined by button text
    :type auto_size_button:   (bool)
    :param button_color:      button color (foreground, background)
    :type button_color:       (str, str) or str
    :param change_submits:    If True, pressing Enter key submits window (Default = False)
    :type change_submits:     (bool)
    :param enable_events:     Turns on the element specific events.(Default = False)
    :type enable_events:      (bool)
    :param font:              specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:               (str or (str, int[, str]) or None)
    :param pad:               Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
    :type pad:                (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param p:                 Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
    :type p:                  (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param key:               key for uniquely identify this element (for window.find_element)
    :type key:                str | int | tuple | object
    :param k:                 Same as the Key. You can use either k or key. Which ever is set will be used.
    :type k:                  str | int | tuple | object
    :param visible:           set initial visibility state of the Button
    :type visible:            (bool)
    :param metadata:          Anything you want to store along with this button
    :type metadata:           (Any)
    :return:                  returns a button
    :rtype:                   (Button)
    """
    ...

def SaveAs(button_text=..., target=..., file_types=..., initial_folder=..., default_extension=..., disabled=..., tooltip=..., size=..., s=..., auto_size_button=..., button_color=..., change_submits=..., enable_events=..., font=..., pad=..., p=..., key=..., k=..., visible=..., metadata=...): # -> Button:
    """

    :param button_text:       text in the button (Default value = 'Save As...')
    :type button_text:        (str)
    :param target:            key or (row,col) target for the button (Default value = (ThisRow, -1))
    :type target:             str | (int, int)
    :param file_types:        Default value = (("ALL Files", "*.* *"),). NOT avoilable on the MAC
    :type file_types:         Tuple[(str, str), ...]
    :param default_extension: If no extension entered by user, add this to filename (only used in saveas dialogs)
    :type default_extension:  (str)
    :param initial_folder:    starting path for folders and files
    :type initial_folder:     (str)
    :param disabled:          set disable state for element (Default = False)
    :type disabled:           (bool)
    :param tooltip:           text, that will appear when mouse hovers over the element
    :type tooltip:            (str)
    :param size:              (w,h) w=characters-wide, h=rows-high
    :type size:               (int, int)
    :param s:                 Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
    :type s:                  (int, int)  | (None, None) | int
    :param auto_size_button:  True if button size is determined by button text
    :type auto_size_button:   (bool)
    :param button_color:      button color (foreground, background)
    :type button_color:       (str, str) or str
    :param change_submits:    If True, pressing Enter key submits window (Default = False)
    :type change_submits:     (bool)
    :param enable_events:     Turns on the element specific events.(Default = False)
    :type enable_events:      (bool)
    :param font:              specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:               (str or (str, int[, str]) or None)
    :param pad:               Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
    :type pad:                (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param p:                 Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
    :type p:                  (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int    :param key:               key for uniquely identify this element (for window.find_element)
    :type key:                str | int | tuple | object
    :param k:                 Same as the Key. You can use either k or key. Which ever is set will be used.
    :type k:                  str | int | tuple | object
    :param visible:           set initial visibility state of the Button
    :type visible:            (bool)
    :param metadata:          Anything you want to store along with this button
    :type metadata:           (Any)
    :return:                  returns a button
    :rtype:                   (Button)
    """
    ...

def Save(button_text=..., size=..., s=..., auto_size_button=..., button_color=..., bind_return_key=..., disabled=..., tooltip=..., font=..., focus=..., pad=..., p=..., key=..., k=..., visible=..., metadata=...): # -> Button:
    """

    :param button_text:      text in the button (Default value = 'Save')
    :type button_text:       (str)
    :param size:             (w,h) w=characters-wide, h=rows-high
    :type size:              (int, int)
    :param s:                Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
    :type s:                 (int, int)  | (None, None) | int
    :param auto_size_button: True if button size is determined by button text
    :type auto_size_button:  (bool)
    :param button_color:     button color (foreground, background)
    :type button_color:      (str, str) or str
    :param bind_return_key:  (Default = True) If True, then the return key will cause a the Listbox to generate an event
    :type bind_return_key:   (bool)
    :param disabled:         set disable state for element (Default = False)
    :type disabled:          (bool)
    :param tooltip:          text, that will appear when mouse hovers over the element
    :type tooltip:           (str)
    :param font:             specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:              (str or (str, int[, str]) or None)
    :param focus:            if focus should be set to this
    :type focus:             idk_yetReally
    :param pad:              Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
    :type pad:               (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param p:                Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
    :type p:                 (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param key:              key for uniquely identify this element (for window.find_element)
    :type key:               str | int | tuple | object
    :param k:                Same as the Key. You can use either k or key. Which ever is set will be used.
    :type k:                 str | int | tuple | object
    :param visible:          set initial visibility state of the Button
    :type visible:           (bool)
    :param metadata:         Anything you want to store along with this button
    :type metadata:          (Any)
    :return:                 returns a button
    :rtype:                  (Button)
    """
    ...

def Submit(button_text=..., size=..., s=..., auto_size_button=..., button_color=..., disabled=..., bind_return_key=..., tooltip=..., font=..., focus=..., pad=..., p=..., key=..., k=..., visible=..., metadata=...): # -> Button:
    """

    :param button_text:      text in the button (Default value = 'Submit')
    :type button_text:       (str)
    :param size:             (w,h) w=characters-wide, h=rows-high
    :type size:              (int, int)
    :param s:                Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
    :type s:                 (int, int)  | (None, None) | int
    :param auto_size_button: True if button size is determined by button text
    :type auto_size_button:  (bool)
    :param button_color:     button color (foreground, background)
    :type button_color:      (str, str) or str
    :param disabled:         set disable state for element (Default = False)
    :type disabled:          (bool)
    :param bind_return_key:  (Default = True) If True, then the return key will cause a the Listbox to generate an event
    :type bind_return_key:   (bool)
    :param tooltip:          text, that will appear when mouse hovers over the element
    :type tooltip:           (str)
    :param font:             specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:              (str or (str, int[, str]) or None)
    :param focus:            if focus should be set to this
    :type focus:             idk_yetReally
    :param pad:              Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
    :type pad:               (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param p:                Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
    :type p:                 (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param key:              key for uniquely identify this element (for window.find_element)
    :type key:               str | int | tuple | object
    :param k:                Same as the Key. You can use either k or key. Which ever is set will be used.
    :type k:                 str | int | tuple | object
    :param visible:          set initial visibility state of the Button
    :type visible:           (bool)
    :param metadata:         Anything you want to store along with this button
    :type metadata:          (Any)
    :return:                 returns a button
    :rtype:                  (Button)
    """
    ...

def Open(button_text=..., size=..., s=..., auto_size_button=..., button_color=..., disabled=..., bind_return_key=..., tooltip=..., font=..., focus=..., pad=..., p=..., key=..., k=..., visible=..., metadata=...): # -> Button:
    """

    :param button_text:      text in the button (Default value = 'Open')
    :type button_text:       (str)
    :param size:             (w,h) w=characters-wide, h=rows-high
    :type size:              (int, int)
    :param s:                Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
    :type s:                 (int, int)  | (None, None) | int
    :param auto_size_button: True if button size is determined by button text
    :type auto_size_button:  (bool)
    :param button_color:     button color (foreground, background)
    :type button_color:      (str, str) or str
    :param disabled:         set disable state for element (Default = False)
    :type disabled:          (bool)
    :param bind_return_key:  (Default = True) If True, then the return key will cause a the Listbox to generate an event
    :type bind_return_key:   (bool)
    :param tooltip:          text, that will appear when mouse hovers over the element
    :type tooltip:           (str)
    :param font:             specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:              (str or (str, int[, str]) or None)
    :param focus:            if focus should be set to this
    :type focus:             idk_yetReally
    :param pad:              Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
    :type pad:               (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param p:                Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
    :type p:                 (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param key:              key for uniquely identify this element (for window.find_element)
    :type key:               str | int | tuple | object
    :param k:                Same as the Key. You can use either k or key. Which ever is set will be used.
    :type k:                 str | int | tuple | object
    :param visible:          set initial visibility state of the Button
    :type visible:           (bool)
    :param metadata:         Anything you want to store along with this button
    :type metadata:          (Any)
    :return:                 returns a button
    :rtype:                  (Button)
    """
    ...

def OK(button_text=..., size=..., s=..., auto_size_button=..., button_color=..., disabled=..., bind_return_key=..., tooltip=..., font=..., focus=..., pad=..., p=..., key=..., k=..., visible=..., metadata=...): # -> Button:
    """

    :param button_text:      text in the button (Default value = 'OK')
    :type button_text:       (str)
    :param size:             (w,h) w=characters-wide, h=rows-high
    :type size:              (int, int)
    :param s:                Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
    :type s:                 (int, int)  | (None, None) | int
    :param auto_size_button: True if button size is determined by button text
    :type auto_size_button:  (bool)
    :param button_color:     button color (foreground, background)
    :type button_color:      (str, str) or str
    :param disabled:         set disable state for element (Default = False)
    :type disabled:          (bool)
    :param bind_return_key:  (Default = True) If True, then the return key will cause a the Listbox to generate an event
    :type bind_return_key:   (bool)
    :param tooltip:          text, that will appear when mouse hovers over the element
    :type tooltip:           (str)
    :param font:             specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:              (str or (str, int[, str]) or None)
    :param focus:            if focus should be set to this
    :type focus:             idk_yetReally
    :param pad:              Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
    :type pad:               (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param p:                Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
    :type p:                 (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param key:              key for uniquely identify this element (for window.find_element)
    :type key:               str | int | tuple | object
    :param k:                Same as the Key. You can use either k or key. Which ever is set will be used.
    :type k:                 str | int | tuple | object
    :param visible:          set initial visibility state of the Button
    :type visible:           (bool)
    :param metadata:         Anything you want to store along with this button
    :type metadata:          (Any)
    :return:                 returns a button
    :rtype:                  (Button)
    """
    ...

def Ok(button_text=..., size=..., s=..., auto_size_button=..., button_color=..., disabled=..., bind_return_key=..., tooltip=..., font=..., focus=..., pad=..., p=..., key=..., k=..., visible=..., metadata=...): # -> Button:
    """

    :param button_text:      text in the button (Default value = 'Ok')
    :type button_text:       (str)
    :param size:             (w,h) w=characters-wide, h=rows-high
    :type size:              (int, int)
    :param s:                Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
    :type s:                 (int, int)  | (None, None) | int
    :param auto_size_button: True if button size is determined by button text
    :type auto_size_button:  (bool)
    :param button_color:     button color (foreground, background)
    :type button_color:      (str, str) or str
    :param disabled:         set disable state for element (Default = False)
    :type disabled:          (bool)
    :param bind_return_key:  (Default = True) If True, then the return key will cause a the Listbox to generate an event
    :type bind_return_key:   (bool)
    :param tooltip:          text, that will appear when mouse hovers over the element
    :type tooltip:           (str)
    :param font:             specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:              (str or (str, int[, str]) or None)
    :param focus:            if focus should be set to this
    :type focus:             idk_yetReally
    :param pad:              Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
    :type pad:               (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param p:                Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
    :type p:                 (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param key:              key for uniquely identify this element (for window.find_element)
    :type key:               str | int | tuple | object
    :param k:                Same as the Key. You can use either k or key. Which ever is set will be used.
    :type k:                 str | int | tuple | object
    :param visible:          set initial visibility state of the Button
    :type visible:           (bool)
    :param metadata:         Anything you want to store along with this button
    :type metadata:          (Any)
    :return:                 returns a button
    :rtype:                  (Button)
    """
    ...

def Cancel(button_text=..., size=..., s=..., auto_size_button=..., button_color=..., disabled=..., tooltip=..., font=..., bind_return_key=..., focus=..., pad=..., p=..., key=..., k=..., visible=..., metadata=...): # -> Button:
    """

    :param button_text:      text in the button (Default value = 'Cancel')
    :type button_text:       (str)
    :param size:             (w,h) w=characters-wide, h=rows-high
    :type size:              (int, int)
    :param s:                Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
    :type s:                 (int, int)  | (None, None) | int
    :param auto_size_button: True if button size is determined by button text
    :type auto_size_button:  (bool)
    :param button_color:     button color (foreground, background)
    :type button_color:      (str, str) or str
    :param disabled:         set disable state for element (Default = False)
    :type disabled:          (bool)
    :param tooltip:          text, that will appear when mouse hovers over the element
    :type tooltip:           (str)
    :param font:             specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:              (str or (str, int[, str]) or None)
    :param bind_return_key:  (Default = False) If True, then the return key will cause a the Listbox to generate an event
    :type bind_return_key:   (bool)
    :param focus:            if focus should be set to this
    :type focus:
    :param pad:              Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
    :type pad:               (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param p:                Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
    :type p:                 (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param key:              key for uniquely identify this element (for window.find_element)
    :type key:               str | int | tuple | object
    :param k:                Same as the Key. You can use either k or key. Which ever is set will be used.
    :type k:                 str | int | tuple | object
    :param visible:          set initial visibility state of the Button
    :type visible:           (bool)
    :param metadata:         Anything you want to store along with this button
    :type metadata:          (Any)
    :return:                 returns a button
    :rtype:                  (Button)
    """
    ...

def Quit(button_text=..., size=..., s=..., auto_size_button=..., button_color=..., disabled=..., tooltip=..., font=..., bind_return_key=..., focus=..., pad=..., p=..., key=..., k=..., visible=..., metadata=...): # -> Button:
    """

    :param button_text:      text in the button (Default value = 'Quit')
    :type button_text:       (str)
    :param size:             (w,h) w=characters-wide, h=rows-high
    :type size:              (int, int)
    :param s:                Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
    :type s:                 (int, int)  | (None, None) | int
    :param auto_size_button: True if button size is determined by button text
    :type auto_size_button:  (bool)
    :param button_color:     button color (foreground, background)
    :type button_color:      (str, str) or str
    :param disabled:         set disable state for element (Default = False)
    :type disabled:          (bool)
    :param tooltip:          text, that will appear when mouse hovers over the element
    :type tooltip:           (str)
    :param font:             specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:              (str or (str, int[, str]) or None)
    :param bind_return_key:  (Default = False) If True, then the return key will cause a the Listbox to generate an event
    :type bind_return_key:   (bool)
    :param focus:            if focus should be set to this
    :type focus:             (bool)
    :param pad:              Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
    :type pad:               (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param p:                Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
    :type p:                 (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param key:              key for uniquely identify this element (for window.find_element)
    :type key:               str | int | tuple | object
    :param k:                Same as the Key. You can use either k or key. Which ever is set will be used.
    :type k:                 str | int | tuple | object
    :param visible:          set initial visibility state of the Button
    :type visible:           (bool)
    :param metadata:         Anything you want to store along with this button
    :type metadata:          (Any)
    :return:                 returns a button
    :rtype:                  (Button)
    """
    ...

def Exit(button_text=..., size=..., s=..., auto_size_button=..., button_color=..., disabled=..., tooltip=..., font=..., bind_return_key=..., focus=..., pad=..., p=..., key=..., k=..., visible=..., metadata=...): # -> Button:
    """

    :param button_text:      text in the button (Default value = 'Exit')
    :type button_text:       (str)
    :param size:             (w,h) w=characters-wide, h=rows-high
    :type size:              (int, int)
    :param s:                Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
    :type s:                 (int, int)  | (None, None) | int
    :param auto_size_button: True if button size is determined by button text
    :type auto_size_button:  (bool)
    :param button_color:     button color (foreground, background)
    :type button_color:      (str, str) or str
    :param disabled:         set disable state for element (Default = False)
    :type disabled:          (bool)
    :param tooltip:          text, that will appear when mouse hovers over the element
    :type tooltip:           (str)
    :param font:             specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:              (str or (str, int[, str]) or None)
    :param bind_return_key:  (Default = False) If True, then the return key will cause a the Listbox to generate an event
    :type bind_return_key:   (bool)
    :param focus:            if focus should be set to this
    :type focus:
    :param pad:              Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
    :type pad:               (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param p:                Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
    :type p:                 (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param key:              key for uniquely identify this element (for window.find_element)
    :type key:               str | int | tuple | object
    :param k:                Same as the Key. You can use either k or key. Which ever is set will be used.
    :type k:                 str | int | tuple | object
    :param visible:          set initial visibility state of the Button
    :type visible:           (bool)
    :param metadata:         Anything you want to store along with this button
    :type metadata:          (Any)
    :return:                 returns a button
    :rtype:                  (Button)
    """
    ...

def Yes(button_text=..., size=..., s=..., auto_size_button=..., button_color=..., disabled=..., tooltip=..., font=..., bind_return_key=..., focus=..., pad=..., p=..., key=..., k=..., visible=..., metadata=...): # -> Button:
    """

    :param button_text:      text in the button (Default value = 'Yes')
    :type button_text:       (str)
    :param size:             (w,h) w=characters-wide, h=rows-high
    :type size:              (int, int)
    :param s:                Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
    :type s:                 (int, int)  | (None, None) | int
    :param auto_size_button: True if button size is determined by button text
    :type auto_size_button:  (bool)
    :param button_color:     button color (foreground, background)
    :type button_color:      (str, str) or str
    :param disabled:         set disable state for element (Default = False)
    :type disabled:          (bool)
    :param tooltip:          text, that will appear when mouse hovers over the element
    :type tooltip:           (str)
    :param font:             specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:              (str or (str, int[, str]) or None)
    :param bind_return_key:  (Default = True) If True, then the return key will cause a the Listbox to generate an event
    :type bind_return_key:   (bool)
    :param focus:            if focus should be set to this
    :type focus:
    :param pad:              Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
    :type pad:               (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param p:                Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
    :type p:                 (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param key:              key for uniquely identify this element (for window.find_element)
    :type key:               str | int | tuple | object
    :param k:                Same as the Key. You can use either k or key. Which ever is set will be used.
    :type k:                 str | int | tuple | object
    :param visible:          set initial visibility state of the Button
    :type visible:           (bool)
    :param metadata:         Anything you want to store along with this button
    :type metadata:          (Any)
    :return:                 returns a button
    :rtype:                  (Button)
    """
    ...

def No(button_text=..., size=..., s=..., auto_size_button=..., button_color=..., disabled=..., tooltip=..., font=..., bind_return_key=..., focus=..., pad=..., p=..., key=..., k=..., visible=..., metadata=...): # -> Button:
    """

    :param button_text:      text in the button (Default value = 'No')
    :type button_text:       (str)
    :param size:             (w,h) w=characters-wide, h=rows-high
    :type size:              (int, int)
    :param s:                Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
    :type s:                 (int, int)  | (None, None) | int
    :param auto_size_button: True if button size is determined by button text
    :type auto_size_button:  (bool)
    :param button_color:     button color (foreground, background)
    :type button_color:      (str, str) or str
    :param disabled:         set disable state for element (Default = False)
    :type disabled:          (bool)
    :param tooltip:          text, that will appear when mouse hovers over the element
    :type tooltip:           (str)
    :param font:             specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:              (str or (str, int[, str]) or None)
    :param bind_return_key:  (Default = False) If True, then the return key will cause a the Listbox to generate an event
    :type bind_return_key:   (bool)
    :param focus:            if focus should be set to this
    :type focus:
    :param pad:              Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
    :type pad:               (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param p:                Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
    :type p:                 (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param key:              key for uniquely identify this element (for window.find_element)
    :type key:               str | int | tuple | object
    :param k:                Same as the Key. You can use either k or key. Which ever is set will be used.
    :type k:                 str | int | tuple | object
    :param visible:          set initial visibility state of the Button
    :type visible:           (bool)
    :param metadata:         Anything you want to store along with this button
    :type metadata:          (Any)
    :return:                 returns a button
    :rtype:                  (Button)
    """
    ...

def Help(button_text=..., size=..., s=..., auto_size_button=..., button_color=..., disabled=..., font=..., tooltip=..., bind_return_key=..., focus=..., pad=..., p=..., key=..., k=..., visible=..., metadata=...): # -> Button:
    """

    :param button_text:      text in the button (Default value = 'Help')
    :type button_text:       (str)
    :param size:             (w,h) w=characters-wide, h=rows-high
    :type size:              (int, int)
    :param s:                Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
    :type s:                 (int, int)  | (None, None) | int
    :param auto_size_button: True if button size is determined by button text
    :type auto_size_button:  (bool)
    :param button_color:     button color (foreground, background)
    :type button_color:      (str, str) or str
    :param disabled:         set disable state for element (Default = False)
    :type disabled:          (bool)
    :param font:             specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:              (str or (str, int[, str]) or None)
    :param tooltip:          text, that will appear when mouse hovers over the element
    :type tooltip:           (str)
    :param bind_return_key:  (Default = False) If True, then the return key will cause a the Listbox to generate an event
    :type bind_return_key:   (bool)
    :param focus:            if focus should be set to this
    :type focus:
    :param pad:              Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
    :type pad:               (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param p:                Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
    :type p:                 (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param key:              key for uniquely identify this element (for window.find_element)
    :type key:               str | int | tuple | object
    :param k:                Same as the Key. You can use either k or key. Which ever is set will be used.
    :type k:                 str | int | tuple | object
    :param visible:          set initial visibility state of the Button
    :type visible:           (bool)
    :param metadata:         Anything you want to store along with this button
    :type metadata:          (Any)
    :return:                 returns a button
    :rtype:                  (Button)
    """
    ...

def Debug(button_text=..., size=..., s=..., auto_size_button=..., button_color=..., disabled=..., font=..., tooltip=..., bind_return_key=..., focus=..., pad=..., p=..., key=..., k=..., visible=..., metadata=...): # -> Button:
    """
    This Button has been changed in how it works!!
    Your button has been replaced with a normal button that has the PySimpleGUI Debugger buggon logo on it.
    In your event loop, you will need to check for the event of this button and then call:
            show_debugger_popout_window()
    :param button_text:      text in the button (Default value = '')
    :type button_text:       (str)
    :param size:             (w,h) w=characters-wide, h=rows-high
    :type size:              (int, int)
    :param s:                Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
    :type s:                 (int, int)  | (None, None) | int
    :param auto_size_button: True if button size is determined by button text
    :type auto_size_button:  (bool)
    :param button_color:     button color (foreground, background)
    :type button_color:      (str, str) or str
    :param disabled:         set disable state for element (Default = False)
    :type disabled:          (bool)
    :param font:             specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:              (str or (str, int[, str]) or None)
    :param tooltip:          text, that will appear when mouse hovers over the element
    :type tooltip:           (str)
    :param bind_return_key:  (Default = False) If True, then the return key will cause a the Listbox to generate an event
    :type bind_return_key:   (bool)
    :param focus:            if focus should be set to this
    :type focus:
    :param pad:              Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
    :type pad:               (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param p:                Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
    :type p:                 (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param key:              key for uniquely identify this element (for window.find_element)
    :type key:               str | int | tuple | object
    :param k:                Same as the Key. You can use either k or key. Which ever is set will be used.
    :type k:                 str | int | tuple | object
    :param visible:          set initial visibility state of the Button
    :type visible:           (bool)
    :param metadata:         Anything you want to store along with this button
    :type metadata:          (Any)
    :return:                 returns a button
    :rtype:                  (Button)
    """
    ...

def SimpleButton(button_text, image_filename=..., image_data=..., image_size=..., image_subsample=..., border_width=..., tooltip=..., size=..., s=..., auto_size_button=..., button_color=..., font=..., bind_return_key=..., disabled=..., focus=..., pad=..., p=..., key=..., k=..., metadata=...): # -> Button:
    """
    DEPIRCATED

    This Button should not be used.

    :param button_text:      text in the button
    :type button_text:       (str)
    :param image_filename:   image filename if there is a button image
    :type image_filename:    image filename if there is a button image
    :param image_data:       in-RAM image to be displayed on button
    :type image_data:        in-RAM image to be displayed on button
    :param image_size:       image size (O.K.)
    :type image_size:        (Default = (None))
    :param image_subsample:  amount to reduce the size of the image
    :type image_subsample:   amount to reduce the size of the image
    :param tooltip:          text, that will appear when mouse hovers over the element
    :type tooltip:           (str)
    :param size:             (w,h) w=characters-wide, h=rows-high
    :type size:              (int, int)
    :param s:                Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
    :type s:                 (int, int)  | (None, None) | int
    :param auto_size_button: True if button size is determined by button text
    :type auto_size_button:  (bool)
    :param button_color:     button color (foreground, background)
    :type button_color:      (str, str) or str
    :param font:             specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:              (str or (str, int[, str]) or None)
    :param bind_return_key:  (Default = False) If True, then the return key will cause a the Listbox to generate an event
    :type bind_return_key:   (bool)
    :param disabled:         set disable state for element (Default = False)
    :type disabled:          (bool)
    :param focus:            if focus should be set to this
    :type focus:             idk_yetReally
    :param pad:              Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
    :type pad:               (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param p:                Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
    :type p:                 (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param key:              key for uniquely identify this element (for window.find_element)
    :type key:               str | int | tuple | object
    :param k:                Same as the Key. You can use either k or key. Which ever is set will be used.
    :type k:                 str | int | tuple | object
    :param metadata:         Anything you want to store along with this button
    :type metadata:          (Any)
    :return:                 returns a button
    :rtype:                  (Button)
    """
    ...

def CloseButton(button_text, image_filename=..., image_data=..., image_size=..., image_subsample=..., border_width=..., tooltip=..., size=..., s=..., auto_size_button=..., button_color=..., font=..., bind_return_key=..., disabled=..., focus=..., pad=..., p=..., key=..., k=..., metadata=...): # -> Button:
    """
    DEPRICATED

    This button should not be used.  Instead explicitly close your windows by calling window.close() or by using
    the close parameter in window.read

    :param button_text:      text in the button
    :type button_text:       (str)
    :param image_filename:   image filename if there is a button image
    :type image_filename:    image filename if there is a button image
    :param image_data:       in-RAM image to be displayed on button
    :type image_data:        in-RAM image to be displayed on button
    :param image_size:       image size (O.K.)
    :type image_size:        (Default = (None))
    :param image_subsample:  amount to reduce the size of the image
    :type image_subsample:   amount to reduce the size of the image
    :param tooltip:          text, that will appear when mouse hovers over the element
    :type tooltip:           (str)
    :param size:             (w,h) w=characters-wide, h=rows-high
    :type size:              (int, int)
    :param s:                Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
    :type s:                 (int, int)  | (None, None) | int
    :param auto_size_button: True if button size is determined by button text
    :type auto_size_button:  (bool)
    :param button_color:     button color (foreground, background)
    :type button_color:      (str, str) or str
    :param font:             specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:              (str or (str, int[, str]) or None)
    :param bind_return_key:  (Default = False) If True, then the return key will cause a the Listbox to generate an event
    :type bind_return_key:   (bool)
    :param disabled:         set disable state for element (Default = False)
    :type disabled:          (bool)
    :param focus:            if focus should be set to this
    :type focus:             idk_yetReally
    :param pad:              Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
    :type pad:               (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param p:                Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
    :type p:                 (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param key:              key for uniquely identify this element (for window.find_element)
    :type key:               str | int | tuple | object
    :param k:                Same as the Key. You can use either k or key. Which ever is set will be used.
    :type k:                 str | int | tuple | object
    :param metadata:         Anything you want to store along with this button
    :type metadata:          (Any)
    :return:                 returns a button
    :rtype:                  (Button)
    """
    ...

CButton = ...
def ReadButton(button_text, image_filename=..., image_data=..., image_size=..., image_subsample=..., border_width=..., tooltip=..., size=..., s=..., auto_size_button=..., button_color=..., font=..., bind_return_key=..., disabled=..., focus=..., pad=..., p=..., key=..., k=..., metadata=...): # -> Button:
    """
    :param button_text:      text in the button
    :type button_text:       (str)
    :param image_filename:   image filename if there is a button image
    :type image_filename:    image filename if there is a button image
    :param image_data:       in-RAM image to be displayed on button
    :type image_data:        in-RAM image to be displayed on button
    :param image_size:       image size (O.K.)
    :type image_size:        (Default = (None))
    :param image_subsample:  amount to reduce the size of the image
    :type image_subsample:   amount to reduce the size of the image
    :param tooltip:          text, that will appear when mouse hovers over the element
    :type tooltip:           (str)
    :param size:             (w,h) w=characters-wide, h=rows-high
    :type size:              (int, int)
    :param s:                Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
    :type s:                 (int, int)  | (None, None) | int
    :param auto_size_button: True if button size is determined by button text
    :type auto_size_button:  (bool)
    :param button_color:     button color (foreground, background)
    :type button_color:      (str, str) or str
    :param font:             specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:              (str or (str, int[, str]) or None)
    :param bind_return_key:  (Default = False) If True, then the return key will cause a the Listbox to generate an event
    :type bind_return_key:   (bool)
    :param disabled:         set disable state for element (Default = False)
    :type disabled:          (bool)
    :param focus:            if focus should be set to this
    :type focus:             idk_yetReally
    :param pad:              Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
    :type pad:               (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param p:                Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
    :type p:                 (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param key:              key for uniquely identify this element (for window.find_element)
    :type key:               str | int | tuple | object
    :param k:                Same as the Key. You can use either k or key. Which ever is set will be used.
    :type k:                 str | int | tuple | object
    :param border_width:     width of border around element
    :type border_width:      (int)
    :param metadata:         Anything you want to store along with this button
    :type metadata:          (Any)
    :return:                 Button created
    :rtype:                  (Button)
    """
    ...

ReadFormButton = ...
RButton = ...
def RealtimeButton(button_text, image_filename=..., image_data=..., image_size=..., image_subsample=..., border_width=..., tooltip=..., size=..., s=..., auto_size_button=..., button_color=..., font=..., disabled=..., bind_return_key=..., focus=..., pad=..., p=..., key=..., k=..., visible=..., metadata=...): # -> Button:
    """

    :param button_text:      text in the button
    :type button_text:       (str)
    :param image_filename:   image filename if there is a button image
    :type image_filename:    image filename if there is a button image
    :param image_data:       in-RAM image to be displayed on button
    :type image_data:        in-RAM image to be displayed on button
    :param image_size:       image size (O.K.)
    :type image_size:        (Default = (None))
    :param image_subsample:  amount to reduce the size of the image
    :type image_subsample:   amount to reduce the size of the image
    :param border_width:     width of border around element
    :type border_width:      (int)
    :param tooltip:          text, that will appear when mouse hovers over the element
    :type tooltip:           (str)
    :param size:             (w,h) w=characters-wide, h=rows-high
    :type size:              (int, int)
    :param s:                Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
    :type s:                 (int, int)  | (None, None) | int
    :param auto_size_button: True if button size is determined by button text
    :type auto_size_button:  (bool)
    :param button_color:     button color (foreground, background)
    :type button_color:      (str, str) or str
    :param font:             specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:              (str or (str, int[, str]) or None)
    :param disabled:         set disable state for element (Default = False)
    :type disabled:          (bool)
    :param bind_return_key:  (Default = False) If True, then the return key will cause a the Listbox to generate an event
    :type bind_return_key:   (bool)
    :param focus:            if focus should be set to this
    :type focus:             (bool)
    :param pad:              Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
    :type pad:               (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param p:                Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
    :type p:                 (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param key:              key for uniquely identify this element (for window.find_element)
    :type key:               str | int | tuple | object
    :param k:                Same as the Key. You can use either k or key. Which ever is set will be used.
    :type k:                 str | int | tuple | object
    :param visible:          set initial visibility state of the Button
    :type visible:           (bool)
    :param metadata:         Anything you want to store along with this button
    :type metadata:          (Any)
    :return:                 Button created
    :rtype:                  (Button)
    """
    ...

def DummyButton(button_text, image_filename=..., image_data=..., image_size=..., image_subsample=..., border_width=..., tooltip=..., size=..., s=..., auto_size_button=..., button_color=..., font=..., disabled=..., bind_return_key=..., focus=..., pad=..., p=..., key=..., k=..., visible=..., metadata=...): # -> Button:
    """
    This is a special type of Button.

    It will close the window but NOT send an event that the window has been closed.

    It's used in conjunction with non-blocking windows to silently close them.  They are used to
    implement the non-blocking popup windows. They're also found in some Demo Programs, so look there for proper use.

    :param button_text:      text in the button
    :type button_text:       (str)
    :param image_filename:   image filename if there is a button image
    :type image_filename:    image filename if there is a button image
    :param image_data:       in-RAM image to be displayed on button
    :type image_data:        in-RAM image to be displayed on button
    :param image_size:       image size (O.K.)
    :type image_size:        (Default = (None))
    :param image_subsample:  amount to reduce the size of the image
    :type image_subsample:   amount to reduce the size of the image
    :param border_width:     width of border around element
    :type border_width:      (int)
    :param tooltip:          text, that will appear when mouse hovers over the element
    :type tooltip:           (str)
    :param size:             (w,h) w=characters-wide, h=rows-high
    :type size:              (int, int)
    :param s:                Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
    :type s:                 (int, int)  | (None, None) | int
    :param auto_size_button: True if button size is determined by button text
    :type auto_size_button:  (bool)
    :param button_color:     button color (foreground, background)
    :type button_color:      (str, str) or str
    :param font:             specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:              (str or (str, int[, str]) or None)
    :param disabled:         set disable state for element (Default = False)
    :type disabled:          (bool)
    :param bind_return_key:  (Default = False) If True, then the return key will cause a the Listbox to generate an event
    :type bind_return_key:   (bool)
    :param focus:            if focus should be set to this
    :type focus:             (bool)
    :param pad:              Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
    :type pad:               (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param p:                Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
    :type p:                 (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param key:              key for uniquely identify this element (for window.find_element)
    :type key:               str | int | tuple | object
    :param k:                Same as the Key. You can use either k or key. Which ever is set will be used.
    :type k:                 str | int | tuple | object
    :param visible:          set initial visibility state of the Button
    :type visible:           (bool)
    :param metadata:         Anything you want to store along with this button
    :type metadata:          (Any)
    :return:                 returns a button
    :rtype:                  (Button)
    """
    ...

def CalendarButton(button_text, target=..., close_when_date_chosen=..., default_date_m_d_y=..., image_filename=..., image_data=..., image_size=..., image_subsample=..., tooltip=..., border_width=..., size=..., s=..., auto_size_button=..., button_color=..., disabled=..., font=..., bind_return_key=..., focus=..., pad=..., p=..., enable_events=..., key=..., k=..., visible=..., locale=..., format=..., begin_at_sunday_plus=..., month_names=..., day_abbreviations=..., title=..., no_titlebar=..., location=..., metadata=...): # -> Button:
    """
    Button that will show a calendar chooser window.  Fills in the target element with result

    :param button_text:            text in the button
    :type button_text:             (str)
    :param target:                 Key or "coordinate" (see docs) of target element
    :type target:                  (int, int) | Any
    :param close_when_date_chosen: (Default = True)
    :type close_when_date_chosen:  bool
    :param default_date_m_d_y:     Beginning date to show
    :type default_date_m_d_y:      (int, int or None, int)
    :param image_filename:         image filename if there is a button image
    :type image_filename:          image filename if there is a button image
    :param image_data:             in-RAM image to be displayed on button
    :type image_data:              in-RAM image to be displayed on button
    :param image_size:             image size (O.K.)
    :type image_size:              (Default = (None))
    :param image_subsample:        amount to reduce the size of the image
    :type image_subsample:         amount to reduce the size of the image
    :param tooltip:                text, that will appear when mouse hovers over the element
    :type tooltip:                 (str)
    :param border_width:           width of border around element
    :type border_width:            width of border around element
    :param size:                   (w,h) w=characters-wide, h=rows-high
    :type size:                    (int, int)
    :param s:                      Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
    :type s:                       (int, int)  | (None, None) | int
    :param auto_size_button:       True if button size is determined by button text
    :type auto_size_button:        (bool)
    :param button_color:           button color (foreground, background)
    :type button_color:            (str, str) or str
    :param disabled:               set disable state for element (Default = False)
    :type disabled:                (bool)
    :param font:                   specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:                    (str or (str, int[, str]) or None)
    :param bind_return_key:        (Default = False) If True, then the return key will cause a the Listbox to generate an event
    :type bind_return_key:         bool
    :param focus:                  if focus should be set to this
    :type focus:                   bool
    :param pad:                    Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
    :type pad:                     (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param p:                      Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
    :type p:                       (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param key:                    key for uniquely identify this element (for window.find_element)
    :type key:                     str | int | tuple | object
    :param k:                      Same as the Key. You can use either k or key. Which ever is set will be used.
    :type k:                       str | int | tuple | object
    :param locale:                 defines the locale used to get day names
    :type locale:                  str
    :param format:                 formats result using this strftime format
    :type format:                  str
    :param month_names:            optional list of month names to use (should be 12 items)
    :type month_names:             List[str]
    :param day_abbreviations:      optional list of abbreviations to display as the day of week
    :type day_abbreviations:       List[str]
    :param title:                  Title shown on the date chooser window
    :type title:                   (str)
    :param no_titlebar:            if True no titlebar will be shown on the date chooser window
    :type no_titlebar:             bool
    :param location:               Location on the screen (x,y) to show the calendar popup window
    :type location:                (int, int)
    :param visible:                set initial visibility state of the Button
    :type visible:                 (bool)
    :param metadata:               Anything you want to store along with this button
    :type metadata:                (Any)
    :return:                       returns a button
    :rtype:                        (Button)
    """
    ...

def ColorChooserButton(button_text, target=..., image_filename=..., image_data=..., image_size=..., image_subsample=..., tooltip=..., border_width=..., size=..., s=..., auto_size_button=..., button_color=..., disabled=..., font=..., bind_return_key=..., focus=..., pad=..., p=..., key=..., k=..., visible=..., metadata=...): # -> Button:
    """

    :param button_text:      text in the button
    :type button_text:       (str)
    :param target:           key or (row,col) target for the button. Note that -1 for column means 1 element to the left of this one. The constant ThisRow is used to indicate the current row. The Button itself is a valid target for some types of button
    :type target:            str | (int, int)
    :type image_filename:    (str)
    :param image_filename:   image filename if there is a button image. GIFs and PNGs only.
    :type image_filename:    (str)
    :param image_data:       Raw or Base64 representation of the image to put on button. Choose either filename or data
    :type image_data:        bytes | str
    :param image_size:       Size of the image in pixels (width, height)
    :type image_size:        (int, int)
    :param image_subsample:  amount to reduce the size of the image. Divides the size by this number. 2=1/2, 3=1/3, 4=1/4, etc
    :type image_subsample:   (int)
    :param tooltip:          text, that will appear when mouse hovers over the element
    :type tooltip:           (str)
    :param border_width:     width of border around element
    :type border_width:      (int)
    :param size:             (w,h) w=characters-wide, h=rows-high
    :type size:              (int, int)
    :param s:                Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
    :type s:                 (int, int)  | (None, None) | int
    :param auto_size_button: True if button size is determined by button text
    :type auto_size_button:  (bool)
    :param button_color:     button color (foreground, background)
    :type button_color:      (str, str) or str
    :param disabled:         set disable state for element (Default = False)
    :type disabled:          (bool)
    :param font:             specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:              (str or (str, int[, str]) or None)
    :param bind_return_key:  If True, then the return key will cause a the Listbox to generate an event
    :type bind_return_key:   (bool)
    :param focus:            Determines if initial focus should go to this element.
    :type focus:             (bool)
    :param pad:              Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
    :type pad:               (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param p:                Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
    :type p:                 (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param key:              key for uniquely identify this element (for window.find_element)
    :type key:               str | int | tuple | object
    :param k:                Same as the Key. You can use either k or key. Which ever is set will be used.
    :type k:                 str | int | tuple | object
    :param visible:          set initial visibility state of the Button
    :type visible:           (bool)
    :param metadata:         User metadata that can be set to ANYTHING
    :type metadata:          (Any)
    :return:                 returns a button
    :rtype:                  (Button)
    """
    ...

def button_color_to_tuple(color_tuple_or_string, default=...): # -> tuple[Literal['1234567890'], Literal['1234567890']]:
    """
    Convert a color tuple or color string into 2 components and returns them as a tuple
    (Text Color, Button Background Color)
    If None is passed in as the first parameter, then the theme's button color is
    returned

    :param color_tuple_or_string: Button color - tuple or a simplied color string with word "on" between color
    :type  color_tuple_or_string: str | (str, str)
    :param default:               The 2 colors to use if there is a problem. Otherwise defaults to the theme's button color
    :type  default:               (str, str)
    :return:                      (str | (str, str)
    :rtype:                       str | (str, str)
    """
    ...

def AddToReturnDictionary(form, element, value): # -> None:
    ...

def AddToReturnList(form, value): # -> None:
    ...

def InitializeResults(form): # -> None:
    ...

def DecodeRadioRowCol(RadValue): # -> tuple[Unknown, Unknown, Unknown]:
    ...

def EncodeRadioRowCol(container, row, col):
    ...

def fill_form_with_values(window, values_dict): # -> None:
    """
    Fills a window with values provided in a values dictionary { element_key : new_value }

    :param window:      The window object to fill
    :type window:       (Window)
    :param values_dict: A dictionary with element keys as key and value is values parm for Update call
    :type values_dict:  (Dict[Any, Any])
    :return:            None
    :rtype:             None
    """
    ...

def AddMenuItem(top_menu, sub_menu_info, element, is_sub_menu=..., skip=..., right_click_menu=...):
    """
    Only to be used internally. Not user callable
    :param top_menu:      ???
    :type top_menu:       ???
    :param sub_menu_info: ???
    :type sub_menu_info:
    :param element:       ???
    :type element:        idk_yetReally
    :param is_sub_menu:   (Default = False)
    :type is_sub_menu:    (bool)
    :param skip:          (Default = False)
    :type skip:           (bool)

    """
    ...

class VarHolder:
    canvas_holder = ...
    def __init__(self) -> None:
        ...
    


def PackFormIntoFrame(form, containing_frame, toplevel_form):
    """

    :param form:             a window class
    :type form:              (Window)
    :param containing_frame: ???
    :type containing_frame:  ???
    :param toplevel_form:    ???
    :type toplevel_form:     (Window)

    """
    ...

def StartupTK(window): # -> None:
    """
    NOT user callable
    Creates the window (for real) lays out all the elements, etc.  It's a HUGE set of things it does.  It's the basic
    "porting layer" that will change depending on the GUI framework PySimpleGUI is running on top of.

    :param window: you window object
    :type window:  (Window)

    """
    ...

def convert_args_to_single_string(*args): # -> tuple[str, int, int]:
    """

    :param *args:
    :type *args:

    """
    ...

METER_REASON_CANCELLED = ...
METER_REASON_CLOSED = ...
METER_REASON_REACHED_MAX = ...
METER_OK = ...
METER_STOPPED = ...
class QuickMeter:
    active_meters = ...
    exit_reasons = ...
    def __init__(self, title, current_value, max_value, key, *args, orientation=..., bar_color=..., button_color=..., size=..., border_width=..., grab_anywhere=..., no_titlebar=..., keep_on_top=..., no_button=...) -> None:
        """

        :param title:         text to display in element
        :type title:          (str)
        :param current_value: current value
        :type current_value:  (int)
        :param max_value:     max value of QuickMeter
        :type max_value:      (int)
        :param key:           Used with window.find_element and with return values to uniquely identify this element
        :type key:            str | int | tuple | object
        :param *args:         stuff to output
        :type *args:          (Any)
        :param orientation:   'horizontal' or 'vertical' ('h' or 'v' work) (Default value = 'vertical' / 'v')
        :type orientation:    (str)
        :param bar_color:     color of a bar line
        :type bar_color:      (str, str)
        :param button_color:  button color (foreground, background)
        :type button_color:   (str, str) or str
        :param size:          (w,h) w=characters-wide, h=rows-high (Default value = DEFAULT_PROGRESS_BAR_SIZE)
        :type size:           (int, int)
        :param border_width:  width of border around element
        :type border_width:   (int)
        :param grab_anywhere: If True: can grab anywhere to move the window (Default = False)
        :type grab_anywhere:  (bool)
        :param no_titlebar:   If True: window will be created without a titlebar
        :type no_titlebar:    (bool)
        :param keep_on_top:   If True the window will remain above all current windows
        :type keep_on_top:    (bool)
        :param no_button:     If True: window will be created without a cancel button
        :type no_button:      (bool)
        """
        ...
    
    def BuildWindow(self, *args): # -> Window:
        ...
    
    def UpdateMeter(self, current_value, max_value, *args): # -> Literal[True]:
        ...
    
    def ComputeProgressStats(self): # -> list[str]:
        ...
    


def one_line_progress_meter(title, current_value, max_value, *args, key=..., orientation=..., bar_color=..., button_color=..., size=..., border_width=..., grab_anywhere=..., no_titlebar=..., keep_on_top=..., no_button=...): # -> bool:
    """
    :param title:         text to display in eleemnt
    :type title:          (str)
    :param current_value: current value
    :type current_value:  (int)
    :param max_value:     max value of QuickMeter
    :type max_value:      (int)
    :param *args:         stuff to output
    :type *args:          (Any)
    :param key:           Used to differentiate between mutliple meters. Used to cancel meter early. Now optional as there is a default value for single meters
    :type key:            str | int | tuple | object
    :param orientation:   'horizontal' or 'vertical' ('h' or 'v' work) (Default value = 'vertical' / 'v')
    :type orientation:    (str)
    :param bar_color:     color of a bar line
    :type bar_color:      Tuple(str, str)
    :param button_color:  button color (foreground, background)
    :type button_color:   (str, str) or str
    :param size:          (w,h) w=characters-wide, h=rows-high (Default value = DEFAULT_PROGRESS_BAR_SIZE)
    :type size:           (int, int)
    :param border_width:  width of border around element
    :type border_width:   (int)
    :param grab_anywhere: If True: can grab anywhere to move the window (Default = False)
    :type grab_anywhere:  (bool)
    :param no_titlebar:   If True: no titlebar will be shown on the window
    :type no_titlebar:    (bool)
    :param keep_on_top:   If True the window will remain above all current windows
    :type keep_on_top:    (bool)
    :param no_button:     If True: window will be created without a cancel button
    :type no_button:      (bool)
    :return:              True if updated successfully. False if user closed the meter with the X or Cancel button
    :rtype:               (bool)
    """
    ...

def one_line_progress_meter_cancel(key=...): # -> None:
    """
    Cancels and closes a previously created One Line Progress Meter window

    :param key: Key used when meter was created
    :type key:  (Any)
    :return:    None
    :rtype:     None
    """
    ...

def get_complimentary_hex(color): # -> str:
    """
    :param color: color string, like "#RRGGBB"
    :type color:  (str)
    :return:      color string, like "#RRGGBB"
    :rtype:       (str)
    """
    ...

class _DebugWin:
    debug_window = ...
    def __init__(self, size=..., location=..., relative_location=..., font=..., no_titlebar=..., no_button=..., grab_anywhere=..., keep_on_top=..., do_not_reroute_stdout=..., echo_stdout=..., resizable=..., blocking=...) -> None:
        """

        :param size:                  (w,h) w=characters-wide, h=rows-high
        :type size:                   (int, int)
        :param location:              Location of upper left corner of the window
        :type location:               (int, int)
        :param relative_location:     (x,y) location relative to the default location of the window, in pixels. Normally the window centers.  This location is relative to the location the window would be created. Note they can be negative.
        :type relative_location:      (int, int)
        :param font:                  specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
        :type font:                   (str or (str, int[, str]) or None)
        :param no_titlebar:           If True no titlebar will be shown
        :type no_titlebar:            (bool)
        :param no_button:             show button
        :type no_button:              (bool)
        :param grab_anywhere:         If True: can grab anywhere to move the window (Default = False)
        :type grab_anywhere:          (bool)
        :param location:              Location of upper left corner of the window
        :type location:               (int, int)
        :param do_not_reroute_stdout: bool value
        :type do_not_reroute_stdout:  (bool)
        :param echo_stdout:           If True stdout is sent to both the console and the debug window
        :type echo_stdout:            (bool)
        :param resizable:             if True, makes the window resizble
        :type resizable:              (bool)
        :param blocking:              if True, makes the window block instead of returning immediately
        :type blocking:               (bool)
        """
        ...
    
    def reopen_window(self): # -> None:
        ...
    
    def Print(self, *args, end=..., sep=..., text_color=..., background_color=..., erase_all=..., font=..., blocking=...):
        ...
    
    def Close(self): # -> None:
        ...
    


def easy_print(*args, size=..., end=..., sep=..., location=..., relative_location=..., font=..., no_titlebar=..., no_button=..., grab_anywhere=..., keep_on_top=..., do_not_reroute_stdout=..., echo_stdout=..., text_color=..., background_color=..., colors=..., c=..., erase_all=..., resizable=..., blocking=..., wait=...): # -> None:
    """
    Works like a "print" statement but with windowing options.  Routes output to the "Debug Window"

    In addition to the normal text and background colors, you can use a "colors" tuple/string
    The "colors" or "c" parameter defines both the text and background in a single parm.
    It can be a tuple or a single single. Both text and background colors need to be specified
    colors -(str, str) or str.  A combined text/background color definition in a single parameter
    c - (str, str) - Colors tuple has format (foreground, backgrouned)
    c - str - can also be a string of the format "foreground on background"  ("white on red")

    :param *args:                 stuff to output
    :type *args:                  (Any)
    :param size:                  (w,h) w=characters-wide, h=rows-high
    :type size:                   (int, int)
    :param end:                   end character
    :type end:                    (str)
    :param sep:                   separator character
    :type sep:                    (str)
    :param location:              Location of upper left corner of the window
    :type location:               (int, int)
    :param relative_location:     (x,y) location relative to the default location of the window, in pixels. Normally the window centers.  This location is relative to the location the window would be created. Note they can be negative.
    :type relative_location:      (int, int)
    :param font:                  specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:                   (str or (str, int[, str]) or None)
    :param no_titlebar:           If True no titlebar will be shown
    :type no_titlebar:            (bool)
    :param no_button:             don't show button
    :type no_button:              (bool)
    :param grab_anywhere:         If True: can grab anywhere to move the window (Default = False)
    :type grab_anywhere:          (bool)
    :param background_color:      color of background
    :type background_color:       (str)
    :param text_color:            color of the text
    :type text_color:             (str)
    :param keep_on_top:           If True the window will remain above all current windows
    :type keep_on_top:            (bool)
    :param location:              Location of upper left corner of the window
    :type location:               (int, int)
    :param do_not_reroute_stdout: do not reroute stdout and stderr. If False, both stdout and stderr will reroute to here
    :type do_not_reroute_stdout:  (bool)
    :param echo_stdout:           If True stdout is sent to both the console and the debug window
    :type echo_stdout:            (bool)
    :param colors:                Either a tuple or a string that has both the text and background colors
    :type colors:                 (str) or (str, str)
    :param c:                     Either a tuple or a string that has both the text and background colors
    :type c:                      (str) or (str, str)
    :param resizable:             if True, the user can resize the debug window. Default is True
    :type resizable:              (bool)
    :param erase_all:             If True when erase the output before printing
    :type erase_all:              (bool)
    :param blocking:              if True, makes the window block instead of returning immediately. The "Quit" button changers to "More"
    :type blocking:               (bool | None)
    :param wait:                  Same as the "blocking" parm. It's an alias.  if True, makes the window block instead of returning immediately. The "Quit" button changes to "Click to Continue..."
    :type wait:                   (bool | None)
    :return:
    :rtype:
    """
    ...

def easy_print_close(): # -> None:
    """
    Close a previously opened EasyPrint window

    :return:
    :rtype:
    """
    ...

CPRINT_DESTINATION_WINDOW = ...
CPRINT_DESTINATION_MULTILINE_ELMENT_KEY = ...
def cprint_set_output_destination(window, multiline_key): # -> None:
    """
    Sets up the color print (cprint) output destination
    :param window:        The window that the cprint call will route the output to
    :type window:         (Window)
    :param multiline_key: Key for the Multiline Element where output will be sent
    :type multiline_key:  (Any)
    :return:              None
    :rtype:               None
    """
    ...

def cprint(*args, end=..., sep=..., text_color=..., font=..., t=..., background_color=..., b=..., colors=..., c=..., window=..., key=..., justification=..., autoscroll=...):
    """
    Color print to a multiline element in a window of your choice.
    Must have EITHER called cprint_set_output_destination prior to making this call so that the
    window and element key can be saved and used here to route the output, OR used the window
    and key parameters to the cprint function to specicy these items.

    args is a variable number of things you want to print.

    end - The end char to use just like print uses
    sep - The separation character like print uses
    text_color - The color of the text
            key - overrides the previously defined Multiline key
    window - overrides the previously defined window to output to
    background_color - The color of the background
    colors -(str, str) or str.  A combined text/background color definition in a single parameter

    There are also "aliases" for text_color, background_color and colors (t, b, c)
     t - An alias for color of the text (makes for shorter calls)
    b - An alias for the background_color parameter
    c - (str, str) - "shorthand" way of specifying color. (foreground, backgrouned)
    c - str - can also be a string of the format "foreground on background"  ("white on red")

    With the aliases it's possible to write the same print but in more compact ways:
    cprint('This will print white text on red background', c=('white', 'red'))
    cprint('This will print white text on red background', c='white on red')
    cprint('This will print white text on red background', text_color='white', background_color='red')
    cprint('This will print white text on red background', t='white', b='red')

    :param *args:            stuff to output
    :type *args:             (Any)
    :param text_color:       Color of the text
    :type text_color:        (str)
    :param font:             specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike for the value being updated
    :type font:              (str or (str, int[, str]) or None)
    :param background_color: The background color of the line
    :type background_color:  (str)
    :param colors:           Either a tuple or a string that has both the text and background colors "text on background" or just the text color
    :type colors:            (str) or (str, str)
    :param t:                Color of the text
    :type t:                 (str)
    :param b:                The background color of the line
    :type b:                 (str)
    :param c:                Either a tuple or a string.  Same as the color parm
    :type c:                 (str) or (str, str)
    :param end:              end character
    :type end:               (str)
    :param sep:              separator character
    :type sep:               (str)
    :param key:              key of multiline to output to (if you want to override the one previously set)
    :type key:               (Any)
    :param window:           Window containing the multiline to output to (if you want to override the one previously set)
    :type window:            (Window)
    :param justification:    text justification. left, right, center. Can use single characters l, r, c. Sets only for this value, not entire element
    :type justification:     (str)
    :param autoscroll:       If True the contents of the element will automatically scroll as more data added to the end
    :type autoscroll:        (bool)
    """
    ...

def set_global_icon(icon): # -> None:
    """
    Sets the icon which will be used any time a window is created if an icon is not provided when the
    window is created.

    :param icon: Either a Base64 byte string or a filename
    :type icon:  bytes | str
    """
    ...

def set_options(icon=..., button_color=..., element_size=..., button_element_size=..., margins=..., element_padding=..., auto_size_text=..., auto_size_buttons=..., font=..., border_width=..., slider_border_width=..., slider_relief=..., slider_orientation=..., autoclose_time=..., message_box_line_width=..., progress_meter_border_depth=..., progress_meter_style=..., progress_meter_relief=..., progress_meter_color=..., progress_meter_size=..., text_justification=..., background_color=..., element_background_color=..., text_element_background_color=..., input_elements_background_color=..., input_text_color=..., scrollbar_color=..., text_color=..., element_text_color=..., debug_win_size=..., window_location=..., error_button_color=..., tooltip_time=..., tooltip_font=..., use_ttk_buttons=..., ttk_theme=..., suppress_error_popups=..., suppress_raise_key_errors=..., suppress_key_guessing=..., warn_button_key_duplicates=..., enable_treeview_869_patch=..., enable_mac_notitlebar_patch=..., use_custom_titlebar=..., titlebar_background_color=..., titlebar_text_color=..., titlebar_font=..., titlebar_icon=..., user_settings_path=..., pysimplegui_settings_path=..., pysimplegui_settings_filename=..., keep_on_top=..., dpi_awareness=..., scaling=..., disable_modal_windows=..., force_modal_windows=..., tooltip_offset=..., sbar_trough_color=..., sbar_background_color=..., sbar_arrow_color=..., sbar_width=..., sbar_arrow_width=..., sbar_frame_color=..., sbar_relief=..., alpha_channel=...):
    """
    :param icon:                            Can be either a filename or Base64 value. For Windows if filename, it MUST be ICO format. For Linux, must NOT be ICO. Most portable is to use a Base64 of a PNG file. This works universally across all OS's
    :type icon:                             bytes | str
    :param button_color:                    Color of the button (text, background)
    :type button_color:                     (str, str) or str
    :param element_size:                    element size (width, height) in characters
    :type element_size:                     (int, int)
    :param button_element_size:             Size of button
    :type button_element_size:              (int, int)
    :param margins:                         (left/right, top/bottom) tkinter margins around outsize. Amount of pixels to leave inside the window's frame around the edges before your elements are shown.
    :type margins:                          (int, int)
    :param element_padding:                 Default amount of padding to put around elements in window (left/right, top/bottom) or ((left, right), (top, bottom))
    :type element_padding:                  (int, int) or ((int, int),(int,int))
    :param auto_size_text:                  True if the Widget should be shrunk to exactly fit the number of chars to show
    :type auto_size_text:                   bool
    :param auto_size_buttons:               True if Buttons in this Window should be sized to exactly fit the text on this.
    :type auto_size_buttons:                (bool)
    :param font:                            specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:                             (str or (str, int[, str]) or None)
    :param border_width:                    width of border around element
    :type border_width:                     (int)
    :param slider_border_width:             Width of the border around sliders
    :type slider_border_width:              (int)
    :param slider_relief:                   Type of relief to use for sliders
    :type slider_relief:                    (str)
    :param slider_orientation:              ???
    :type slider_orientation:               ???
    :param autoclose_time:                  ???
    :type autoclose_time:                   ???
    :param message_box_line_width:          ???
    :type message_box_line_width:           ???
    :param progress_meter_border_depth:     ???
    :type progress_meter_border_depth:      ???
    :param progress_meter_style:            You can no longer set a progress bar style. All ttk styles must be the same for the window
    :type progress_meter_style:             ???
    :param progress_meter_relief:
    :type progress_meter_relief:            ???
    :param progress_meter_color:            ???
    :type progress_meter_color:             ???
    :param progress_meter_size:             ???
    :type progress_meter_size:              ???
    :param text_justification:              Default text justification for all Text Elements in window
    :type text_justification:               'left' | 'right' | 'center'
    :param background_color:                color of background
    :type background_color:                 (str)
    :param element_background_color:        element background color
    :type element_background_color:         (str)
    :param text_element_background_color:   text element background color
    :type text_element_background_color:    (str)
    :param input_elements_background_color: Default color to use for the background of input elements
    :type input_elements_background_color:  (str)
    :param input_text_color:                Default color to use for the text for Input elements
    :type input_text_color:                 (str)
    :param scrollbar_color:                 Default color to use for the slider trough
    :type scrollbar_color:                  (str)
    :param text_color:                      color of the text
    :type text_color:                       (str)
    :param element_text_color:              Default color to use for Text elements
    :type element_text_color:               (str)
    :param debug_win_size:                  window size
    :type debug_win_size:                   (int, int)
    :param window_location:                 Default location to place windows. Not setting will center windows on the display
    :type window_location:                  (int, int) | None
    :param error_button_color:              (Default = (None))
    :type error_button_color:               ???
    :param tooltip_time:                    time in milliseconds to wait before showing a tooltip. Default is 400ms
    :type tooltip_time:                     (int)
    :param tooltip_font:                    font to use for all tooltips
    :type tooltip_font:                     str or Tuple[str, int] or Tuple[str, int, str]
    :param use_ttk_buttons:                 if True will cause all buttons to be ttk buttons
    :type use_ttk_buttons:                  (bool)
    :param ttk_theme:                       Theme to use with ttk widgets.  Choices (on Windows) include - 'default', 'winnative', 'clam', 'alt', 'classic', 'vista', 'xpnative'
    :type ttk_theme:                        (str)
    :param suppress_error_popups:           If True then error popups will not be shown if generated internally to PySimpleGUI
    :type suppress_error_popups:            (bool)
    :param suppress_raise_key_errors:       If True then key errors won't be raised (you'll still get popup error)
    :type suppress_raise_key_errors:        (bool)
    :param suppress_key_guessing:           If True then key errors won't try and find closest matches for you
    :type suppress_key_guessing:            (bool)
    :param warn_button_key_duplicates:      If True then duplicate Button Keys generate warnings (not recommended as they're expected)
    :type warn_button_key_duplicates:       (bool)
    :param enable_treeview_869_patch:       If True, then will use the treeview color patch for tk 8.6.9
    :type enable_treeview_869_patch:        (bool)
    :param enable_mac_notitlebar_patch:     If True then Windows with no titlebar use an alternative technique when tkinter version < 8.6.10
    :type enable_mac_notitlebar_patch:      (bool)
    :param use_custom_titlebar:             If True then a custom titlebar is used instead of the normal system titlebar
    :type use_custom_titlebar:              (bool)
    :param titlebar_background_color:       If custom titlebar indicated by use_custom_titlebar, then use this as background color
    :type titlebar_background_color:        str | None
    :param titlebar_text_color:             If custom titlebar indicated by use_custom_titlebar, then use this as text color
    :type titlebar_text_color:              str | None
    :param titlebar_font:                   If custom titlebar indicated by use_custom_titlebar, then use this as title font
    :type titlebar_font:                    (str or (str, int[, str]) or None) | None
    :param titlebar_icon:                   If custom titlebar indicated by use_custom_titlebar, then use this as the icon (file or base64 bytes)
    :type titlebar_icon:                    bytes | str
    :param user_settings_path:              default path for user_settings API calls. Expanded with os.path.expanduser so can contain ~ to represent user
    :type user_settings_path:               (str)
    :param pysimplegui_settings_path:       default path for the global PySimpleGUI user_settings
    :type pysimplegui_settings_path:        (str)
    :param pysimplegui_settings_filename:   default filename for the global PySimpleGUI user_settings
    :type pysimplegui_settings_filename:    (str)
    :param keep_on_top:                     If True then all windows will automatically be set to keep_on_top=True
    :type keep_on_top:                      (bool)
    :param dpi_awareness:                   If True then will turn on DPI awareness (Windows only at the moment)
    :type dpi_awareness:                    (bool)
    :param scaling:                         Sets the default scaling for all windows including popups, etc.
    :type scaling:                          (float)
    :param disable_modal_windows:           If True then all windows, including popups, will not be modal windows (unless they've been set to FORCED using another option)
    :type disable_modal_windows:            (bool)
    :param force_modal_windows:             If True then all windows will be modal (the disable option will be ignored... all windows will be forced to be modal)
    :type force_modal_windows:              (bool)
    :param tooltip_offset:                  Offset to use for tooltips as a tuple. These values will be added to the mouse location when the widget was entered.
    :type tooltip_offset:                   ((None, None) | (int, int))
    :param sbar_trough_color:               Scrollbar color of the trough
    :type sbar_trough_color:                (str)
    :param sbar_background_color:           Scrollbar color of the background of the arrow buttons at the ends AND the color of the "thumb" (the thing you grab and slide). Switches to arrow color when mouse is over
    :type sbar_background_color:            (str)
    :param sbar_arrow_color:                Scrollbar color of the arrow at the ends of the scrollbar (it looks like a button). Switches to background color when mouse is over
    :type sbar_arrow_color:                 (str)
    :param sbar_width:                      Scrollbar width in pixels
    :type sbar_width:                       (int)
    :param sbar_arrow_width:                Scrollbar width of the arrow on the scrollbar. It will potentially impact the overall width of the scrollbar
    :type sbar_arrow_width:                 (int)
    :param sbar_frame_color:                Scrollbar Color of frame around scrollbar (available only on some ttk themes)
    :type sbar_frame_color:                 (str)
    :param sbar_relief:                     Scrollbar relief that will be used for the "thumb" of the scrollbar (the thing you grab that slides). Should be a constant that is defined at starting with "RELIEF_" - RELIEF_RAISED, RELIEF_SUNKEN, RELIEF_FLAT, RELIEF_RIDGE, RELIEF_GROOVE, RELIEF_SOLID
    :param alpha_channel                    Default alpha channel to be used on all windows
    :type alpha_channel                     (float)
    :type sbar_relief:                      (str)
    :return:                                None
    :rtype:                                 None
    """
    ...

LOOK_AND_FEEL_TABLE = ...
def list_of_look_and_feel_values(): # -> list[str]:
    """
    Get a list of the valid values to pass into your call to change_look_and_feel

    :return: list of valid string values
    :rtype:  List[str]
    """
    ...

def theme(new_theme=...): # -> Literal['Dark Blue 3']:
    """
    Sets / Gets the current Theme.  If none is specified then returns the current theme.
    This call replaces the ChangeLookAndFeel / change_look_and_feel call which only sets the theme.

    :param new_theme: the new theme name to use
    :type new_theme:  (str)
    :return:          the currently selected theme
    :rtype:           (str)
    """
    ...

def theme_background_color(color=...): # -> None:
    """
    Sets/Returns the background color currently in use
    Used for Windows and containers (Column, Frame, Tab) and tables

    :param color: new background color to use (optional)
    :type color:  (str)
    :return:      color string of the background color currently in use
    :rtype:       (str)
    """
    ...

TRANSPARENT_BUTTON = ...
def theme_element_background_color(color=...): # -> None:
    """
    Sets/Returns the background color currently in use for all elements except containers

    :return: (str) - color string of the element background color currently in use
    :rtype:  (str)
    """
    ...

def theme_text_color(color=...): # -> Literal['1234567890']:
    """
    Sets/Returns the text color currently in use

    :return: (str) - color string of the text color currently in use
    :rtype:  (str)
    """
    ...

def theme_text_element_background_color(color=...): # -> None:
    """
    Sets/Returns the background color for text elements

    :return: (str) - color string of the text background color currently in use
    :rtype:  (str)
    """
    ...

def theme_input_background_color(color=...): # -> Literal['1234567890']:
    """
    Sets/Returns the input element background color currently in use

    :return: (str) - color string of the input element background color currently in use
    :rtype:  (str)
    """
    ...

def theme_input_text_color(color=...): # -> Literal['1234567890']:
    """
    Sets/Returns the input element entry color (not the text but the thing that's displaying the text)

    :return: (str) - color string of the input element color currently in use
    :rtype:  (str)
    """
    ...

def theme_button_color(color=...): # -> tuple[Literal['white'], Literal['#082567']]:
    """
    Sets/Returns the button color currently in use

    :return: (str, str) - TUPLE with color strings of the button color currently in use (button text color, button background color)
    :rtype:  (str, str)
    """
    ...

def theme_button_color_background(): # -> Literal['#082567']:
    """
    Returns the button color background currently in use. Note this function simple calls the theme_button_color
    function and splits apart the tuple

    :return: color string of the button color background currently in use
    :rtype:  (str)
    """
    ...

def theme_button_color_text(): # -> Literal['white']:
    """
    Returns the button color text currently in use.  Note this function simple calls the theme_button_color
    function and splits apart the tuple

    :return: color string of the button color text currently in use
    :rtype:  (str)
    """
    ...

def theme_progress_bar_color(color=...): # -> tuple[Literal['#01826B'], Literal['#D0D0D0']]:
    """
    Sets/Returns the progress bar colors by the current color theme

    :return: (str, str) - TUPLE with color strings of the ProgressBar color currently in use(button text color, button background color)
    :rtype:  (str, str)
    """
    ...

def theme_slider_color(color=...): # -> None:
    """
    Sets/Returns the slider color (used for sliders)

    :return: color string of the slider color currently in use
    :rtype:  (str)
    """
    ...

def theme_border_width(border_width=...): # -> Literal[1]:
    """
    Sets/Returns the border width currently in use
    Used by non ttk elements at the moment

    :return: border width currently in use
    :rtype:  (int)
    """
    ...

def theme_slider_border_width(border_width=...): # -> Literal[1]:
    """
    Sets/Returns the slider border width currently in use

    :return: border width currently in use for sliders
    :rtype:  (int)
    """
    ...

def theme_progress_bar_border_width(border_width=...): # -> Literal[1]:
    """
    Sets/Returns the progress meter border width currently in use

    :return: border width currently in use for progress meters
    :rtype:  (int)
    """
    ...

def theme_element_text_color(color=...): # -> Literal['1234567890']:
    """
    Sets/Returns the text color used by elements that have text as part of their display (Tables, Trees and Sliders)

    :return: color string currently in use
    :rtype:  (str)
    """
    ...

def theme_list(): # -> list[str]:
    """
    Returns a sorted list of the currently available color themes

    :return: A sorted list of the currently available color themes
    :rtype:  List[str]
    """
    ...

def theme_add_new(new_theme_name, new_theme_dict): # -> None:
    """
    Add a new theme to the dictionary of themes

    :param new_theme_name: text to display in element
    :type new_theme_name:  (str)
    :param new_theme_dict: text to display in element
    :type new_theme_dict:  (dict)
    """
    ...

def theme_use_custom_titlebar(): # -> Any | bool | None:
    """
    Returns True if a custom titlebar will be / should be used.
    The setting is in the Global Settings window and can be overwridden
    using set_options call

    :return:        True if a custom titlebar / custom menubar should be used
    :rtype:         (bool)
    """
    ...

def theme_global(new_theme=...): # -> Any | None:
    """
    Sets / Gets the global PySimpleGUI Theme.  If none is specified then returns the global theme from user settings.
    Note the theme must be a standard, built-in PySimpleGUI theme... not a user-created theme.

    :param new_theme: the new theme name to use
    :type new_theme:  (str)
    :return:          the currently selected theme
    :rtype:           (str)
    """
    ...

def theme_previewer(columns=..., scrollable=..., scroll_area_size=..., search_string=..., location=...): # -> None:
    """
    Displays a "Quick Reference Window" showing all of the different Look and Feel settings that are available.
    They are sorted alphabetically.  The legacy color names are mixed in, but otherwise they are sorted into Dark and Light halves

    :param columns:          The number of themes to display per row
    :type columns:           int
    :param scrollable:       If True then scrollbars will be added
    :type scrollable:        bool
    :param scroll_area_size: Size of the scrollable area (The Column Element used to make scrollable)
    :type scroll_area_size:  (int, int)
    :param search_string:    If specified then only themes containing this string will be shown
    :type search_string:     str
    :param location:         Location on the screen to place the window. Defaults to the center like all windows
    :type location:          (int, int)
    """
    ...

preview_all_look_and_feel_themes = ...
def theme_previewer_swatches(): # -> None:
    """
    Display themes in a window as color swatches.
    Click on a color swatch to see the hex value printed on the console.
    If you hover over a color or right click it you'll also see the hext value.
    """
    ...

def change_look_and_feel(index, force=...): # -> None:
    """
    Change the "color scheme" of all future PySimpleGUI Windows.
    The scheme are string names that specify a group of colors. Background colors, text colors, button colors.
    There are 13 different color settings that are changed at one time using a single call to ChangeLookAndFeel
    The look and feel table itself has these indexes into the dictionary LOOK_AND_FEEL_TABLE.
    The original list was (prior to a major rework and renaming)... these names still work...
    In Nov 2019 a new Theme Formula was devised to make choosing a theme easier:
    The "Formula" is:
    ["Dark" or "Light"] Color Number
    Colors can be Blue Brown Grey Green Purple Red Teal Yellow Black
    The number will vary for each pair. There are more DarkGrey entries than there are LightYellow for example.
    Default = The default settings (only button color is different than system default)
    Default1 = The full system default including the button (everything's gray... how sad... don't be all gray... please....)
    :param index: the name of the index into the Look and Feel table (does not have to be exact, can be "fuzzy")
    :type index:  (str)
    :param force: no longer used
    :type force:  (bool)
    :return:      None
    :rtype:       None
    """
    ...

def obj_to_string_single_obj(obj): # -> str:
    """
    Dumps an Object's values as a formatted string.  Very nicely done. Great way to display an object's member variables in human form
    Returns only the top-most object's variables instead of drilling down to dispolay more
    :param obj: The object to display
    :type obj:  (Any)
    :return:    Formatted output of the object's values
    :rtype:     (str)
    """
    ...

def obj_to_string(obj, extra=...): # -> str:
    """
    Dumps an Object's values as a formatted string.  Very nicely done. Great way to display an object's member variables in human form
    :param obj:   The object to display
    :type obj:    (Any)
    :param extra: extra stuff (Default value = '    ')
    :type extra:  (str)
    :return:      Formatted output of the object's values
    :rtype:       (str)
    """
    ...

def clipboard_set(new_value): # -> None:
    """
    Sets the clipboard to a specific value.
    IMPORTANT NOTE - Your PySimpleGUI application needs to remain running until you've pasted
    your clipboard. This is a tkinter limitation.  A workaround was found for Windows, but you still
    need to stay running for Linux systems.

    :param new_value: value to set the clipboard to. Will be converted to a string
    :type new_value:  (str | bytes)
    """
    ...

def clipboard_get(): # -> str:
    """
    Gets the clipboard current value.

    :return: The current value of the clipboard
    :rtype:  (str)
    """
    ...

def popup(*args, title=..., button_color=..., background_color=..., text_color=..., button_type=..., auto_close=..., auto_close_duration=..., custom_text=..., non_blocking=..., icon=..., line_width=..., font=..., no_titlebar=..., grab_anywhere=..., keep_on_top=..., location=..., relative_location=..., any_key_closes=..., image=..., modal=...): # -> str:
    """
    Popup - Display a popup Window with as many parms as you wish to include.  This is the GUI equivalent of the
    "print" statement.  It's also great for "pausing" your program's flow until the user can read some error messages.

    If this popup doesn't have the features you want, then you can easily make your own. Popups can be accomplished in 1 line of code:
    choice, _ = sg.Window('Continue?', [[sg.T('Do you want to continue?')], [sg.Yes(s=10), sg.No(s=10)]], disable_close=True).read(close=True)


    :param *args:               Variable number of your arguments.  Load up the call with stuff to see!
    :type *args:                (Any)
    :param title:               Optional title for the window. If none provided, the first arg will be used instead.
    :type title:                (str)
    :param button_color:        Color of the buttons shown (text color, button color)
    :type button_color:         (str, str) | None
    :param background_color:    Window's background color
    :type background_color:     (str)
    :param text_color:          text color
    :type text_color:           (str)
    :param button_type:         NOT USER SET!  Determines which pre-defined buttons will be shown (Default value = POPUP_BUTTONS_OK). There are many Popup functions and they call Popup, changing this parameter to get the desired effect.
    :type button_type:          (int)
    :param auto_close:          If True the window will automatically close
    :type auto_close:           (bool)
    :param auto_close_duration: time in seconds to keep window open before closing it automatically
    :type auto_close_duration:  (int)
    :param custom_text:         A string or pair of strings that contain the text to display on the buttons
    :type custom_text:          (str, str) | str
    :param non_blocking:        If True then will immediately return from the function without waiting for the user's input.
    :type non_blocking:         (bool)
    :param icon:                icon to display on the window. Same format as a Window call
    :type icon:                 str | bytes
    :param line_width:          Width of lines in characters.  Defaults to MESSAGE_BOX_LINE_WIDTH
    :type line_width:           (int)
    :param font:                specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:                 str | Tuple[font_name, size, modifiers]
    :param no_titlebar:         If True will not show the frame around the window and the titlebar across the top
    :type no_titlebar:          (bool)
    :param grab_anywhere:       If True can grab anywhere to move the window. If no_titlebar is True, grab_anywhere should likely be enabled too
    :type grab_anywhere:        (bool)
    :param location:            Location on screen to display the top left corner of window. Defaults to window centered on screen
    :type location:             (int, int)
    :param relative_location:   (x,y) location relative to the default location of the window, in pixels. Normally the window centers.  This location is relative to the location the window would be created. Note they can be negative.
    :type relative_location:    (int, int)
    :param keep_on_top:         If True the window will remain above all current windows
    :type keep_on_top:          (bool)
    :param any_key_closes:      If True then will turn on return_keyboard_events for the window which will cause window to close as soon as any key is pressed.  Normally the return key only will close the window.  Default is false.
    :type any_key_closes:       (bool)
    :param image:               Image to include at the top of the popup window
    :type image:                (str) or (bytes)
    :param modal:               If True then makes the popup will behave like a Modal window... all other windows are non-operational until this one is closed. Default = True
    :type modal:                bool
    :return:                    Returns text of the button that was pressed.  None will be returned if user closed window with X
    :rtype:                     str | None
    """
    ...

def MsgBox(*args):
    """
    Do not call this anymore it will raise exception.  Use Popups instead
    :param *args:
    :type *args:

    """
    ...

def popup_scrolled(*args, title=..., button_color=..., background_color=..., text_color=..., yes_no=..., auto_close=..., auto_close_duration=..., size=..., location=..., relative_location=..., non_blocking=..., no_titlebar=..., grab_anywhere=..., keep_on_top=..., font=..., image=..., icon=..., modal=..., no_sizegrip=...): # -> str | None:
    """
    Show a scrolled Popup window containing the user's text that was supplied.  Use with as many items to print as you
    want, just like a print statement.

    :param *args:               Variable number of items to display
    :type *args:                (Any)
    :param title:               Title to display in the window.
    :type title:                (str)
    :param button_color:        button color (foreground, background)
    :type button_color:         (str, str) or str
    :param yes_no:              If True, displays Yes and No buttons instead of Ok
    :type yes_no:               (bool)
    :param auto_close:          if True window will close itself
    :type auto_close:           (bool)
    :param auto_close_duration: Older versions only accept int. Time in seconds until window will close
    :type auto_close_duration:  int | float
    :param size:                (w,h) w=characters-wide, h=rows-high
    :type size:                 (int, int)
    :param location:            Location on the screen to place the upper left corner of the window
    :type location:             (int, int)
    :param relative_location:   (x,y) location relative to the default location of the window, in pixels. Normally the window centers.  This location is relative to the location the window would be created. Note they can be negative.
    :type relative_location:    (int, int)
    :param non_blocking:        if True the call will immediately return rather than waiting on user input
    :type non_blocking:         (bool)
    :param background_color:    color of background
    :type background_color:     (str)
    :param text_color:          color of the text
    :type text_color:           (str)
    :param no_titlebar:         If True no titlebar will be shown
    :type no_titlebar:          (bool)
    :param grab_anywhere:       If True, than can grab anywhere to move the window (Default = False)
    :type grab_anywhere:        (bool)
    :param keep_on_top:         If True the window will remain above all current windows
    :type keep_on_top:          (bool)
    :param font:                specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:                 (str or (str, int[, str]) or None)
    :param image:               Image to include at the top of the popup window
    :type image:                (str) or (bytes)
    :param icon:                filename or base64 string to be used for the window's icon
    :type icon:                 bytes | str
    :param modal:               If True then makes the popup will behave like a Modal window... all other windows are non-operational until this one is closed. Default = True
    :type modal:                bool
    :param no_sizegrip:         If True no Sizegrip will be shown when there is no titlebar. It's only shown if there is no titlebar
    :type no_sizegrip:          (bool)
    :return:                    Returns text of the button that was pressed.  None will be returned if user closed window with X
    :rtype:                     str | None | TIMEOUT_KEY
    """
    ...

def popup_no_buttons(*args, title=..., background_color=..., text_color=..., auto_close=..., auto_close_duration=..., non_blocking=..., icon=..., line_width=..., font=..., no_titlebar=..., grab_anywhere=..., keep_on_top=..., location=..., relative_location=..., image=..., modal=...): # -> None:
    """Show a Popup but without any buttons

    :param *args:               Variable number of items to display
    :type *args:                (Any)
    :param title:               Title to display in the window.
    :type title:                (str)
    :param background_color:    color of background
    :type background_color:     (str)
    :param text_color:          color of the text
    :type text_color:           (str)
    :param auto_close:          if True window will close itself
    :type auto_close:           (bool)
    :param auto_close_duration: Older versions only accept int. Time in seconds until window will close
    :type auto_close_duration:  int | float
    :param non_blocking:        If True then will immediately return from the function without waiting for the user's input. (Default = False)
    :type non_blocking:         (bool)
    :param icon:                filename or base64 string to be used for the window's icon
    :type icon:                 bytes | str
    :param line_width:          Width of lines in characters
    :type line_width:           (int)
    :param font:                specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:                 (str or (str, int[, str]) or None)
    :param no_titlebar:         If True no titlebar will be shown
    :type no_titlebar:          (bool)
    :param grab_anywhere:       If True, than can grab anywhere to move the window (Default = False)
    :type grab_anywhere:        (bool)
    :param location:            Location of upper left corner of the window
    :type location:             (int, int)
    :param relative_location:   (x,y) location relative to the default location of the window, in pixels. Normally the window centers.  This location is relative to the location the window would be created. Note they can be negative.
    :type relative_location:    (int, int)
    :param image:               Image to include at the top of the popup window
    :type image:                (str) or (bytes)
    :param modal:               If True then makes the popup will behave like a Modal window... all other windows are non-operational until this one is closed. Default = True
    :type modal:                bool
    :return:                    Returns text of the button that was pressed.  None will be returned if user closed window with X
    :rtype:                     str | None | TIMEOUT_KEY    """
    ...

def popup_non_blocking(*args, title=..., button_type=..., button_color=..., background_color=..., text_color=..., auto_close=..., auto_close_duration=..., non_blocking=..., icon=..., line_width=..., font=..., no_titlebar=..., grab_anywhere=..., keep_on_top=..., location=..., relative_location=..., image=..., modal=...): # -> str:
    """
    Show Popup window and immediately return (does not block)

    :param *args:               Variable number of items to display
    :type *args:                (Any)
    :param title:               Title to display in the window.
    :type title:                (str)
    :param button_type:         Determines which pre-defined buttons will be shown (Default value = POPUP_BUTTONS_OK).
    :type button_type:          (int)
    :param button_color:        button color (foreground, background)
    :type button_color:         (str, str) or str
    :param background_color:    color of background
    :type background_color:     (str)
    :param text_color:          color of the text
    :type text_color:           (str)
    :param auto_close:          if True window will close itself
    :type auto_close:           (bool)
    :param auto_close_duration: Older versions only accept int. Time in seconds until window will close
    :type auto_close_duration:  int | float
    :param non_blocking:        if True the call will immediately return rather than waiting on user input
    :type non_blocking:         (bool)
    :param icon:                filename or base64 string to be used for the window's icon
    :type icon:                 bytes | str
    :param line_width:          Width of lines in characters
    :type line_width:           (int)
    :param font:                specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:                 (str or (str, int[, str]) or None)
    :param no_titlebar:         If True no titlebar will be shown
    :type no_titlebar:          (bool)
    :param grab_anywhere:       If True: can grab anywhere to move the window (Default = False)
    :type grab_anywhere:        (bool)
    :param location:            Location of upper left corner of the window
    :type location:             (int, int)
    :param relative_location:   (x,y) location relative to the default location of the window, in pixels. Normally the window centers.  This location is relative to the location the window would be created. Note they can be negative.
    :type relative_location:    (int, int)
    :param image:               Image to include at the top of the popup window
    :type image:                (str) or (bytes)
    :param modal:               If True then makes the popup will behave like a Modal window... all other windows are non-operational until this one is closed. Default = False
    :type modal:                bool
    :return:                    Reason for popup closing
    :rtype:                     str | None
    """
    ...

def popup_quick(*args, title=..., button_type=..., button_color=..., background_color=..., text_color=..., auto_close=..., auto_close_duration=..., non_blocking=..., icon=..., line_width=..., font=..., no_titlebar=..., grab_anywhere=..., keep_on_top=..., location=..., relative_location=..., image=..., modal=...): # -> str:
    """
    Show Popup box that doesn't block and closes itself

    :param *args:               Variable number of items to display
    :type *args:                (Any)
    :param title:               Title to display in the window.
    :type title:                (str)
    :param button_type:         Determines which pre-defined buttons will be shown (Default value = POPUP_BUTTONS_OK).
    :type button_type:          (int)
    :param button_color:        button color (foreground, background)
    :type button_color:         (str, str) or str
    :param background_color:    color of background
    :type background_color:     (str)
    :param text_color:          color of the text
    :type text_color:           (str)
    :param auto_close:          if True window will close itself
    :type auto_close:           (bool)
    :param auto_close_duration: Older versions only accept int. Time in seconds until window will close
    :type auto_close_duration:  int | float
    :param non_blocking:        if True the call will immediately return rather than waiting on user input
    :type non_blocking:         (bool)
    :param icon:                filename or base64 string to be used for the window's icon
    :type icon:                 bytes | str
    :param line_width:          Width of lines in characters
    :type line_width:           (int)
    :param font:                specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:                 (str or (str, int[, str]) or None)
    :param no_titlebar:         If True no titlebar will be shown
    :type no_titlebar:          (bool)
    :param grab_anywhere:       If True: can grab anywhere to move the window (Default = False)
    :type grab_anywhere:        (bool)
    :param keep_on_top:         If True the window will remain above all current windows
    :type keep_on_top:          (bool)
    :param location:            Location of upper left corner of the window
    :type location:             (int, int)
    :param relative_location:   (x,y) location relative to the default location of the window, in pixels. Normally the window centers.  This location is relative to the location the window would be created. Note they can be negative.
    :type relative_location:    (int, int)
    :param image:               Image to include at the top of the popup window
    :type image:                (str) or (bytes)
    :param modal:               If True then makes the popup will behave like a Modal window... all other windows are non-operational until this one is closed. Default = False
    :type modal:                bool
    :return:                    Returns text of the button that was pressed.  None will be returned if user closed window with X
    :rtype:                     str | None | TIMEOUT_KEY
    """
    ...

def popup_quick_message(*args, title=..., button_type=..., button_color=..., background_color=..., text_color=..., auto_close=..., auto_close_duration=..., non_blocking=..., icon=..., line_width=..., font=..., no_titlebar=..., grab_anywhere=..., keep_on_top=..., location=..., relative_location=..., image=..., modal=...): # -> str:
    """
    Show Popup window with no titlebar, doesn't block, and auto closes itself.

    :param *args:               Variable number of items to display
    :type *args:                (Any)
    :param title:               Title to display in the window.
    :type title:                (str)
    :param button_type:         Determines which pre-defined buttons will be shown (Default value = POPUP_BUTTONS_OK).
    :type button_type:          (int)
    :param button_color:        button color (foreground, background)
    :type button_color:         (str, str) or str
    :param keep_on_top:         If True the window will remain above all current windows
    :type keep_on_top:          (bool)
    :param background_color:    color of background
    :type background_color:     (str)
    :param text_color:          color of the text
    :type text_color:           (str)
    :param auto_close:          if True window will close itself
    :type auto_close:           (bool)
    :param auto_close_duration: Older versions only accept int. Time in seconds until window will close
    :type auto_close_duration:  int | float
    :param non_blocking:        if True the call will immediately return rather than waiting on user input
    :type non_blocking:         (bool)
    :param icon:                filename or base64 string to be used for the window's icon
    :type icon:                 bytes | str
    :param line_width:          Width of lines in characters
    :type line_width:           (int)
    :param font:                specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:                 (str or (str, int[, str]) or None)
    :param no_titlebar:         If True no titlebar will be shown
    :type no_titlebar:          (bool)
    :param grab_anywhere:       If True: can grab anywhere to move the window (Default = False)
    :type grab_anywhere:        (bool)
    :param location:            Location of upper left corner of the window
    :type location:             (int, int)
    :param relative_location:   (x,y) location relative to the default location of the window, in pixels. Normally the window centers.  This location is relative to the location the window would be created. Note they can be negative.
    :type relative_location:    (int, int)
    :param image:               Image to include at the top of the popup window
    :type image:                (str) or (bytes)
    :param modal:               If True then makes the popup will behave like a Modal window... all other windows are non-operational until this one is closed. Default = False
    :type modal:                bool
    :return:                    Returns text of the button that was pressed.  None will be returned if user closed window with X
    :rtype:                     str | None | TIMEOUT_KEY
    """
    ...

def popup_no_titlebar(*args, title=..., button_type=..., button_color=..., background_color=..., text_color=..., auto_close=..., auto_close_duration=..., non_blocking=..., icon=..., line_width=..., font=..., grab_anywhere=..., keep_on_top=..., location=..., relative_location=..., image=..., modal=...): # -> str:
    """
    Display a Popup without a titlebar.   Enables grab anywhere so you can move it

    :param *args:               Variable number of items to display
    :type *args:                (Any)
    :param title:               Title to display in the window.
    :type title:                (str)
    :param button_type:         Determines which pre-defined buttons will be shown (Default value = POPUP_BUTTONS_OK).
    :type button_type:          (int)
    :param button_color:        button color (foreground, background)
    :type button_color:         (str, str) or str
    :param background_color:    color of background
    :type background_color:     (str)
    :param text_color:          color of the text
    :type text_color:           (str)
    :param auto_close:          if True window will close itself
    :type auto_close:           (bool)
    :param auto_close_duration: Older versions only accept int. Time in seconds until window will close
    :type auto_close_duration:  int | float
    :param non_blocking:        if True the call will immediately return rather than waiting on user input
    :type non_blocking:         (bool)
    :param icon:                filename or base64 string to be used for the window's icon
    :type icon:                 bytes | str
    :param line_width:          Width of lines in characters
    :type line_width:           (int)
    :param font:                specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:                 (str or (str, int[, str]) or None)
    :param grab_anywhere:       If True: can grab anywhere to move the window (Default = False)
    :type grab_anywhere:        (bool)
    :param keep_on_top:         If True the window will remain above all current windows
    :type keep_on_top:          (bool)
    :param location:            Location of upper left corner of the window
    :type location:             (int, int)
    :param relative_location:   (x,y) location relative to the default location of the window, in pixels. Normally the window centers.  This location is relative to the location the window would be created. Note they can be negative.
    :type relative_location:    (int, int)
    :param image:               Image to include at the top of the popup window
    :type image:                (str) or (bytes)
    :param modal:               If True then makes the popup will behave like a Modal window... all other windows are non-operational until this one is closed. Default = True
    :type modal:                bool
    :return:                    Returns text of the button that was pressed.  None will be returned if user closed window with X
    :rtype:                     str | None | TIMEOUT_KEY
    """
    ...

def popup_auto_close(*args, title=..., button_type=..., button_color=..., background_color=..., text_color=..., auto_close=..., auto_close_duration=..., non_blocking=..., icon=..., line_width=..., font=..., no_titlebar=..., grab_anywhere=..., keep_on_top=..., location=..., relative_location=..., image=..., modal=...): # -> str:
    """Popup that closes itself after some time period

    :param *args:               Variable number of items to display
    :type *args:                (Any)
    :param title:               Title to display in the window.
    :type title:                (str)
    :param button_type:         Determines which pre-defined buttons will be shown (Default value = POPUP_BUTTONS_OK).
    :type button_type:          (int)
    :param button_color:        button color (foreground, background)
    :type button_color:         (str, str) or str
    :param background_color:    color of background
    :type background_color:     (str)
    :param text_color:          color of the text
    :type text_color:           (str)
    :param auto_close:          if True window will close itself
    :type auto_close:           (bool)
    :param auto_close_duration: Older versions only accept int. Time in seconds until window will close
    :type auto_close_duration:  int | float
    :param non_blocking:        if True the call will immediately return rather than waiting on user input
    :type non_blocking:         (bool)
    :param icon:                filename or base64 string to be used for the window's icon
    :type icon:                 bytes | str
    :param line_width:          Width of lines in characters
    :type line_width:           (int)
    :param font:                specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:                 (str or (str, int[, str]) or None)
    :param no_titlebar:         If True no titlebar will be shown
    :type no_titlebar:          (bool)
    :param grab_anywhere:       If True: can grab anywhere to move the window (Default = False)
    :type grab_anywhere:        (bool)
    :param keep_on_top:         If True the window will remain above all current windows
    :type keep_on_top:          (bool)
    :param location:            Location of upper left corner of the window
    :type location:             (int, int)
    :param relative_location:   (x,y) location relative to the default location of the window, in pixels. Normally the window centers.  This location is relative to the location the window would be created. Note they can be negative.
    :type relative_location:    (int, int)
    :param image:               Image to include at the top of the popup window
    :type image:                (str) or (bytes)
    :param modal:               If True then makes the popup will behave like a Modal window... all other windows are non-operational until this one is closed. Default = True
    :type modal:                bool
    :return:                    Returns text of the button that was pressed.  None will be returned if user closed window with X
    :rtype:                     str | None | TIMEOUT_KEY
    """
    ...

def popup_error(*args, title=..., button_color=..., background_color=..., text_color=..., auto_close=..., auto_close_duration=..., non_blocking=..., icon=..., line_width=..., font=..., no_titlebar=..., grab_anywhere=..., keep_on_top=..., location=..., relative_location=..., image=..., modal=...): # -> str:
    """
    Popup with colored button and 'Error' as button text

    :param *args:               Variable number of items to display
    :type *args:                (Any)
    :param title:               Title to display in the window.
    :type title:                (str)
    :param button_color:        button color (foreground, background)
    :type button_color:         (str, str) or str
    :param background_color:    color of background
    :type background_color:     (str)
    :param text_color:          color of the text
    :type text_color:           (str)
    :param auto_close:          if True window will close itself
    :type auto_close:           (bool)
    :param auto_close_duration: Older versions only accept int. Time in seconds until window will close
    :type auto_close_duration:  int | float
    :param non_blocking:        if True the call will immediately return rather than waiting on user input
    :type non_blocking:         (bool)
    :param icon:                filename or base64 string to be used for the window's icon
    :type icon:                 bytes | str
    :param line_width:          Width of lines in characters
    :type line_width:           (int)
    :param font:                specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:                 (str or (str, int[, str]) or None)
    :param no_titlebar:         If True no titlebar will be shown
    :type no_titlebar:          (bool)
    :param grab_anywhere:       If True: can grab anywhere to move the window (Default = False)
    :type grab_anywhere:        (bool)
    :param keep_on_top:         If True the window will remain above all current windows
    :type keep_on_top:          (bool)
    :param location:            Location of upper left corner of the window
    :type location:             (int, int)
    :param relative_location:   (x,y) location relative to the default location of the window, in pixels. Normally the window centers.  This location is relative to the location the window would be created. Note they can be negative.
    :type relative_location:    (int, int)
    :param image:               Image to include at the top of the popup window
    :type image:                (str) or (bytes)
    :param modal:               If True then makes the popup will behave like a Modal window... all other windows are non-operational until this one is closed. Default = True
    :type modal:                bool
    :return:                    Returns text of the button that was pressed.  None will be returned if user closed window with X
    :rtype:                     str | None | TIMEOUT_KEY
    """
    ...

def popup_cancel(*args, title=..., button_color=..., background_color=..., text_color=..., auto_close=..., auto_close_duration=..., non_blocking=..., icon=..., line_width=..., font=..., no_titlebar=..., grab_anywhere=..., keep_on_top=..., location=..., relative_location=..., image=..., modal=...): # -> str:
    """
    Display Popup with "cancelled" button text

    :param *args:               Variable number of items to display
    :type *args:                (Any)
    :param title:               Title to display in the window.
    :type title:                (str)
    :param button_color:        button color (foreground, background)
    :type button_color:         (str, str) or str
    :param background_color:    color of background
    :type background_color:     (str)
    :param text_color:          color of the text
    :type text_color:           (str)
    :param auto_close:          if True window will close itself
    :type auto_close:           (bool)
    :param auto_close_duration: Older versions only accept int. Time in seconds until window will close
    :type auto_close_duration:  int | float
    :param non_blocking:        if True the call will immediately return rather than waiting on user input
    :type non_blocking:         (bool)
    :param icon:                filename or base64 string to be used for the window's icon
    :type icon:                 bytes | str
    :param line_width:          Width of lines in characters
    :type line_width:           (int)
    :param font:                specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:                 (str or (str, int[, str]) or None)
    :param no_titlebar:         If True no titlebar will be shown
    :type no_titlebar:          (bool)
    :param grab_anywhere:       If True: can grab anywhere to move the window (Default = False)
    :type grab_anywhere:        (bool)
    :param keep_on_top:         If True the window will remain above all current windows
    :type keep_on_top:          (bool)
    :param location:            Location of upper left corner of the window
    :type location:             (int, int)
    :param relative_location:   (x,y) location relative to the default location of the window, in pixels. Normally the window centers.  This location is relative to the location the window would be created. Note they can be negative.
    :type relative_location:    (int, int)
    :param image:               Image to include at the top of the popup window
    :type image:                (str) or (bytes)
    :param modal:               If True then makes the popup will behave like a Modal window... all other windows are non-operational until this one is closed. Default = True
    :type modal:                bool
    :return:                    Returns text of the button that was pressed.  None will be returned if user closed window with X
    :rtype:                     str | None | TIMEOUT_KEY
    """
    ...

def popup_ok(*args, title=..., button_color=..., background_color=..., text_color=..., auto_close=..., auto_close_duration=..., non_blocking=..., icon=..., line_width=..., font=..., no_titlebar=..., grab_anywhere=..., keep_on_top=..., location=..., relative_location=..., image=..., modal=...): # -> str:
    """
    Display Popup with OK button only

    :param *args:               Variable number of items to display
    :type *args:                (Any)
    :param title:               Title to display in the window.
    :type title:                (str)
    :param button_color:        button color (foreground, background)
    :type button_color:         (str, str) or str
    :param background_color:    color of background
    :type background_color:     (str)
    :param text_color:          color of the text
    :type text_color:           (str)
    :param auto_close:          if True window will close itself
    :type auto_close:           (bool)
    :param auto_close_duration: Older versions only accept int. Time in seconds until window will close
    :type auto_close_duration:  int | float
    :param non_blocking:        if True the call will immediately return rather than waiting on user input
    :type non_blocking:         (bool)
    :param icon:                filename or base64 string to be used for the window's icon
    :type icon:                 bytes | str
    :param line_width:          Width of lines in characters
    :type line_width:           (int)
    :param font:                specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:                 (str or (str, int[, str]) or None)
    :param no_titlebar:         If True no titlebar will be shown
    :type no_titlebar:          (bool)
    :param grab_anywhere:       If True: can grab anywhere to move the window (Default = False)
    :type grab_anywhere:        (bool)
    :param keep_on_top:         If True the window will remain above all current windows
    :type keep_on_top:          (bool)
    :param location:            Location of upper left corner of the window
    :type location:             (int, int)
    :param relative_location:   (x,y) location relative to the default location of the window, in pixels. Normally the window centers.  This location is relative to the location the window would be created. Note they can be negative.
    :type relative_location:    (int, int)
    :param image:               Image to include at the top of the popup window
    :type image:                (str) or (bytes)
    :param modal:               If True then makes the popup will behave like a Modal window... all other windows are non-operational until this one is closed. Default = True
    :type modal:                bool
    :return:                    Returns text of the button that was pressed.  None will be returned if user closed window with X
    :rtype:                     str | None | TIMEOUT_KEY
    """
    ...

def popup_ok_cancel(*args, title=..., button_color=..., background_color=..., text_color=..., auto_close=..., auto_close_duration=..., non_blocking=..., icon=..., line_width=..., font=..., no_titlebar=..., grab_anywhere=..., keep_on_top=..., location=..., relative_location=..., image=..., modal=...): # -> str:
    """
    Display popup with OK and Cancel buttons

    :param *args:               Variable number of items to display
    :type *args:                (Any)
    :param title:               Title to display in the window.
    :type title:                (str)
    :param button_color:        button color (foreground, background)
    :type button_color:         (str, str) or str
    :param background_color:    color of background
    :type background_color:     (str)
    :param text_color:          color of the text
    :type text_color:           (str)
    :param auto_close:          if True window will close itself
    :type auto_close:           (bool)
    :param auto_close_duration: Older versions only accept int. Time in seconds until window will close
    :type auto_close_duration:  int | float
    :param non_blocking:        if True the call will immediately return rather than waiting on user input
    :type non_blocking:         (bool)
    :param icon:                filename or base64 string to be used for the window's icon
    :type icon:                 bytes | str
    :param line_width:          Width of lines in characters
    :type line_width:           (int)
    :param font:                specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:                 (str or (str, int[, str]) or None)
    :param no_titlebar:         If True no titlebar will be shown
    :type no_titlebar:          (bool)
    :param grab_anywhere:       If True: can grab anywhere to move the window (Default = False)
    :type grab_anywhere:        (bool)
    :param keep_on_top:         If True the window will remain above all current windows
    :type keep_on_top:          (bool)
    :param location:            Location of upper left corner of the window
    :type location:             (int, int)
    :param relative_location:   (x,y) location relative to the default location of the window, in pixels. Normally the window centers.  This location is relative to the location the window would be created. Note they can be negative.
    :type relative_location:    (int, int)
    :param image:               Image to include at the top of the popup window
    :type image:                (str) or (bytes)
    :param modal:               If True then makes the popup will behave like a Modal window... all other windows are non-operational until this one is closed. Default = True
    :type modal:                bool
    :return:                    clicked button
    :rtype:                     "OK" | "Cancel" | None
    """
    ...

def popup_yes_no(*args, title=..., button_color=..., background_color=..., text_color=..., auto_close=..., auto_close_duration=..., non_blocking=..., icon=..., line_width=..., font=..., no_titlebar=..., grab_anywhere=..., keep_on_top=..., location=..., relative_location=..., image=..., modal=...): # -> str:
    """
    Display Popup with Yes and No buttons

    :param *args:               Variable number of items to display
    :type *args:                (Any)
    :param title:               Title to display in the window.
    :type title:                (str)
    :param button_color:        button color (foreground, background)
    :type button_color:         (str, str) or str
    :param background_color:    color of background
    :type background_color:     (str)
    :param text_color:          color of the text
    :type text_color:           (str)
    :param auto_close:          if True window will close itself
    :type auto_close:           (bool)
    :param auto_close_duration: Older versions only accept int. Time in seconds until window will close
    :type auto_close_duration:  int | float
    :param non_blocking:        if True the call will immediately return rather than waiting on user input
    :type non_blocking:         (bool)
    :param icon:                filename or base64 string to be used for the window's icon
    :type icon:                 bytes | str
    :param line_width:          Width of lines in characters
    :type line_width:           (int)
    :param font:                specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:                 (str or (str, int[, str]) or None)
    :param no_titlebar:         If True no titlebar will be shown
    :type no_titlebar:          (bool)
    :param grab_anywhere:       If True: can grab anywhere to move the window (Default = False)
    :type grab_anywhere:        (bool)
    :param keep_on_top:         If True the window will remain above all current windows
    :type keep_on_top:          (bool)
    :param location:            Location of upper left corner of the window
    :type location:             (int, int)
    :param relative_location:   (x,y) location relative to the default location of the window, in pixels. Normally the window centers.  This location is relative to the location the window would be created. Note they can be negative.
    :type relative_location:    (int, int)
    :param image:               Image to include at the top of the popup window
    :type image:                (str) or (bytes)
    :param modal:               If True then makes the popup will behave like a Modal window... all other windows are non-operational until this one is closed. Default = True
    :type modal:                bool
    :return:                    clicked button
    :rtype:                     "Yes" | "No" | None
    """
    ...

def popup_get_folder(message, title=..., default_path=..., no_window=..., size=..., button_color=..., background_color=..., text_color=..., icon=..., font=..., no_titlebar=..., grab_anywhere=..., keep_on_top=..., location=..., relative_location=..., initial_folder=..., image=..., modal=..., history=..., history_setting_filename=...):
    """
    Display popup with text entry field and browse button so that a folder can be chosen.

    :param message:                  message displayed to user
    :type message:                   (str)
    :param title:                    Window title
    :type title:                     (str)
    :param default_path:             path to display to user as starting point (filled into the input field)
    :type default_path:              (str)
    :param no_window:                if True, no PySimpleGUI window will be shown. Instead just the tkinter dialog is shown
    :type no_window:                 (bool)
    :param size:                     (width, height) of the InputText Element
    :type size:                      (int, int)
    :param button_color:             button color (foreground, background)
    :type button_color:              (str, str) or str
    :param background_color:         color of background
    :type background_color:          (str)
    :param text_color:               color of the text
    :type text_color:                (str)
    :param icon:                     filename or base64 string to be used for the window's icon
    :type icon:                      bytes | str
    :param font:                     specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:                      (str or (str, int[, str]) or None)
    :param no_titlebar:              If True no titlebar will be shown
    :type no_titlebar:               (bool)
    :param grab_anywhere:            If True: can grab anywhere to move the window (Default = False)
    :type grab_anywhere:             (bool)
    :param keep_on_top:              If True the window will remain above all current windows
    :type keep_on_top:               (bool)
    :param location:                 Location of upper left corner of the window
    :type location:                  (int, int)
    :param relative_location:        (x,y) location relative to the default location of the window, in pixels. Normally the window centers.  This location is relative to the location the window would be created. Note they can be negative.
    :type relative_location:         (int, int)
    :param initial_folder:           location in filesystem to begin browsing
    :type initial_folder:            (str)
    :param image:                    Image to include at the top of the popup window
    :type image:                     (str) or (bytes)
    :param modal:                    If True then makes the popup will behave like a Modal window... all other windows are non-operational until this one is closed. Default = True
    :type modal:                     bool
    :param history:                  If True then enable a "history" feature that will display previous entries used. Uses settings filename provided or default if none provided
    :type history:                   bool
    :param history_setting_filename: Filename to use for the User Settings. Will store list of previous entries in this settings file
    :type history_setting_filename:  (str)
    :return:                         string representing the path chosen, None if cancelled or window closed with X
    :rtype:                          str | None
    """
    ...

def popup_get_file(message, title=..., default_path=..., default_extension=..., save_as=..., multiple_files=..., file_types=..., no_window=..., size=..., button_color=..., background_color=..., text_color=..., icon=..., font=..., no_titlebar=..., grab_anywhere=..., keep_on_top=..., location=..., relative_location=..., initial_folder=..., image=..., files_delimiter=..., modal=..., history=..., show_hidden=..., history_setting_filename=...):
    """
    Display popup window with text entry field and browse button so that a file can be chosen by user.

    :param message:                  message displayed to user
    :type message:                   (str)
    :param title:                    Window title
    :type title:                     (str)
    :param default_path:             path to display to user as starting point (filled into the input field)
    :type default_path:              (str)
    :param default_extension:        If no extension entered by user, add this to filename (only used in saveas dialogs)
    :type default_extension:         (str)
    :param save_as:                  if True, the "save as" dialog is shown which will verify before overwriting
    :type save_as:                   (bool)
    :param multiple_files:           if True, then allows multiple files to be selected that are returned with ';' between each filename
    :type multiple_files:            (bool)
    :param file_types:               List of extensions to show using wildcards. All files (the default) = (("ALL Files", "*.* *"),). NOT avoilable on the MAC
    :type file_types:                Tuple[Tuple[str,str]]
    :param no_window:                if True, no PySimpleGUI window will be shown. Instead just the tkinter dialog is shown
    :type no_window:                 (bool)
    :param size:                     (width, height) of the InputText Element or Combo element if using history feature
    :type size:                      (int, int)
    :param button_color:             Color of the button (text, background)
    :type button_color:              (str, str) or str
    :param background_color:         background color of the entire window
    :type background_color:          (str)
    :param text_color:               color of the text
    :type text_color:                (str)
    :param icon:                     filename or base64 string to be used for the window's icon
    :type icon:                      bytes | str
    :param font:                     specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:                      (str or (str, int[, str]) or None)
    :param no_titlebar:              If True no titlebar will be shown
    :type no_titlebar:               (bool)
    :param grab_anywhere:            If True: can grab anywhere to move the window (Default = False)
    :type grab_anywhere:             (bool)
    :param keep_on_top:              If True the window will remain above all current windows
    :type keep_on_top:               (bool)
    :param location:                 Location of upper left corner of the window
    :type location:                  (int, int)
    :param relative_location:        (x,y) location relative to the default location of the window, in pixels. Normally the window centers.  This location is relative to the location the window would be created. Note they can be negative.
    :type relative_location:         (int, int)
    :param initial_folder:           location in filesystem to begin browsing
    :type initial_folder:            (str)
    :param image:                    Image to include at the top of the popup window
    :type image:                     (str) or (bytes)
    :param files_delimiter:          String to place between files when multiple files are selected. Normally a ;
    :type files_delimiter:           str
    :param modal:                    If True then makes the popup will behave like a Modal window... all other windows are non-operational until this one is closed. Default = True
    :type modal:                     bool
    :param history:                  If True then enable a "history" feature that will display previous entries used. Uses settings filename provided or default if none provided
    :type history:                   bool
    :param show_hidden:              If True then enables the checkbox in the system dialog to select hidden files to be shown
    :type show_hidden:               bool
    :param history_setting_filename: Filename to use for the User Settings. Will store list of previous entries in this settings file
    :type history_setting_filename:  (str)
    :return:                         string representing the file(s) chosen, None if cancelled or window closed with X
    :rtype:                          str | None
    """
    ...

def popup_get_text(message, title=..., default_text=..., password_char=..., size=..., button_color=..., background_color=..., text_color=..., icon=..., font=..., no_titlebar=..., grab_anywhere=..., keep_on_top=..., location=..., relative_location=..., image=..., modal=...): # -> None:
    """
    Display Popup with text entry field. Returns the text entered or None if closed / cancelled

    :param message:          message displayed to user
    :type message:           (str)
    :param title:            Window title
    :type title:             (str)
    :param default_text:     default value to put into input area
    :type default_text:      (str)
    :param password_char:    character to be shown instead of actually typed characters
    :type password_char:     (str)
    :param size:             (width, height) of the InputText Element
    :type size:              (int, int)
    :param button_color:     Color of the button (text, background)
    :type button_color:      (str, str) or str
    :param background_color: background color of the entire window
    :type background_color:  (str)
    :param text_color:       color of the message text
    :type text_color:        (str)
    :param icon:             filename or base64 string to be used for the window's icon
    :type icon:              bytes | str
    :param font:             specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:              (str or (str, int[, str]) or None)
    :param no_titlebar:      If True no titlebar will be shown
    :type no_titlebar:       (bool)
    :param grab_anywhere:    If True can click and drag anywhere in the window to move the window
    :type grab_anywhere:     (bool)
    :param keep_on_top:      If True the window will remain above all current windows
    :type keep_on_top:       (bool)
    :param location:         (x,y) Location on screen to display the upper left corner of window
    :type location:          (int, int)
    :param relative_location: (x,y) location relative to the default location of the window, in pixels. Normally the window centers.  This location is relative to the location the window would be created. Note they can be negative.
    :type relative_location: (int, int)
    :param image:            Image to include at the top of the popup window
    :type image:             (str) or (bytes)
    :param modal:            If True then makes the popup will behave like a Modal window... all other windows are non-operational until this one is closed. Default = True
    :type modal:             bool
    :return:                 Text entered or None if window was closed or cancel button clicked
    :rtype:                  str | None
    """
    ...

def popup_get_date(start_mon=..., start_day=..., start_year=..., begin_at_sunday_plus=..., no_titlebar=..., title=..., keep_on_top=..., location=..., relative_location=..., close_when_chosen=..., icon=..., locale=..., month_names=..., day_abbreviations=..., modal=...):
    """
    Display a calendar window, get the user's choice, return as a tuple (mon, day, year)

    :param start_mon:            The starting month
    :type start_mon:             (int)
    :param start_day:            The starting day - optional. Set to None or 0 if no date to be chosen at start
    :type start_day:             int | None
    :param start_year:           The starting year
    :type start_year:            (int)
    :param begin_at_sunday_plus: Determines the left-most day in the display. 0=sunday, 1=monday, etc
    :type begin_at_sunday_plus:  (int)
    :param icon:                 Same as Window icon parameter. Can be either a filename or Base64 value. For Windows if filename, it MUST be ICO format. For Linux, must NOT be ICO
    :type icon:                  (str | bytes)
    :param location:             (x,y) location on the screen to place the top left corner of your window. Default is to center on screen
    :type location:              (int, int)
    :param relative_location:    (x,y) location relative to the default location of the window, in pixels. Normally the window centers.  This location is relative to the location the window would be created. Note they can be negative.
    :type relative_location:     (int, int)
    :param title:                Title that will be shown on the window
    :type title:                 (str)
    :param close_when_chosen:    If True, the window will close and function return when a day is clicked
    :type close_when_chosen:     (bool)
    :param locale:               locale used to get the day names
    :type locale:                (str)
    :param no_titlebar:          If True no titlebar will be shown
    :type no_titlebar:           (bool)
    :param keep_on_top:          If True the window will remain above all current windows
    :type keep_on_top:           (bool)
    :param month_names:          optional list of month names to use (should be 12 items)
    :type month_names:           List[str]
    :param day_abbreviations:    optional list of abbreviations to display as the day of week
    :type day_abbreviations:     List[str]
    :param modal:                If True then makes the popup will behave like a Modal window... all other windows are non-operational until this one is closed. Default = True
    :type modal:                 bool
    :return:                     Tuple containing (month, day, year) of chosen date or None if was cancelled
    :rtype:                      None | (int, int, int)
    """
    ...

def popup_animated(image_source, message=..., background_color=..., text_color=..., font=..., no_titlebar=..., grab_anywhere=..., keep_on_top=..., location=..., relative_location=..., alpha_channel=..., time_between_frames=..., transparent_color=..., title=..., icon=...): # -> bool | None:
    """
     Show animation one frame at a time.  This function has its own internal clocking meaning you can call it at any frequency
     and the rate the frames of video is shown remains constant.  Maybe your frames update every 30 ms but your
     event loop is running every 10 ms.  You don't have to worry about delaying, just call it every time through the
     loop.

    :param image_source:        Either a filename or a base64 string. Use None to close the window.
    :type image_source:         str | bytes | None
    :param message:             An optional message to be shown with the animation
    :type message:              (str)
    :param background_color:    color of background
    :type background_color:     (str)
    :param text_color:          color of the text
    :type text_color:           (str)
    :param font:                specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:                 str | tuple
    :param no_titlebar:         If True then the titlebar and window frame will not be shown
    :type no_titlebar:          (bool)
    :param grab_anywhere:       If True then you can move the window just clicking anywhere on window, hold and drag
    :type grab_anywhere:        (bool)
    :param keep_on_top:         If True then Window will remain on top of all other windows currently shownn
    :type keep_on_top:          (bool)
    :param location:            (x,y) location on the screen to place the top left corner of your window. Default is to center on screen
    :type location:             (int, int)
    :param relative_location:   (x,y) location relative to the default location of the window, in pixels. Normally the window centers.  This location is relative to the location the window would be created. Note they can be negative.
    :type relative_location:    (int, int)
    :param alpha_channel:       Window transparency 0 = invisible 1 = completely visible. Values between are see through
    :type alpha_channel:        (float)
    :param time_between_frames: Amount of time in milliseconds between each frame
    :type time_between_frames:  (int)
    :param transparent_color:   This color will be completely see-through in your window. Can even click through
    :type transparent_color:    (str)
    :param title:               Title that will be shown on the window
    :type title:                (str)
    :param icon:                Same as Window icon parameter. Can be either a filename or Base64 byte string. For Windows if filename, it MUST be ICO format. For Linux, must NOT be ICO
    :type icon:                 str | bytes
    :return:                    True if the window updated OK. False if the window was closed
    :rtype:                     bool
    """
    ...

def popup_notify(*args, title=..., icon=..., display_duration_in_ms=..., fade_in_duration=..., alpha=..., location=...): # -> str:
    """
    Displays a "notification window", usually in the bottom right corner of your display.  Has an icon, a title, and a message.  It is more like a "toaster" window than the normal popups.

    The window will slowly fade in and out if desired.  Clicking on the window will cause it to move through the end the current "phase". For example, if the window was fading in and it was clicked, then it would immediately stop fading in and instead be fully visible.  It's a way for the user to quickly dismiss the window.

    The return code specifies why the call is returning (e.g. did the user click the message to dismiss it)

    :param title:                  Text to be shown at the top of the window in a larger font
    :type title:                   (str)
    :param message:                Text message that makes up the majority of the window
    :type message:                 (str)
    :param icon:                   A base64 encoded PNG/GIF image or PNG/GIF filename that will be displayed in the window
    :type icon:                    bytes | str
    :param display_duration_in_ms: Number of milliseconds to show the window
    :type display_duration_in_ms:  (int)
    :param fade_in_duration:       Number of milliseconds to fade window in and out
    :type fade_in_duration:        (int)
    :param alpha:                  Alpha channel. 0 - invisible 1 - fully visible
    :type alpha:                   (float)
    :param location:               Location on the screen to display the window
    :type location:                (int, int)
    :return:                       reason for returning
    :rtype:                        (int)
    """
    ...

def popup_menu(window, element, menu_def, title=..., location=...): # -> None:
    """
    Makes a "popup menu"
    This type of menu is what you get when a normal menu or a right click menu is torn off
    The settings for the menu are obtained from the window parameter's Window


    :param window:   The window associated with the popup menu. The theme and right click menu settings for this window will be used
    :type window:    Window
    :param element:  An element in your window to associate the menu to. It can be any element
    :type element:   Element
    :param menu_def: A menu definition. This will be the same format as used for Right Click Menus1
    :type  menu_def: List[List[ List[str] | str ]]
    :param title:    The title that will be shown on the torn off menu window. Defaults to window titlr
    :type title:     str
    :param location: The location on the screen to place the window
    :type location:  (int, int) | (None, None)
    """
    ...

def popup_error_with_traceback(title, *messages): # -> None:
    """
    Show an error message and as many additoinal lines of messages as you want.
    Will show the same error window as PySimpleGUI uses internally.  Has a button to
    take the user to the line of code you called this popup from

    :param title:    The title that will be shown in the popup's titlebar and in the first line of the window
    :type title:     str
    :param messages: A variable number of lines of messages you wish to show your user
    :type messages:  *Any
    """
    ...

def shell_with_animation(command, args=..., image_source=..., message=..., background_color=..., text_color=..., font=..., no_titlebar=..., grab_anywhere=..., keep_on_top=..., location=..., alpha_channel=..., time_between_frames=..., transparent_color=...): # -> str:
    """
    Execute a "shell command" (anything capable of being launched using subprocess.run) and
    while the command is running, show an animated popup so that the user knows that a long-running
    command is being executed.  Without this mechanism, the GUI appears locked up.

    :param command:             The command to run
    :type command:              (str)
    :param args:                List of arguments
    :type args:                 List[str]
    :param image_source:        Either a filename or a base64 string.
    :type image_source:         str | bytes
    :param message:             An optional message to be shown with the animation
    :type message:              (str)
    :param background_color:    color of background
    :type background_color:     (str)
    :param text_color:          color of the text
    :type text_color:           (str)
    :param font:                specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:                 str | tuple
    :param no_titlebar:         If True then the titlebar and window frame will not be shown
    :type no_titlebar:          (bool)
    :param grab_anywhere:       If True then you can move the window just clicking anywhere on window, hold and drag
    :type grab_anywhere:        (bool)
    :param keep_on_top:         If True then Window will remain on top of all other windows currently shownn
    :type keep_on_top:          (bool)
    :param location:            (x,y) location on the screen to place the top left corner of your window. Default is to center on screen
    :type location:             (int, int)
    :param alpha_channel:       Window transparency 0 = invisible 1 = completely visible. Values between are see through
    :type alpha_channel:        (float)
    :param time_between_frames: Amount of time in milliseconds between each frame
    :type time_between_frames:  (int)
    :param transparent_color:   This color will be completely see-through in your window. Can even click through
    :type transparent_color:    (str)
    :return:                    The resulting string output from stdout
    :rtype:                     (str)
    """
    ...

class UserSettings:
    _default_for_function_interface: UserSettings = ...
    def __init__(self, filename=..., path=..., silent_on_error=..., autosave=..., use_config_file=..., convert_bools_and_none=...) -> None:
        """
        User Settings

        :param filename:               The name of the file to use. Can be a full path and filename or just filename
        :type filename:                (str or None)
        :param path:                   The folder that the settings file will be stored in. Do not include the filename.
        :type path:                    (str or None)
        :param silent_on_error:        If True errors will not be reported
        :type silent_on_error:         (bool)
        :param autosave:               If True the settings file is saved after every update
        :type autosave:                (bool)
        :param use_config_file:        If True then the file format will be a config.ini rather than json
        :type use_config_file:         (bool)
        :param convert_bools_and_none: If True then "True", "False", "None" will be converted to the Python values True, False, None when using INI files. Default is TRUE
        :type convert_bools_and_none:  (bool)
        """
        ...
    
    class _SectionDict:
        item_count = ...
        def __init__(self, section_name, section_dict, config, user_settings_parent) -> None:
            """
            The Section Dictionary.  It holds the values for a section.

            :param section_name:                Name of the section
            :type section_name:                 str
            :param section_dict:                Dictionary of values for the section
            :type section_dict:                 dict
            :param config:                      The configparser object
            :type config:                       configparser.ConfigParser
            :param user_settings_parent:        The parent UserSettings object that hdas this section
            :type user_settings_parent:         UserSettings
            """
            ...
        
        def __repr__(self): # -> LiteralString:
            """
            Converts the settings dictionary into a string for easy display

            :return: the dictionary as a string
            :rtype:  (str)
            """
            ...
        
        def get(self, key, default=...): # -> bool | None:
            """
            Returns the value of a specified setting.  If the setting is not found in the settings dictionary, then
            the user specified default value will be returned.  It no default is specified and nothing is found, then
            the "default value" is returned.  This default can be specified in this call, or previously defined
            by calling set_default. If nothing specified now or previously, then None is returned as default.

            :param key:     Key used to lookup the setting in the settings dictionary
            :type key:      (Any)
            :param default: Value to use should the key not be found in the dictionary
            :type default:  (Any)
            :return:        Value of specified settings
            :rtype:         (Any)
            """
            ...
        
        def set(self, key, value): # -> None:
            ...
        
        def delete_section(self): # -> None:
            ...
        
        def __getitem__(self, item): # -> bool | None:
            ...
        
        def __setitem__(self, item, value): # -> None:
            """
            Enables setting a setting by using [ ] notation like a dictionary.
            Your code will have this kind of design pattern:
            settings = sg.UserSettings()
            settings[item] = value

            :param item:  The key for the setting to change. Needs to be a hashable type. Basically anything but a list
            :type item:   Any
            :param value: The value to set the setting to
            :type value:  Any
            """
            ...
        
        def __delitem__(self, item): # -> None:
            """
            Delete an individual user setting.  This is the same as calling delete_entry.  The syntax
            for deleting the item using this manner is:
                del settings['entry']
            :param item: The key for the setting to delete
            :type item:  Any
            """
            ...
        
    
    
    def __repr__(self): # -> str:
        """
        Converts the settings dictionary into a string for easy display

        :return: the dictionary as a string
        :rtype:  (str)
        """
        ...
    
    def set_default_value(self, default): # -> None:
        """
        Set the value that will be returned if a requested setting is not found

        :param default: value to be returned if a setting is not found in the settings dictionary
        :type default:  Any
        """
        ...
    
    def set_location(self, filename=..., path=...): # -> None:
        """
        Sets the location of the settings file

        :param filename: The name of the file to use. Can be a full path and filename or just filename
        :type filename:  (str or None)
        :param path:     The folder that the settings file will be stored in. Do not include the filename.
        :type path:      (str or None)
        """
        ...
    
    def get_filename(self, filename=..., path=...): # -> None:
        """
        Sets the filename and path for your settings file.  Either paramter can be optional.

        If you don't choose a path, one is provided for you that is OS specific
        Windows path default = users/name/AppData/Local/PySimpleGUI/settings.

        If you don't choose a filename, your application's filename + '.json' will be used.

        Normally the filename and path are split in the user_settings calls. However for this call they
        can be combined so that the filename contains both the path and filename.

        :param filename: The name of the file to use. Can be a full path and filename or just filename
        :type filename:  (str or None)
        :param path:     The folder that the settings file will be stored in. Do not include the filename.
        :type path:      (str or None)
        :return:         The full pathname of the settings file that has both the path and filename combined.
        :rtype:          (str)
        """
        ...
    
    def save(self, filename=..., path=...): # -> None:
        """
        Saves the current settings dictionary.  If a filename or path is specified in the call, then it will override any
        previously specitfied filename to create a new settings file.  The settings dictionary is then saved to the newly defined file.

        :param filename: The fFilename to save to. Can specify a path or just the filename. If no filename specified, then the caller's filename will be used.
        :type filename:  (str or None)
        :param path:     The (optional) path to use to save the file.
        :type path:      (str or None)
        :return:         The full path and filename used to save the settings
        :rtype:          (str)
        """
        ...
    
    def load(self, filename=..., path=...): # -> Any | dict[Unknown, Unknown]:
        """
        Specifies the path and filename to use for the settings and reads the contents of the file.
        The filename can be a full filename including a path, or the path can be specified separately.
        If  no filename is specified, then the caller's filename will be used with the extension ".json"

        :param filename: Filename to load settings from (and save to in the future)
        :type filename:  (str or None)
        :param path:     Path to the file. Defaults to a specific folder depending on the operating system
        :type path:      (str or None)
        :return:         The settings dictionary (i.e. all settings)
        :rtype:          (dict)
        """
        ...
    
    def delete_file(self, filename=..., path=..., report_error=...): # -> None:
        """
        Deltes the filename and path for your settings file.  Either paramter can be optional.
        If you don't choose a path, one is provided for you that is OS specific
        Windows path default = users/name/AppData/Local/PySimpleGUI/settings.
        If you don't choose a filename, your application's filename + '.json' will be used
        Also sets your current dictionary to a blank one.

        :param filename:     The name of the file to use. Can be a full path and filename or just filename
        :type filename:      (str or None)
        :param path:         The folder that the settings file will be stored in. Do not include the filename.
        :type path:          (str or None)
        :param report_error: Determines if an error should be shown if a delete error happen (i.e. file isn't present)
        :type report_error:  (bool)
        """
        ...
    
    def write_new_dictionary(self, settings_dict): # -> None:
        """
        Writes a specified dictionary to the currently defined settings filename.

        :param settings_dict: The dictionary to be written to the currently defined settings file
        :type settings_dict:  (dict)
        """
        ...
    
    def read(self): # -> Any | dict[Unknown, Unknown]:
        """
        Reads settings file and returns the dictionary.
        If you have anything changed in an existing settings dictionary, you will lose your changes.
        :return: settings dictionary
        :rtype:  (dict)
        """
        ...
    
    def exists(self, filename=..., path=...): # -> bool:
        """
        Check if a particular settings file exists.  Returns True if file exists

        :param filename: The name of the file to use. Can be a full path and filename or just filename
        :type filename:  (str or None)
        :param path:     The folder that the settings file will be stored in. Do not include the filename.
        :type path:      (str or None)
        """
        ...
    
    def delete_entry(self, key, section=...): # -> None:
        """
        Deletes an individual entry.  If no filename has been specified up to this point,
        then a default filename will be used.
        After value has been deleted, the settings file is written to disk.

        :param key: Setting to be deleted. Can be any valid dictionary key type (i.e. must be hashable)
        :type key:  (Any)
        """
        ...
    
    def delete_section(self, section): # -> None:
        """
        Deletes a section with the name provided in the section parameter.  Your INI file will be saved afterwards if auto-save enabled (default is ON)
        :param section:     Name of the section to delete
        :type section:      str
        """
        ...
    
    def set(self, key, value):
        """
        Sets an individual setting to the specified value.  If no filename has been specified up to this point,
        then a default filename will be used.
        After value has been modified, the settings file is written to disk.
        Note that this call is not value for a config file normally. If it is, then the key is assumed to be the
            Section key and the value written will be the default value.
        :param key:      Setting to be saved. Can be any valid dictionary key type
        :type key:       (Any)
        :param value:    Value to save as the setting's value. Can be anything
        :type value:     (Any)
        :return:         value that key was set to
        :rtype:          (Any)
        """
        ...
    
    def get(self, key, default=...): # -> Any | None:
        """
        Returns the value of a specified setting.  If the setting is not found in the settings dictionary, then
        the user specified default value will be returned.  It no default is specified and nothing is found, then
        the "default value" is returned.  This default can be specified in this call, or previously defined
        by calling set_default. If nothing specified now or previously, then None is returned as default.

        :param key:     Key used to lookup the setting in the settings dictionary
        :type key:      (Any)
        :param default: Value to use should the key not be found in the dictionary
        :type default:  (Any)
        :return:        Value of specified settings
        :rtype:         (Any)
        """
        ...
    
    def get_dict(self): # -> Any | dict[Unknown, Unknown]:
        """
        Returns the current settings dictionary.  If you've not setup the filename for the
        settings, a default one will be used and then read.

        Note that you can display the dictionary in text format by printing the object itself.

        :return: The current settings dictionary
        :rtype:  Dict
        """
        ...
    
    def __setitem__(self, item, value):
        """
        Enables setting a setting by using [ ] notation like a dictionary.
        Your code will have this kind of design pattern:
        settings = sg.UserSettings()
        settings[item] = value

        :param item:  The key for the setting to change. Needs to be a hashable type. Basically anything but a list
        :type item:   Any
        :param value: The value to set the setting to
        :type value:  Any
        """
        ...
    
    def __getitem__(self, item): # -> Any | None:
        """
        Enables accessing a setting using [ ] notation like a dictionary.
        If the entry does not exist, then the default value will be returned.  This default
        value is None unless user sets by calling UserSettings.set_default_value(default_value)

        :param item: The key for the setting to change. Needs to be a hashable type. Basically anything but a list
        :type item:  Any
        :return:     The setting value
        :rtype:      Any
        """
        ...
    
    def __delitem__(self, item): # -> Any | None:
        """
        Delete an individual user setting.  This is the same as calling delete_entry.  The syntax
        for deleting the item using this manner is:
            del settings['entry']
        :param item: The key for the setting to delete
        :type item:  Any
        """
        ...
    


if UserSettings._default_for_function_interface is None:
    ...
def user_settings_filename(filename=..., path=...): # -> None:
    """
    Sets the filename and path for your settings file.  Either paramter can be optional.

    If you don't choose a path, one is provided for you that is OS specific
    Windows path default = users/name/AppData/Local/PySimpleGUI/settings.

    If you don't choose a filename, your application's filename + '.json' will be used.

    Normally the filename and path are split in the user_settings calls. However for this call they
    can be combined so that the filename contains both the path and filename.

    :param filename: The name of the file to use. Can be a full path and filename or just filename
    :type filename:  (str)
    :param path:     The folder that the settings file will be stored in. Do not include the filename.
    :type path:      (str)
    :return:         The full pathname of the settings file that has both the path and filename combined.
    :rtype:          (str)
    """
    ...

def user_settings_delete_filename(filename=..., path=..., report_error=...): # -> None:
    """
    Deltes the filename and path for your settings file.  Either paramter can be optional.
    If you don't choose a path, one is provided for you that is OS specific
    Windows path default = users/name/AppData/Local/PySimpleGUI/settings.
    If you don't choose a filename, your application's filename + '.json' will be used
    Also sets your current dictionary to a blank one.

    :param filename: The name of the file to use. Can be a full path and filename or just filename
    :type filename:  (str)
    :param path:     The folder that the settings file will be stored in. Do not include the filename.
    :type path:      (str)
    """
    ...

def user_settings_set_entry(key, value): # -> None:
    """
    Sets an individual setting to the specified value.  If no filename has been specified up to this point,
    then a default filename will be used.
    After value has been modified, the settings file is written to disk.

    :param key:   Setting to be saved. Can be any valid dictionary key type
    :type key:    (Any)
    :param value: Value to save as the setting's value. Can be anything
    :type value:  (Any)
    """
    ...

def user_settings_delete_entry(key): # -> None:
    """
    Deletes an individual entry.  If no filename has been specified up to this point,
    then a default filename will be used.
    After value has been deleted, the settings file is written to disk.

    :param key: Setting to be saved. Can be any valid dictionary key type (hashable)
    :type key:  (Any)
    """
    ...

def user_settings_get_entry(key, default=...): # -> Any | None:
    """
    Returns the value of a specified setting.  If the setting is not found in the settings dictionary, then
    the user specified default value will be returned.  It no default is specified and nothing is found, then
    None is returned.  If the key isn't in the dictionary, then it will be added and the settings file saved.
    If no filename has been specified up to this point, then a default filename will be assigned and used.
    The settings are SAVED prior to returning.

    :param key:     Key used to lookup the setting in the settings dictionary
    :type key:      (Any)
    :param default: Value to use should the key not be found in the dictionary
    :type default:  (Any)
    :return:        Value of specified settings
    :rtype:         (Any)
    """
    ...

def user_settings_save(filename=..., path=...): # -> None:
    """
    Saves the current settings dictionary.  If a filename or path is specified in the call, then it will override any
    previously specitfied filename to create a new settings file.  The settings dictionary is then saved to the newly defined file.

    :param filename: The fFilename to save to. Can specify a path or just the filename. If no filename specified, then the caller's filename will be used.
    :type filename:  (str)
    :param path:     The (optional) path to use to save the file.
    :type path:      (str)
    :return:         The full path and filename used to save the settings
    :rtype:          (str)
    """
    ...

def user_settings_load(filename=..., path=...): # -> Any | dict[Unknown, Unknown]:
    """
    Specifies the path and filename to use for the settings and reads the contents of the file.
    The filename can be a full filename including a path, or the path can be specified separately.
    If  no filename is specified, then the caller's filename will be used with the extension ".json"

    :param filename: Filename to load settings from (and save to in the future)
    :type filename:  (str)
    :param path:     Path to the file. Defaults to a specific folder depending on the operating system
    :type path:      (str)
    :return:         The settings dictionary (i.e. all settings)
    :rtype:          (dict)
    """
    ...

def user_settings_file_exists(filename=..., path=...): # -> bool:
    """
    Determines if a settings file exists.  If so a boolean True is returned.
    If either a filename or a path is not included, then the appropriate default
    will be used.

    :param filename: Filename to check
    :type filename:  (str)
    :param path:     Path to the file. Defaults to a specific folder depending on the operating system
    :type path:      (str)
    :return:         True if the file exists
    :rtype:          (bool)
    """
    ...

def user_settings_write_new_dictionary(settings_dict): # -> None:
    """
    Writes a specified dictionary to the currently defined settings filename.

    :param settings_dict: The dictionary to be written to the currently defined settings file
    :type settings_dict:  (dict)
    """
    ...

def user_settings_silent_on_error(silent_on_error=...): # -> None:
    """
    Used to control the display of error messages.  By default, error messages are displayed to stdout.

    :param silent_on_error: If True then all error messages are silenced (not displayed on the console)
    :type silent_on_error:  (bool)
    """
    ...

def user_settings(): # -> Any | dict[Unknown, Unknown]:
    """
    Returns the current settings dictionary.  If you've not setup the filename for the
    settings, a default one will be used and then read.
    :return:            The current settings dictionary as a dictionary or a nicely formatted string representing it
    :rtype:             (dict or str)
    """
    ...

def user_settings_object(): # -> UserSettings:
    """
    Returns the object that is used for the function version of this API.
    With this object you can use the object interface, print it out in a nice format, etc.

    :return:    The UserSettings obect used for the function level interface
    :rtype:     (UserSettings)
    """
    ...

def execute_command_subprocess(command, *args, wait=..., cwd=..., pipe_output=..., merge_stderr_with_stdout=..., stdin=...):
    """
    Runs the specified command as a subprocess.
    By default the call is non-blocking.
    The function will immediately return without waiting for the process to complete running. You can use the returned Popen object to communicate with the subprocess and get the results.
    Returns a subprocess Popen object.

    :param command:                  Filename to load settings from (and save to in the future)
    :type command:                   (str)
    :param *args:                    Variable number of arguments that are passed to the program being started as command line parms
    :type *args:                     (Any)
    :param wait:                     If True then wait for the subprocess to finish
    :type wait:                      (bool)
    :param cwd:                      Working directory to use when executing the subprocess
    :type cwd:                       (str))
    :param pipe_output:              If True then output from the subprocess will be piped. You MUST empty the pipe by calling execute_get_results or your subprocess will block until no longer full
    :type pipe_output:               (bool)
    :param merge_stderr_with_stdout: If True then output from the subprocess stderr will be merged with stdout. The result is ALL output will be on stdout.
    :type merge_stderr_with_stdout:  (bool)
    :param stdin:                    Value passed to the Popen call. Defaults to subprocess.DEVNULL so that the pyinstaller created executable work correctly
    :type stdin:                     (bool)
    :return:                         Popen object
    :rtype:                          (subprocess.Popen)
    """
    ...

def execute_py_file(pyfile, parms=..., cwd=..., interpreter_command=..., wait=..., pipe_output=..., merge_stderr_with_stdout=...): # -> None:
    """
    Executes a Python file.
    The interpreter to use is chosen based on this priority order:
        1. interpreter_command paramter
        2. global setting "-python command-"
        3. the interpreter running running PySimpleGUI
    :param pyfile:                   the file to run
    :type pyfile:                    (str)
    :param parms:                    parameters to pass on the command line
    :type parms:                     (str)
    :param cwd:                      the working directory to use
    :type cwd:                       (str)
    :param interpreter_command:      the command used to invoke the Python interpreter
    :type interpreter_command:       (str)
    :param wait:                     the working directory to use
    :type wait:                      (bool)
    :param pipe_output:              If True then output from the subprocess will be piped. You MUST empty the pipe by calling execute_get_results or your subprocess will block until no longer full
    :type pipe_output:               (bool)
    :param merge_stderr_with_stdout: If True then output from the subprocess stderr will be merged with stdout. The result is ALL output will be on stdout.
    :type merge_stderr_with_stdout:  (bool)
    :return:                         Popen object
    :rtype:                          (subprocess.Popen) | None
    """
    ...

def execute_py_get_interpreter(): # -> str | Any | None:
    """
    Returns the command that is currently running. Previously returned the one from the system settings, but
    have determined that the one currently running is the better choice.

    :return: Full path to python interpreter (uses sys.executable)
    :rtype:  (str)
    """
    ...

def execute_editor(file_to_edit, line_number=...): # -> None:
    """
    Runs the editor that was configured in the global settings and opens the file to a specific line number.
    Two global settings keys are used.
    '-editor program-' the command line used to startup your editor. It's set
        in the global settings window or by directly manipulating the PySimpleGUI settings object
    '-editor format string-' a string containing 3 "tokens" that describes the command that is executed
            <editor> <file> <line>
    :param file_to_edit: the full path to the file to edit
    :type file_to_edit:  (str)
    :param line_number:  optional line number to place the cursor
    :type line_number:   (int)
    :return:             Popen object
    :rtype:              (subprocess.Popen) | None
    """
    ...

def execute_get_results(subprocess_id, timeout=...): # -> tuple[Unknown | None, Unknown | None]:
    """
    Get the text results of a previously executed execute call
    Returns a tuple of the strings (stdout, stderr)
    :param subprocess_id: a Popen subprocess ID returned from a previous execute call
    :type subprocess_id:  (subprocess.Popen)
    :param timeout:       Time in fractions of a second to wait. Returns '','' if timeout. Default of None means wait forever
    :type timeout:        (None | float)
    :returns:             Tuple with 2 strings (stdout, stderr)
    :rtype:               (str | None , str | None)
    """
    ...

def execute_subprocess_still_running(subprocess_id): # -> bool:
    """
    Returns True is the subprocess ID provided is for a process that is still running

    :param subprocess_id: ID previously returned from Exec API calls that indicate this value is returned
    :type subprocess_id:  (subprocess.Popen)
    :return:              True if the subproces is running
    :rtype:               bool
    """
    ...

def execute_file_explorer(folder_to_open=...): # -> None:
    """
    The global settings has a setting called -   "-explorer program-"
    It defines the program to run when this function is called.
    The optional folder paramter specified which path should be opened.

    :param folder_to_open: The path to open in the explorer program
    :type folder_to_open:  str
    :return:               Popen object
    :rtype:                (subprocess.Popen) | None
    """
    ...

def execute_find_callers_filename(): # -> str:
    """
    Returns the first filename found in a traceback that is not the nsame of this file (__file__)
    Used internally with the debugger for example.

    :return: filename of the caller, asseumed to be the first non PySimpleGUI file
    :rtype:  str
    """
    ...

MAC_PATCH_DICT = ...
def main_mac_feature_control(): # -> None:
    """
    Window to set settings that will be used across all PySimpleGUI programs that choose to use them.
    Use set_options to set the path to the folder for all PySimpleGUI settings.

    :return: True if settings were changed
    :rtype:  (bool)
    """
    ...

red_x = ...
COLOR_SCHEME = ...
DEBUGGER_POPOUT_THEME = ...
WIDTH_VARIABLES = ...
WIDTH_RESULTS = ...
WIDTH_WATCHER_VARIABLES = ...
WIDTH_WATCHER_RESULTS = ...
WIDTH_LOCALS = ...
NUM_AUTO_WATCH = ...
MAX_LINES_PER_RESULT_FLOATING = ...
MAX_LINES_PER_RESULT_MAIN = ...
POPOUT_WINDOW_FONT = ...
DEBUGGER_VARIABLE_DETAILS_FONT = ...
class _Debugger:
    debugger = ...
    def __init__(self) -> None:
        ...
    


def show_debugger_window(location=..., *args): # -> Literal[True]:
    """
    Shows the large main debugger window
    :param location: Locations (x,y) on the screen to place upper left corner of the window
    :type location:  (int, int)
    :return:         None
    :rtype:          None
    """
    ...

def show_debugger_popout_window(location=..., *args): # -> None:
    """
    Shows the smaller "popout" window.  Default location is the upper right corner of your screen

    :param location: Locations (x,y) on the screen to place upper left corner of the window
    :type location:  (int, int)
    :return:         None
    :rtype:          None
    """
    ...

def get_versions(): # -> str:
    """
    Returns a human-readable string of version numbers for:

    Python version
    PySimpleGUI Port (tkinter in this case)
    tkinter version
    PySimpleGUI version
    The location of the PySimpleGUI.py file

    The format is a newline between each value and descriptive text for each line

    :return:
    :rtype:  str
    """
    ...

EMOJI_BASE64_FACEPALM = ...
EMOJI_BASE64_FRUSTRATED = ...
EMOJI_BASE64_NOTUNDERSTANDING = ...
EMOJI_BASE64_PONDER = ...
EMOJI_BASE64_SAD = ...
EMOJI_BASE64_SKEPTICAL = ...
EMOJI_BASE64_THINK = ...
EMOJI_BASE64_DREAMING = ...
EMOJI_BASE64_WEARY = ...
EMOJI_BASE64_YIKES = ...
EMOJI_BASE64_HAPPY_GASP = ...
EMOJI_BASE64_HAPPY_IDEA = ...
EMOJI_BASE64_HAPPY_JOY = ...
EMOJI_BASE64_HAPPY_LAUGH = ...
EMOJI_BASE64_HAPPY_STARE = ...
ICON_BUY_ME_A_COFFEE = ...
EMOJI_BASE64_HAPPY_RELIEF = ...
EMOJI_BASE64_HAPPY_BIG_SMILE = ...
EMOJI_BASE64_HAPPY_CONTENT = ...
EMOJI_BASE64_HAPPY_HEARTS = ...
EMOJI_BASE64_HAPPY_THUMBS_UP = ...
EMOJI_BASE64_HAPPY_WINK = ...
EMOJI_BASE64_CRY = ...
EMOJI_BASE64_DEAD = ...
EMOJI_BASE64_FINGERS_CROSSED = ...
EMOJI_BASE64_GUESS = ...
EMOJI_BASE64_CLAP = ...
EMOJI_BASE64_NO_HEAR = ...
EMOJI_BASE64_NO_SEE = ...
EMOJI_BASE64_NO_SPEAK = ...
EMOJI_BASE64_PRAY = ...
EMOJI_BASE64_ZIPPED_SHUT = ...
EMOJI_BASE64_NO_HEAR = ...
EMOJI_BASE64_MIKE = ...
EMOJI_BASE64_SUPERHERO = ...
EMOJI_BASE64_HAPPY_LIST = ...
EMOJI_BASE64_SAD_LIST = ...
EMOJI_BASE64_LIST = ...
HEART_FLAT_BASE64 = ...
HEART_3D_BASE64 = ...
PYTHON_COLORED_HEARTS_BASE64 = ...
RED_X_BASE64 = ...
GREEN_CHECK_BASE64 = ...
def main_open_github_issue(): # -> None:
    ...

main_upgrade_from_github = ...
def main_get_debug_data(suppress_popup=...): # -> str:
    """
    Collect up and display the data needed to file GitHub issues.
    This function will place the information on the clipboard.
    You MUST paste the information from the clipboard prior to existing your application (except on Windows).
    :param suppress_popup: If True no popup window will be shown. The string will be only returned, not displayed
    :type suppress_popup:  (bool)
    :returns:              String containing the information to place into the GitHub Issue
    :rtype:                (str)
    """
    ...

def main_global_get_screen_snapshot_symcode(): # -> Any | str:
    ...

def main_global_pysimplegui_settings_erase(): # -> None:
    """
    *** WARNING ***
    Deletes the PySimpleGUI settings file without asking for verification


    """
    ...

def main_global_pysimplegui_settings(): # -> bool:
    """
    Window to set settings that will be used across all PySimpleGUI programs that choose to use them.
    Use set_options to set the path to the folder for all PySimpleGUI settings.

    :return: True if settings were changed
    :rtype:  (bool)
    """
    ...

def main_sdk_help(): # -> None:
    """
    Display a window that will display the docstrings for each PySimpleGUI Element and the Window object

    """
    ...

def main(): # -> None:
    """
    The PySimpleGUI "Test Harness".  This is meant to be a super-quick test of the Elements.
    """
    ...

ChangeLookAndFeel = ...
ConvertArgsToSingleString = ...
EasyPrint = ...
Print = ...
eprint = ...
sgprint = ...
PrintClose = ...
sgprint_close = ...
EasyPrintClose = ...
FillFormWithValues = ...
GetComplimentaryHex = ...
ListOfLookAndFeelValues = ...
ObjToString = ...
ObjToStringSingleObj = ...
OneLineProgressMeter = ...
OneLineProgressMeterCancel = ...
Popup = ...
PopupNoFrame = ...
popup_no_frame = ...
PopupNoBorder = ...
popup_no_border = ...
PopupAnnoying = ...
popup_annoying = ...
PopupAnimated = ...
PopupAutoClose = ...
PopupCancel = ...
PopupError = ...
PopupGetFile = ...
PopupGetFolder = ...
PopupGetText = ...
PopupNoButtons = ...
PopupNoTitlebar = ...
PopupNoWait = ...
popup_no_wait = ...
PopupNonBlocking = ...
PopupOK = ...
PopupOKCancel = ...
PopupQuick = ...
PopupQuickMessage = ...
PopupScrolled = ...
PopupTimed = ...
popup_timed = ...
PopupYesNo = ...
RGB = ...
SetGlobalIcon = ...
SetOptions = ...
sprint = ...
ScrolledTextBox = ...
TimerStart = ...
TimerStop = ...
test = ...
sdk_help = ...
pysimplegui_user_settings = ...
if running_trinket():
    USE_CUSTOM_TITLEBAR = ...
if tclversion_detailed.startswith('8.5'):
    ...
if running_windows():
    ...
if _mac_should_set_alpha_to_99():
    ...
if __name__ == '__main__':
    ...
